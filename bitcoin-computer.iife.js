var t=function(t,e,n,r,s,o){"use strict";function i(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}function c(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,r.get?r:{enumerable:!0,get:function(){return t[n]}})}})),e.default=t,Object.freeze(e)}var a=i(n);var u=i(r);var d=i(s);var h=c(o);
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */function l(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(t);s<r.length;s++)e.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(t,r[s])&&(n[r[s]]=t[r[s]])}return n}function f(t,e,n,r){var s,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,r);else for(var c=t.length-1;c>=0;c--)(s=t[c])&&(i=(o<3?s(i):o>3?s(e,n,i):s(e,n))||i);return o>3&&i&&Object.defineProperty(e,n,i),i}function p(t,e,n,r){return new(n||(n=Promise))((function(s,o){function i(t){try{a(r.next(t))}catch(t){o(t)}}function c(t){try{a(r.throw(t))}catch(t){o(t)}}function a(t){var e;t.done?s(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(i,c)}a((r=r.apply(t,e||[])).next())}))}const v=process.env.BC_CHAIN||"BSV";const _=process.env.BC_NETWORK||"testnet";const g=parseInt(process.env.BC_DUST_LIMIT||"",10)||4e3;const b=parseInt(process.env.BC_DEFAULT_FEE||"",10)||("BSV"===v?500:2500);const w=parseInt(process.env.BC_SCRIPT_CHUNK_SIZE||"",10)||("BSV"===v?1/0:479);const y=process.env.BSV_TESTNET_BBS_URL?process.env.BSV_TESTNET_BBS_URL:"http://50.18.114.11";const m=process.env.BCH_TESTNET_BBS_URL?process.env.BCH_TESTNET_BBS_URL:"http://13.52.113.43";let O="";"BSV"===v&&"testnet"===_&&(O=y),"BCH"===v&&"testnet"===_&&(O=m);const x=t=>{O=t};const S=new URL(O).origin;var j={CHAIN:v,NETWORK:_,MIN_NON_DUST_AMOUNT:g,SCRIPT_CHUNK_SIZE:w,BBS_URL:O,setBbsUrl:x,BBS_ORIGIN:S,DEFAULT_FEE:b};const I=t=>{const n=Date.now();const r=e.crypto.Hash.sha256(Buffer.from(j.BBS_ORIGIN+n));const s=[e.crypto.ECDSA.sign(r,t,"big").toString("hex"),t.publicKey.toString(),n];return`Bearer ${Buffer.from(s.join(":")).toString("base64")}`};const E=(t,e={})=>{const{path:n="m/44'/0'/0'/0",passphrase:r=""}=e;let s=t.toHDPrivateKey(r,j.NETWORK);return n&&(s=s.derive(n)),s.privateKey};function $(t){try{const n=JSON.parse(t);if("object"!=typeof n)throw new Error("Invalid object");if("string"!=typeof n.txhex)throw new Error("Invalid object");return new e.Transaction(n.txhex)}catch(t){return null}}function B(t){return p(this,void 0,void 0,(function*(){const{message:e,config:n,response:r}=t;const s=$(null==n?void 0:n.data);const o=`message\t${e}`;const i=`request\t${null==n?void 0:n.method} ${null==n?void 0:n.url}`;const c=s?`transaction\t ${JSON.stringify(s.toJSON(),null,2)}`:"";const a="post"===(null==n?void 0:n.method)?`data\t${null==n?void 0:n.data}`:"";const u=r?`response\t${JSON.stringify(r.data)}`:"";const d=s?c:a;throw t.message=`\n    Communication Error\n    ${o}\n    ${i}\n    ${d}\n    ${u}`,t}))}class R{constructor(t,e={},n){this.baseUrl=t,this.headers=e,this.privateKey=n}get(t){return p(this,void 0,void 0,(function*(){const e=`${this.baseUrl}${t}`;try{let t={};return this.privateKey&&(t={Authentication:I(this.privateKey)}),(yield a.default.get(e,{headers:Object.assign(Object.assign({},this.headers),t)})).data}catch(t){return B(t)}}))}post(t,e){return p(this,void 0,void 0,(function*(){const n=`${this.baseUrl}${t}`;try{let t={};return this.privateKey&&(t={Authentication:I(this.privateKey)}),(yield a.default.post(n,e,{headers:Object.assign(Object.assign({},this.headers),t)})).data}catch(t){return B(t)}}))}delete(t){return p(this,void 0,void 0,(function*(){const e=`${this.baseUrl}${t}`;try{let t={};return this.privateKey&&(t={Authentication:I(this.privateKey)}),(yield a.default.delete(e,{headers:Object.assign(Object.assign({},this.headers),t)})).data}catch(t){return B(t)}}))}}function T(t){return void 0!==t._url}function D(t){return void 0!==t.__cypher&&void 0!==t.__secrets}const C=()=>t=>t;function K(t){if(!/^[0-9A-Fa-f]{64}$/.test(t))throw new Error(`Invalid txId: ${t}`)}function N(t){if(!/^[0-9A-Fa-f]{64}:\d+$/.test(t))throw new Error(`Invalid outId: ${t}`)}function P(t){N(t);const[e,n]=t.split(":");return{txId:e,outIndex:parseInt(n,10)}}let A=class{constructor(t=j.CHAIN,n=j.NETWORK,r=new e.PrivateKey){this.chain=t,this.network=n,this.bbs=new R(j.BBS_URL,{},r)}getBalance(t){return p(this,void 0,void 0,(function*(){return yield this.bbs.get(`/balance/${t}`)}))}getTransaction(t){return p(this,void 0,void 0,(function*(){return new e.Transaction(yield this.getRawTx(t))}))}getRawTx(t){return p(this,void 0,void 0,(function*(){K(t);const e="livenet"===this.network?"main":"test";return this.bbs.get(`/tx/${this.chain}/${e}/${t}`)}))}getRawTxData(t){return p(this,void 0,void 0,(function*(){K(t);const e="livenet"===this.network?"main":"test";return this.bbs.get(`/tx-data/${this.chain}/${e}/${t}`)}))}getTransactions(t){return p(this,void 0,void 0,(function*(){return(yield this.getRawTxs(t)).map((t=>new e.Transaction(t)))}))}getRawTxs(t){return p(this,void 0,void 0,(function*(){t.map(K);const e="livenet"===this.network?"main":"test";return this.bbs.post(`/tx-bulk/${this.chain}/${e}`,{txIds:t})}))}sendTransaction(t){return p(this,void 0,void 0,(function*(){return this.bbs.post("/tx",{rawTx:t})}))}getUtxosFromAddress(t){return p(this,void 0,void 0,(function*(){return this.bbs.get(`/utxos/${t.toString()}`)}))}postOutData(t){return p(this,void 0,void 0,(function*(){return this.bbs.post("/postOutData",t)}))}getOutData(t){return p(this,void 0,void 0,(function*(){return this.bbs.get(`/un-p2sh/${t}`)}))}getOwnedRevs(t){return p(this,void 0,void 0,(function*(){return this.bbs.get(`/txos/${t.toString()}`)}))}queryRevs(t){return p(this,void 0,void 0,(function*(){const{publicKey:e,contractName:n,contractHash:r}=t;if(void 0===e&&void 0===n&&void 0===r)throw new Error("Filter parameter for queryRevs endpoint cannot be empty.");let s="";return e&&(s+=`?publicKey=${e}`),n&&(s+=0===s.length?"?":"&",s+=`contractName=${n}`),r&&(s+=0===s.length?"?":"&",s+=`contractHash=${r}`),this.bbs.get(`/query-revs${s}`)}))}getLatestRev(t){return p(this,void 0,void 0,(function*(){N(t);const[{rev:e}]=yield this.bbs.get(`/get-rev/${t}`);return e}))}getLatestRevs(t){return p(this,void 0,void 0,(function*(){return t.map(N),t.map(N),yield this.bbs.post("/get-revs",{ids:t})}))}static getSecretOutput({_url:t,privateKey:e}){return p(this,void 0,void 0,(function*(){const n=t.split("/");const r=n[n.length-1];const s=n.slice(0,-2).join("/");const o=new R(s,{},e);return{host:s,data:yield o.get(`/store/${r}`)}}))}static setSecretOutput({secretOutput:t,host:e,privateKey:n}){return p(this,void 0,void 0,(function*(){return new R(e,{},n).post("/store/",t)}))}static deleteSecretOutput({_url:t,privateKey:e}){return p(this,void 0,void 0,(function*(){const n=t.split("/");const r=n[n.length-1];const s=n.slice(0,-2).join("/");const o=new R(s,{},e);yield o.delete(`/store/${r}`)}))}};A=f([C()],A);const U=()=>`__temp__:${Math.random()}`;const H=["_id","_rev","_owners","_amount","_readers","_url","__vouts","__cls","__func","__index","__args"];const k=t=>(Object.prototype.toString.call(t).match(/\s([a-zA-Z]+)/)||[])[1];const V=t=>"object"==typeof t?k(t):k(t).toLowerCase();const F=t=>["number","string","boolean","undefined","Null"].includes(V(t));const L=t=>"Array"===V(t);const J=t=>"Object"===V(t);const M=t=>F(t)||["Array","Object"].includes(V(t));const W=t=>"Object"===V(t)&&Object.keys(t).every((t=>!Number.isNaN(parseInt(t,10))));const q=(t,e)=>{if(!M(t)||!M(e))throw new Error(`Unsupported data types for deep equals: ${V(t)} & ${V(e)}`);if(V(t)!==V(e))return!1;if(F(t)&&F(e))return t===e;const n=(t,e)=>Object.entries(t).every((([t,n])=>q(e[t],n)));return t&&e&&n(t,e)&&n(e,t)};const Z=t=>{if(F(t))return t;if(L(t))return t.map(Z);if(J(t)){const e=Object.keys(t).reduce(((e,n)=>(e[n]=Z(t[n]),e)),{});const n=Object.create(Object.getPrototypeOf(t));return Object.assign(n,e)}throw new Error(`Unsupported data type for clone: ${V(t)}`)};const G=(t,e)=>t.reduce((([t,n],r,s)=>e(r,s)?[[...t,r],n]:[t,[...n,r]]),[[],[]]);const z=(t,e)=>Object.fromEntries(Object.entries(t).map((t=>e(t))));const Q=(t,e)=>z(t,(([t,n])=>[t,e(n)]));const X=(t,e)=>Object.fromEntries(Object.entries(t).filter((([,t])=>e(t))));const Y=(t,e,n,r)=>{if(F(t))return t;if(L(t))return t.map((t=>Y(t,e,n,r)));if(J(t)){t._rev=`${r}:${n}`;const s=e[n];return Object.entries(t).forEach((([n,o])=>{"object"==typeof s&&Object.keys(s).includes(n)&&(t[n]=Y(o,e,s[n],r))})),t}throw new Error(`Unsupported type ${V(t)} in deep.updateRev`)};const tt=t=>{if(F(t))return t;if(L(t))return t.map((t=>tt(t)));if(J(t))return t.__cls=t.constructor.toString(),Object.entries(t).forEach((([e,n])=>{t[e]=tt(n)})),t;throw new Error(`Unsupported type ${V(t)} in deep.addClass`)};const et=(t,e)=>{if(F(t))return t;if(L(t))return t.map((t=>et(t,e)));if(J(t))return t._id=!t._id||t._id.startsWith("__temp__")?t._rev:t._id,t._rootId=t._rootId||e,Object.entries(t).forEach((([n,r])=>{t[n]=et(r,e)})),t;throw new Error(`Unsupported type ${V(t)} in deep.addId`)};const nt=t=>{if(F(t))return t;if(L(t))return t.map((t=>nt(t)));if(J(t)){const e=U();return t._id=t._id||e,t._rev=t._rev||e,Object.values(t).map((t=>nt(t))),t}throw new Error(`Unsupported type ${V(t)} in addRandomId`)};const rt=t=>{if(F(t))return t;if(L(t))return t.map((t=>rt(t)));if(J(t))return z(t,(([t,e])=>["_owners","_readers","_url"].includes(t)?[t,JSON.stringify(e)]:F(e)?[t,e]:[t,rt(e)]));throw new Error(`Unexpected type ${V(t)} in stringifyOwners`)};const st=t=>(t._owners&&(t._owners=JSON.parse(t._owners)),t._readers&&(t._readers=JSON.parse(t._readers)),t._url&&(t._url=JSON.parse(t._url)),t);const ot=t=>{if(F(t))return t;if(L(t)||J(t))return Object.entries(t).reduce(((t,[e,n])=>{const r=ot(n);return W(r)?Object.entries(r).forEach((([n,r])=>{t[`${e}_${n}`]=r})):t[e]=r,t}),{});throw new Error(`Unsupported type ${V(t)} in encodeArraysAsObjects`)};const it=t=>{const e={[t._id]:Object.entries(t).reduce(((t,[e,n])=>H.includes(e)?Object.assign(Object.assign({},t),{[e]:n}):F(n)?Object.assign(Object.assign({},t),{[`__basic__${e}`]:n}):Object.assign(Object.assign({},t),{[e]:n._id})),{})};return Object.values(t).filter((t=>!F(t))).reduce(((t,e)=>Object.assign(Object.assign({},t),it(e))),e)};const ct=t=>Object.fromEntries(Object.entries(t).filter((([t])=>!t.startsWith("__basic__"))));const at=(t,e)=>Object.fromEntries(Object.entries(e).map((([e,n])=>{const r=t[e];var s;return n.__change=(s=r)?q(s,n)?"same":"diff":"new",[e,n]})));const ut=(t,e)=>(t[e].__contains=Object.entries(t[e]).reduce(((e,[n,r])=>["__contains"].concat(H).includes(n)?e:"__change"===n?"new"===r||"diff"===r||e:ut(t,r)[r].__contains||e),!1),t);const dt=t=>t.reduce(((t,e,n)=>Object.assign(Object.assign({},t),{[e._id]:n})),{});const ht=(t,e)=>t.map((t=>Object.entries(t).reduce(((t,[n,r])=>{const s="string"==typeof r&&"undefined"!==V(e[r])?e[r]:r;return Object.assign(Object.assign({},t),{[n]:s})}),{})));const lt=(t,e,n)=>{const[r,...s]=[e,...t].map(((t,e)=>{const r=l(t,["_id","_rev","__change","__contains"]);return 0===e||e<=n.length?l(r,["__cls"]):r}));return[r,...s.map((t=>Object.fromEntries(Object.entries(t).filter((([t,e])=>H.filter((t=>"__cls"!==t)).includes(t)||"__cls"===t&&"string"==typeof e&&"function Object() { [native code] }"!==e||"number"==typeof e)))))]};const ft=(t,e)=>{const n=nt(e);const r=n._id;const s=Z(t);const o=Z(n);tt(s),tt(o);const i=rt(s);const c=rt(o);const a=ot(i);const u=ot(c);const d=it(a);const h=it(u);const l=at(d,h);const f=Q(l,ct);const p=ut(f,r);const v=p[r];delete v.__cls,delete p[r];const _=Q(p,(t=>t._rev));const g=X(p,(t=>t.__contains||Object.values(v).includes(t._id)));const b=Object.values(g);const[w,y]=G(b,(t=>"new"===t.__change));const m=[...y,...w];const O=dt(m);const x=ht(m,O);const[S]=ht([v],O);const j=y.map((t=>t._rev));const[I,...E]=lt(x,S,j);return[j,E.map(st).map((t=>Object.entries(t).reduce(((t,[e,n])=>Object.assign(Object.assign({},t),{[e]:_[n]||n})),{}))),I]};function pt(t,e){let n=0;return e.map((e=>"__"===e?t[n++]:e))}class vt{constructor(t){this.db=t}get(t){return p(this,void 0,void 0,(function*(){const{txId:e,outIndex:n}=P(t);const{inRevs:r,outData:s}=yield this.db.fromTxId(e);if(!Array.isArray(r)||!Array.isArray(s)||0===s.length)return;const o=s[0].__index||{};const i=s[o.obj].__cls||"";const c=s[o.obj].__func||"";const a=s[o.obj].__args||[];const u=yield Promise.all(Object.values(o).map((t=>{const e=r[t];return e?this.get(e):Promise.resolve({})})));const d=Object.keys(o).map(((t,e)=>[t,u[e]]));const h=Object.fromEntries(d);let l=h.obj;delete h.obj;const f=Object.entries(h).reduce(((t,[e,n])=>{const r=parseInt(e,10);return Number.isNaN(r)||(t[r]=n),t}),[]);const p=pt(f,a);let v;if("constructor"===c){const t=eval(`(${i})`);l=Reflect.construct(t,p)}else v=Reflect.apply(l[c].bind(l),l,p);Object.entries(o).forEach((([t,n])=>{const r=parseInt(t,10);let o=f[r];"obj"===t?o=l:"res"===t&&(o=v),Y(o,s,n,e)}));const _=l._rootId||`${e}:${o.obj}`;return et([v,l,...f],_),[...f,l,v][n]}))}}function _t(t){return{smartArgs:t.filter((t=>t._rev)),dumbArgs:t.map((t=>t._rev?"__":t))}}function gt(t){return p(this,void 0,void 0,(function*(){let e;let n;let r;let s;let o;let i;let c;if("Cls"in t){const{Cls:a,args:u}=t;e=a.toString(),n=null,r=Reflect.construct(a,u),s=Z(u),o=u,i=null,c=void 0}else{const{target:a,property:u,args:d}=t;e=null,n=Z(a),r=a,s=Z(d),o=d,i=u,c=Reflect.apply(a[u],a,o)}const{smartArgs:a,dumbArgs:u}=_t(s);const{smartArgs:d}=_t(o);const h=Object.assign(Object.assign(Object.assign({},a),{obj:n}),{_id:"index"});const l=Object.assign(Object.assign(Object.assign({},d),{obj:r}),{_id:"index"});"Object"===V(c)&&(l.res=c);const[f,p,v]=ft(h,l);void 0!==p[0]&&(p[0].__index=v);const _=v.obj;return void 0!==p[_]&&(null!==e&&(p[_].__cls=e),p[_].__func=null===i?"constructor":String(i),p[_].__args=u),[f,p,r,d,c,v]}))}class bt{constructor(t){this.db=t}construct(t,e){return p(this,void 0,void 0,(function*(){const[n,r,s,o,,i]=yield gt({Cls:t,args:e});const[c]=yield this.db.update(n,r);const{txId:a}=P(c);Object.entries(i).forEach((([t,e])=>{const n=parseInt(t,10);let i=o[n];"obj"===t&&(i=s),Y(i,r,e,a)}));const u=`${a}:${i.obj}`;return et([s,...o],u),s}))}call(t,e,n){return p(this,void 0,void 0,(function*(){const[r,s,,o,i,c]=yield gt({target:t,property:e,args:n});const[a]=yield this.db.update(r,s);const{txId:u}=P(a);Object.entries(c).forEach((([e,n])=>{const r=parseInt(e,10);let c=o[r];"obj"===e?c=t:"res"===e&&(c=i),Y(c,s,n,u)}));const d="string"==typeof t._rootId?t._rootId:`${u}:${c.obj}`;return et([i,t,...o],d),i}))}get(t,e){return"function"==typeof t[e]?(...n)=>this.call(t,e,n):Reflect.get(t,e)}}function wt(t,e){const n=[];let r=0;for(;r<t.length;){const s=r+e;n.push(t.slice(r,s)),r=s}return n}function yt(t,n){const r=new e.Script;if(!Array.isArray(n))throw new Error("Owners is not defined");if(n.length>16)throw new Error("Too many owners");return r.add("OP_1"),n.forEach((t=>{r.add(e.PublicKey.fromString(t).toBuffer())})),r.add(`OP_${n.length}`),r.add("OP_CHECKMULTISIG"),r.add(t),r.add("OP_DROP"),r}function mt(t){const n=t.chunks.length;return!(!t.chunks[n-2].buf||t.chunks[n-1].opcodenum!==e.Opcode.OP_DROP)}function Ot(t){const{_amount:e,__vouts:n,_owners:r}=t,s=l(t,["_amount","__vouts","_owners"]);const o=Buffer.from(JSON.stringify(s));return("BSV"===j.CHAIN?[o]:wt(o,j.SCRIPT_CHUNK_SIZE)).map((t=>yt(t,r)))}function xt(t){if(mt(t))return t.chunks.slice(1,t.chunks.length-4).map((t=>{if(!t.buf)throw new Error("Illegal state");return new e.PublicKey(t.buf).toString()}));throw new Error("Cannot get owners from non-data script")}function St(t){if(mt(t)){const e=t.chunks[t.chunks.length-2];if(!e.buf)throw new Error("Illegal state");const n=JSON.parse(e.buf.toString());const r=xt(t);return void 0!==r&&(n._owners=r),n}throw new Error("Not a data script.")}function jt(t){const{chunks:n}=t;return n[0].opcodenum===e.Opcode.OP_HASH160&&n[n.length-1].opcodenum===e.Opcode.OP_EQUAL}function It(t){let e=0;const n=[];for(let r=0;r<t.length;r+=1)n.push(e),e+=t[r];return n}function Et(t,e){let n=0;for(let r=0;r<e.length;r+=1){const s=[];for(let t=0;t<e[r];t+=1)s.push(n),n+=1;if(s[0]===t)return s}throw new Error("No match found")}function $t(t,e){let n=0;for(let r=0;r<e.length;r+=1){const s=[];for(let t=0;t<e[r];t+=1)s.push(n),n+=1;if(s[0]===t)return r}throw new Error("No match found")}const Bt=(t,e)=>t.length===e.length&&t.every(((t,n)=>t===e[n]));var Rt;const{Output:Tt}=e.Transaction;const{MultiSigScriptHash:Dt}=e.Transaction.Input;const{UnspentOutput:Ct}=e.Transaction;let Kt=Rt=class{constructor(t,n,r,s){const o=new e.Transaction(s);o.feePerKb(j.DEFAULT_FEE),this.restClient=new A(t,n,r),this._tx=o,this._outData=[],this._privateKey=r}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get tx(){return this._tx}get inputs(){return this.tx.inputs.map((t=>`${t.prevTxId.toString("hex")}:${t.outputIndex}`))}get inRevs(){let t=0;const{opReturns:e}=this;if(0===e.length)return;const[{__vins:n}]=e;if(!Array.isArray(n))throw new Error("Virtual inputs not found");return n.map((e=>{if(!this.tx.inputs[t])throw new Error("Input not found in inRevs");const{prevTxId:n,outputIndex:r}=this.tx.inputs[t];return t+=e,`${n.toString("hex")}:${r}`}))}get outRevs(){let t=0;const{opReturns:e}=this;if(0===e.length)return;const[{__vouts:n}]=e;if(!Array.isArray(n))throw new Error("Virtual inputs not found");const r=this.tx.id;return n.map((e=>{const n=`${r}:${t}`;return t+=e,n}))}get outData(){return this._outData}get opReturns(){const{outputs:t}=this.tx;return t.filter((t=>new e.Script(t.script.toBuffer()).toString().startsWith("OP_RETURN"))).map((t=>{var n,r;const s=new e.Script(t.script.toBuffer());const{chunks:o}=s;return JSON.parse((null===(r=null===(n=o[1])||void 0===n?void 0:n.buf)||void 0===r?void 0:r.toString())||"")}))}checkOutDataBCH(t){const n=t.map((t=>Ot(l(t,["_amount"])).map((t=>e.Script.buildScriptHashOut(t))))).flat().map((t=>t.toString()));const r=this.tx.outputs.map((t=>new e.Script(t.script))).filter((t=>jt(t))).map((t=>t.toString()));return Bt(r,n)}addMetaData(t){return t.map(((t,n)=>{const r=this.tx.outputs[n];const s="BSV"===this.chain?xt(new e.Script(r.script)):t._owners;const o=r.satoshis;return void 0!==s&&(t._owners=s),void 0!==o&&(t._amount=o),t}))}spendFromDataBsv(t){return p(this,void 0,void 0,(function*(){const n=t.map(P);const r=n.map((t=>t.txId));const s=yield this.restClient.getTransactions(r);for(let t=0;t<n.length;t+=1){const{txId:r,outIndex:o}=n[t];const{outputs:i}=s[t];const c=i[o];const a=new e.Script(c.script);const u=Math.round(c.satoshis);const d=xt(a);const h={txId:r,outputIndex:o,script:a,satoshis:u};this.tx.from([new Ct(h)],d,1)}return new Array(n.length).fill(1)}))}spendFromDataBch(t){return p(this,void 0,void 0,(function*(){const n=[];for(const r of t){const{txId:t,outIndex:s}=P(r);const o=yield Rt.fromTxId(t,this.chain,this.network,this._privateKey);const{outData:i}=o;const[{__vouts:c}]=o.opReturns;const a=Et(s,c).map((e=>{const{script:n,satoshis:r}=o.tx.outputs[e];const s=n.toBuffer().toString("hex");return{txId:t,vout:e,scriptPubKey:s,satoshis:r,amount:r/1e8}}));const u=i[$t(s,c)];const d=Ot(l(u,["_amount"]));d.forEach(((t,n)=>{const{scriptPubKey:r,satoshis:s,txId:o,vout:i}=a[n];const c=new Tt({script:new e.Script(r),satoshis:s});const d=new e.Script;const h=new Dt({prevTxId:o,output:c,outputIndex:i,script:d},u._owners||[],1,null,t);this.tx.addInput(h)})),n.push(d.length)}return n}))}spendFromData(t){return p(this,void 0,void 0,(function*(){return 0===t.length?[]:"BSV"===this.chain?this.spendFromDataBsv(t):this.spendFromDataBch(t)}))}createOpReturnOut(t){this.tx.addData(JSON.stringify(t))}createDataOut(t){const{_amount:n}=t,r=l(t,["_amount"]);const s=n||j.MIN_NON_DUST_AMOUNT;const o=Ot(r);if(this._outData.push(r),"BSV"===this.chain){const t=new Tt({script:o[0],satoshis:s});return this.tx.addOutput(t),1}return o.forEach((t=>{const n=new Tt({script:e.Script.buildScriptHashOut(t),satoshis:s});this.tx.addOutput(n)})),o.length}static fromHexBSV(t,n,r){const s=new this("BSV",n,r);s.tx.fromString(t);const o=s.tx.outputs.filter((t=>mt(new e.Script(t._scriptBuffer)))).map((t=>St(new e.Script(t._scriptBuffer))));return s._outData=s.addMetaData(o),s}static fromHexBCH(t,e,n,r){const s=new this("BCH",e,n);if(s.tx.fromString(t),!s.checkOutDataBCH(r))throw new Error("Invalid data from server in fromHexBCH.");return s._outData=s.addMetaData(r),s}static fromTxId(t,e,n,r){return p(this,void 0,void 0,(function*(){const s=new A(e,n,r);if("BSV"===e){const e=yield s.getRawTx(t);return this.fromHexBSV(e,n,r)}const{hex:o,data:i}=yield s.getRawTxData(t);return this.fromHexBCH(o,n,r,i)}))}};function Nt(t){return Buffer.from(d.default.SHA256(t).toString(),"hex").toString("hex").substr(0,4)}function Pt(t,e){return Nt(t)===e}function At(t){return`${Nt(t)};${t}`}function Ut(t){const e=t.substr(0,4);const n=t.substr(5);if(!Pt(n,e))throw new Error("Decryption failure");return n}function Ht(){return u.default.randomBytes(32).toString("hex")}function kt(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const n=Buffer.from(e,"hex").toString("binary");const r=At(t);return d.default.AES.encrypt(r,n).toString()}function Vt(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const n=Buffer.from(e,"hex").toString("binary");return Ut(d.default.AES.decrypt(t,n).toString(d.default.enc.Utf8))}function Ft(t,e){if(!/^0[2-3][0-9a-f]{64}|04[0-9a-f]{128}$/.test(e))throw new Error("Invalid publicKey");const n=At(t);return h.encrypt(e,Buffer.from(n,"utf8")).toString("base64")}function Lt(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid privateKey");return Ut(h.decrypt(e,Buffer.from(t,"base64")).toString("utf8"))}function Jt(t,e){const n=Ht();return{__cypher:kt(t,n),__secrets:e.map((t=>Ft(n,t)))}}function Mt({__cypher:t,__secrets:e},n){let r="";if(n.forEach((n=>{e.forEach((e=>{try{const s=Lt(e,n);r=Vt(t,s)}catch(t){if(!["Decryption failure","Unsupported state or unable to authenticate data"].includes(t.message))throw t}}))})),r)return r;throw new Error("Decryption failure")}function Wt(t){if(void 0!==t._readers){const{_readers:e,_url:n,_owners:r,_amount:s}=t,o=l(t,["_readers","_url","_owners","_amount"]);const i=Jt(JSON.stringify(o),e);return void 0!==n&&(i._url=n),void 0!==r&&(i._owners=r),void 0!==s&&(i._amount=s),i}return t}function qt(t,e){if(D(t)){const{__cypher:n,__secrets:r}=t,s=l(t,["__cypher","__secrets"]);return Object.assign(Object.assign(Object.assign({},s),JSON.parse(Mt({__cypher:n,__secrets:r},e))),{_readers:[]})}return t}function Zt(t){return e=>p(this,void 0,void 0,(function*(){if(void 0!==e._url){const{_url:n,_owners:r,_amount:s}=e,o=l(e,["_url","_owners","_amount"]);const i=yield A.setSecretOutput({host:n,secretOutput:{data:JSON.stringify(o)},privateKey:t.getPrivateKey()});return void 0!==r&&(i._owners=r),void 0!==s&&(i._amount=s),i}return e}))}function Gt(t){return e=>p(this,void 0,void 0,(function*(){if(T(e)){const{_url:n}=e,r=l(e,["_url"]);const{host:s,data:o}=yield A.getSecretOutput({_url:n,privateKey:t.getPrivateKey()});return Object.assign(Object.assign(Object.assign({},r),JSON.parse(o)),{_url:s})}return e}))}Kt=Rt=f([C()],Kt);class zt{constructor(t){this.wallet=t}get chain(){return this.wallet.chain}get network(){return this.wallet.network}fromDataTx(t,e=!0,n=!0){return p(this,void 0,void 0,(function*(){const r=t.tx.id;const{inputs:s,inRevs:o,outRevs:i,opReturns:c}=t;const a=this.wallet.getPrivateKey().toBuffer().toString("hex");return{inRevs:o,outRevs:i,inputs:s,outData:yield Promise.all(t.outData.map((t=>p(this,void 0,void 0,(function*(){const r=n?yield Gt(this.wallet)(t):t;return e?qt(r,[a]):r}))))),opReturns:c,txId:r}}))}fromTxHex(t,e=!0,n=!0){return p(this,void 0,void 0,(function*(){const{network:r,wallet:s}=this;const o=s.getPrivateKey();let i;if("BSV"===this.chain)i=Kt.fromHexBSV(t,r,o);else{i=new Kt("BCH",r,o),i.tx.fromString(t);const e=yield s.restClient.getOutData(i.tx.id);if(!i.checkOutDataBCH(e))throw new Error("Invalid data from server in fromTxHex.");i._outData=i.addMetaData(e)}return this.fromDataTx(i,e,n)}))}fromTxId(t,e=!0,n=!0){return p(this,void 0,void 0,(function*(){const{chain:r,network:s,wallet:o}=this;const i=o.getPrivateKey();const c=yield Kt.fromTxId(t,r,s,i);return this.fromDataTx(c,e,n)}))}get(t,e,n){return p(this,void 0,void 0,(function*(){const r=t.map(P);return Promise.all(r.map((({txId:t,outIndex:r})=>p(this,void 0,void 0,(function*(){const{outData:s,opReturns:o}=yield this.fromTxId(t,e,n);const[{__vouts:i}]=o;return s[$t(r,i)]})))))}))}put(t){return this.update([],t)}update(t,e){return p(this,void 0,void 0,(function*(){const{chain:n,network:r,wallet:s}=this;const o=s.getPrivateKey();const i=new Kt(n,r,o);const c=e.map((t=>{var{_owners:e}=t,n=l(t,["_owners"]);return Object.assign({_owners:e||[this.wallet.getPublicKey().toString()]},n)})).map(Wt);const a=yield Promise.all(c.map(Zt(this.wallet)));const u=yield i.spendFromData(t);const d=a.map(i.createDataOut.bind(i));i.createOpReturnOut({__vins:u,__vouts:d});const h=yield this.wallet.fundAndSendTransaction(i,!0);return It(d).map((t=>`${h}:${t}`))}))}}function Qt(t){const e=t;for(let t=e.length-1;t>0;t-=1){const n=Math.floor(Math.random()*(t+1));[e[t],e[n]]=[e[n],e[t]]}}class Xt{constructor(t,e,n={}){const{path:r="m/44'/0'/0'/0",passphrase:s=""}=n;let o=t.toHDPrivateKey(s,j.NETWORK);r&&(o=o.derive(r));const i=o.publicKey.toAddress(e.network);this.mnemonic=t,this.restClient=e,this.path=r,this.passphrase=s,this.hdPrivateKey=o,this.address=i}get chain(){return this.restClient.chain}get network(){return this.restClient.network}getMnemonic(){return this.mnemonic}getPath(){return this.path}derive(t="0"){const e=`${this.path}${this.path.length>0?"/":""}${t}`;return new Xt(this.mnemonic,this.restClient,{path:e})}getPrivateKey(){return this.hdPrivateKey.privateKey}getPublicKey(){return this.hdPrivateKey.publicKey}getAddress(){return this.address}getBalance(){return p(this,void 0,void 0,(function*(){return this.restClient.getBalance(this.getAddress())}))}getUtxos(t=this.getAddress()){return p(this,void 0,void 0,(function*(){return this.restClient.getUtxosFromAddress(t)}))}selectUtxos(t,e){let n=0;const r=[];Qt(t);for(let s=0;s<t.length;s+=1){const o=t[s];if(n+=o.satoshis,r.push(o),n>=e)return r}throw new Error(`Insufficient balance in address ${this.getAddress().toString()} on ${j.NETWORK} ${j.CHAIN}. Found ${n}, required ${e}.`)}fundAndSendTransaction(t,n=!1){return p(this,void 0,void 0,(function*(){t.tx.feePerKb(j.DEFAULT_FEE);const r=t.tx._getInputAmount();const s=t.tx._getOutputAmount()-r+(t.tx._estimateFee()+100);if(s>0){const n=yield this.getUtxos(this.getAddress());this.selectUtxos(n,s).forEach((n=>{t.tx.from([new e.Transaction.UnspentOutput(n)])}))}t.tx.change(this.getAddress()),t.tx.sign(this.getPrivateKey());const o=yield this.restClient.sendTransaction(t.tx.toString());return n&&(yield this.storeResult(o,t)),o}))}storeResult(t,e){return p(this,void 0,void 0,(function*(){const{outData:n,inputs:r,inRevs:s,outRevs:o}=e;const i=JSON.stringify(n);yield this.restClient.postOutData({outData:i,txId:t,inputs:r,inRevs:s,outRevs:o})}))}send(t,e){return p(this,void 0,void 0,(function*(){const n=new Kt(this.chain,this.network,this.getPrivateKey());return n.tx.to(e,t),this.fundAndSendTransaction(n)}))}}class Yt{constructor(t={}){if(void 0===t.bbsUrl){if("livenet"===t.network)throw new Error('Bitcoincomputer.io does not support mainnet Bitcoin networks by default.\n          Please either use testnet or provide a self-managed Bitcoin Broadcast Server by setting the "bbsUrl" option.');t.chain&&!["BSV","BCH"].includes(t.chain)&&console.log("Chain not set when calling new Computer({ ... }), defaulting to BSV"),t.network&&!["livenet","testnet"].includes(t.network)&&console.log("Network not set when calling new Computer({ ... }), defaulting to testnet")}t.bbsUrl&&j.setBbsUrl(t.bbsUrl);const n=t.chain||j.CHAIN||"BSV";const r=t.network||j.NETWORK||"testnet";const s=t.mnemonic||new e.Mnemonic(t.seed);const o=t.path||"m/44'/0'/0'/0";const i=t.passphrase||"";const c=E(s,{path:o,passphrase:i});const a=new A(n,r,c);const u=t.db||new zt(new Xt(s,a,{path:o,passphrase:i}));this.db=u}get chain(){return this.db.chain}get network(){return this.db.network}parseContract(t){const e=t.startsWith("export ")?t.slice(7):t;const n=e.startsWith("default ")?e.slice(8):e;return eval(`(${n})`)}new(t,e){return p(this,void 0,void 0,(function*(){const n=t.toString();const r=yield this.parseContract(n);const s=new bt(this.db);const o=yield s.construct(r,e);return new Proxy(o,s)}))}sync(t){return p(this,void 0,void 0,(function*(){N(t);const e=new vt(this.db);const n=new bt(this.db);const r=yield e.get(t);return new Proxy(r,n)}))}getOwnedRevs(t=this.db.wallet.getPublicKey()){return this.db.wallet.restClient.getOwnedRevs(t)}queryRevs(t){return p(this,void 0,void 0,(function*(){const{publicKey:n,contractName:r,contractHash:s}=t;const o=n?new e.PublicKey(n):void 0;return this.db.wallet.restClient.queryRevs({publicKey:o,contractName:r,contractHash:s})}))}getRevs(t=this.db.wallet.getPublicKey()){return p(this,void 0,void 0,(function*(){return(yield this.getOwnedRevs(t)).map((({txId:t,outIndex:e})=>`${t}:${e}`))}))}getLatestRev(t){return this.db.wallet.restClient.getLatestRev(t)}getLatestRevs(t){return this.db.wallet.restClient.getLatestRevs(t)}}var te=(t,n,r)=>p(void 0,void 0,void 0,(function*(){let s;if("BSV"===t)s=Kt.fromHexBSV(r,n,new e.PrivateKey);else{s=new Kt("BCH",n,new e.PrivateKey),s.tx.fromString(r);const o=new A(t,n,new e.PrivateKey);const i=yield o.getOutData(s.tx.id);if(!s.checkOutDataBCH(i))throw new Error("Invalid data from server in parseOutputData.");s._outData=s.addMetaData(i)}return{txId:s.tx.id,outData:JSON.stringify(s.outData),inputs:s.tx.toJSON().inputs.map((t=>`${t.prevTxId}:${t.outputIndex}`))}}));return t.Computer=Yt,t.parseOutData=te,Object.defineProperty(t,"__esModule",{value:!0}),t}({},BitcoinSource,axios,crypto,CryptoJS,eciesjs);
