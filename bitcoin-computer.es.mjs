import{crypto as t,Transaction as e,PrivateKey as n,Opcode as r,Script as s,PublicKey as o,Mnemonic as i}from"bitcoinsource";import c from"axios";import a from"crypto";import u from"crypto-js";import*as d from"eciesjs";
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function h(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(t);s<r.length;s++)e.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(t,r[s])&&(n[r[s]]=t[r[s]])}return n}function l(t,e,n,r){var s,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,r);else for(var c=t.length-1;c>=0;c--)(s=t[c])&&(i=(o<3?s(i):o>3?s(e,n,i):s(e,n))||i);return o>3&&i&&Object.defineProperty(e,n,i),i}function f(t,e,n,r){return new(n||(n=Promise))((function(s,o){function i(t){try{a(r.next(t))}catch(t){o(t)}}function c(t){try{a(r.throw(t))}catch(t){o(t)}}function a(t){var e;t.done?s(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(i,c)}a((r=r.apply(t,e||[])).next())}))}const p=process.env.BC_CHAIN||"BSV";const v=process.env.BC_NETWORK||"testnet";const g=parseInt(process.env.BC_DUST_LIMIT||"",10)||4e3;const _=parseInt(process.env.BC_DEFAULT_FEE||"",10)||("BSV"===p?500:2500);const w=parseInt(process.env.BC_SCRIPT_CHUNK_SIZE||"",10)||("BSV"===p?1/0:479);const b=process.env.BSV_TESTNET_BBS_URL?process.env.BSV_TESTNET_BBS_URL:"http://50.18.114.11";const y=process.env.BCH_TESTNET_BBS_URL?process.env.BCH_TESTNET_BBS_URL:"http://13.52.113.43";let m="";"BSV"===p&&"testnet"===v&&(m=b),"BCH"===p&&"testnet"===v&&(m=y);const O=new URL(m).origin;var x={CHAIN:p,NETWORK:v,MIN_NON_DUST_AMOUNT:g,SCRIPT_CHUNK_SIZE:w,BBS_URL:m,BBS_ORIGIN:O,DEFAULT_FEE:_};const S=e=>{const n=Date.now();const r=t.Hash.sha256(Buffer.from(x.BBS_ORIGIN+n));const s=[t.ECDSA.sign(r,e,"big").toString("hex"),e.publicKey.toString(),n];return`Bearer ${Buffer.from(s.join(":")).toString("base64")}`};const j=(t,e,n={})=>{const{path:r="m/44'/0'/0'/0",passphrase:s=""}=n;let o=t.toHDPrivateKey(s,e);return r&&(o=o.derive(r)),o.privateKey};function $(t){try{const n=JSON.parse(t);if("object"!=typeof n)throw new Error("Invalid object");if("string"!=typeof n.txhex)throw new Error("Invalid object");return new e(n.txhex)}catch(t){return null}}function I(t){return void 0!==t.config}function E(t){return f(this,void 0,void 0,(function*(){if(!I(t))throw new Error("Unknown error");const{message:e,config:n,response:r}=t;const s=$(null==n?void 0:n.data);const o=`message\t${e}`;const i=`request\t${null==n?void 0:n.method} ${null==n?void 0:n.url}`;const c=s?`transaction\t ${JSON.stringify(s.toJSON(),null,2)}`:"";const a="post"===(null==n?void 0:n.method)?`data\t${null==n?void 0:n.data}`:"";const u=r?`response\t${JSON.stringify(r.data)}`:"";const d=s?c:a;throw t.message=`\n    Communication Error\n    ${o}\n    ${i}\n    ${d}\n    ${u}`,t}))}class C{constructor(t,e={},n){this.baseUrl=t,this.headers=e,this.privateKey=n}get(t){return f(this,void 0,void 0,(function*(){const e=`${this.baseUrl}${t}`;try{let t={};return this.privateKey&&(t={Authentication:S(this.privateKey)}),(yield c.get(e,{headers:Object.assign(Object.assign({},this.headers),t)})).data}catch(t){return E(t)}}))}post(t,e){return f(this,void 0,void 0,(function*(){const n=`${this.baseUrl}${t}`;try{let t={};return this.privateKey&&(t={Authentication:S(this.privateKey)}),(yield c.post(n,e,{headers:Object.assign(Object.assign({},this.headers),t)})).data}catch(t){return E(t)}}))}delete(t){return f(this,void 0,void 0,(function*(){const e=`${this.baseUrl}${t}`;try{let t={};return this.privateKey&&(t={Authentication:S(this.privateKey)}),(yield c.delete(e,{headers:Object.assign(Object.assign({},this.headers),t)})).data}catch(t){return E(t)}}))}}function R(t){return void 0!==t._url}function B(t){return void 0!==t.__cypher&&void 0!==t.__secrets}const T=()=>t=>t;function D(t){if(!/^[0-9A-Fa-f]{64}$/.test(t))throw new Error(`Invalid txId: ${t}`)}function A(t){if(!/^[0-9A-Fa-f]{64}:\d+$/.test(t))throw new Error(`Invalid outId: ${t}`)}function N(t){A(t);const[e,n]=t.split(":");return{txId:e,outIndex:parseInt(n,10)}}let K=class{constructor(t,e=new n){this.nodeConfig=t,this.bbs=new C(t.url,{},e)}get chain(){return this.nodeConfig.chain}get network(){return this.nodeConfig.network}getBalance(t){return f(this,void 0,void 0,(function*(){const{chain:e,network:n}=this;return yield this.bbs.get(`/v1/${e}/${n}/address/${t}/balance`)}))}getTransaction(t){return f(this,void 0,void 0,(function*(){return new e(yield this.getRawTx(t))}))}getRawTx(t){return f(this,void 0,void 0,(function*(){D(t);const{chain:e,network:n}=this;return this.bbs.get(`/v1/${e}/${n}/tx/${t}`)}))}getRawTxData(t){return f(this,void 0,void 0,(function*(){D(t);const{chain:e,network:n}=this;return this.bbs.get(`/v1/${e}/${n}/tx-data/${t}`)}))}getTransactions(t){return f(this,void 0,void 0,(function*(){return(yield this.getRawTxs(t)).map((t=>new e(t)))}))}getRawTxs(t){return f(this,void 0,void 0,(function*(){t.map(D);const{chain:e,network:n}=this;return this.bbs.post(`/v1/${e}/${n}/tx/bulk/`,{txIds:t})}))}sendTransaction(t){return f(this,void 0,void 0,(function*(){return this.bbs.post(`/v1/${this.chain}/${this.network}/tx/send`,{rawTx:t})}))}getUtxosFromAddress(t){return f(this,void 0,void 0,(function*(){const{chain:e,network:n}=this;return this.bbs.get(`/v1/${e}/${n}/wallet/${t.toString()}/utxos`)}))}postOutData(t){return f(this,void 0,void 0,(function*(){const{chain:e,network:n}=this;return this.bbs.post(`/v1/${e}/${n}/out-data`,t)}))}getOutData(t){return f(this,void 0,void 0,(function*(){const{chain:e,network:n}=this;return this.bbs.get(`/v1/${e}/${n}/out-data/${t}`)}))}getOwnedRevs(t){return f(this,void 0,void 0,(function*(){const{chain:e,network:n}=this;return this.bbs.get(`/v1/${e}/${n}/wallet/${t.toString()}/non-standard-utxos`)}))}queryRevs(t){return f(this,void 0,void 0,(function*(){const{publicKey:e,contractName:n,contractHash:r}=t;if(void 0===e&&void 0===n&&void 0===r)throw new Error("Filter parameter for queryRevs endpoint cannot be empty.");let s="";e&&(s+=`?publicKey=${e}`),n&&(s+=0===s.length?"?":"&",s+=`contractName=${n}`),r&&(s+=0===s.length?"?":"&",s+=`contractHash=${r}`);const{chain:o,network:i}=this;return this.bbs.get(`/v1/${o}/${i}/non-standard-utxos${s}`)}))}getLatestRev(t){return f(this,void 0,void 0,(function*(){A(t);const{chain:e,network:n}=this;const[{rev:r}]=yield this.bbs.get(`/v1/${e}/${n}/rev/${t}`);return r}))}getLatestRevs(t){return f(this,void 0,void 0,(function*(){t.map(A),t.map(A);const{chain:e,network:n}=this;return yield this.bbs.post(`/v1/${e}/${n}/revs`,{ids:t})}))}static getSecretOutput({_url:t,privateKey:e}){return f(this,void 0,void 0,(function*(){const n=t.split("/");const r=n[n.length-1];const s=n.slice(0,-2).join("/");const o=new C(s,{},e);return{host:s,data:yield o.get(`/v1/store/${r}`)}}))}static setSecretOutput({secretOutput:t,host:e,privateKey:n}){return f(this,void 0,void 0,(function*(){return new C(e,{},n).post("/v1/store/",t)}))}static deleteSecretOutput({_url:t,privateKey:e}){return f(this,void 0,void 0,(function*(){const n=t.split("/");const r=n[n.length-1];const s=n.slice(0,-2).join("/");const o=new C(s,{},e);yield o.delete(`/v1/store/${r}`)}))}};K=l([T()],K);const P=()=>`__temp__:${Math.random()}`;const k=["_id","_rev","_owners","_amount","_readers","_url","__vouts","__func","__index","__args"];const U=(t,e)=>t.length===e.length&&t.every(((t,n)=>t===e[n]));const H=t=>(Object.prototype.toString.call(t).match(/\s([a-zA-Z]+)/)||[])[1];const L=t=>"object"==typeof t?H(t):H(t).toLowerCase();const F=t=>["number","string","boolean","undefined","Null"].includes(L(t));const J=t=>"Array"===L(t);const V=t=>"Object"===L(t);const M=t=>F(t)||["Array","Object"].includes(L(t));const q=t=>"Object"===L(t)&&Object.keys(t).every((t=>!Number.isNaN(parseInt(t,10))));const W=(t,e)=>{if(!M(t)||!M(e))throw new Error(`Unsupported data types for deep equals: ${L(t)} & ${L(e)}`);if(L(t)!==L(e))return!1;if(F(t)&&F(e))return t===e;const n=(t,e)=>Object.entries(t).every((([t,n])=>W(e[t],n)));return t&&e&&n(t,e)&&n(e,t)};const G=t=>{if(F(t))return t;if(J(t))return t.map(G);if(V(t)){const e=Object.keys(t).reduce(((e,n)=>(e[n]=G(t[n]),e)),{});const n=Object.create(Object.getPrototypeOf(t));return Object.assign(n,e)}throw new Error(`Unsupported data type for clone: ${L(t)}`)};const Z=(t,e)=>t.reduce((([t,n],r,s)=>e(r,s)?[[...t,r],n]:[t,[...n,r]]),[[],[]]);const z=(t,e)=>Object.fromEntries(Object.entries(t).map((t=>e(t))));const Q=(t,e)=>z(t,(([t,n])=>[t,e(n)]));const X=(t,e)=>Object.fromEntries(Object.entries(t).filter((t=>e(t))));const Y=(t,e)=>X(t,(([,t])=>e(t)));const tt=(t,e,n,r)=>{if(F(t))return t;if(J(t))return t.map((t=>tt(t,e,n,r)));if(V(t)){t._rev=`${r}:${n}`;const s=e[n];return Object.entries(t).forEach((([n,o])=>{"object"==typeof s&&Object.keys(s).includes(n)&&(t[n]=tt(o,e,s[n],r))})),t}throw new Error(`Unsupported type ${L(t)} in deep.updateRev`)};const et=(t,e)=>{if(F(t))return t;if(J(t))return t.map((t=>et(t,e)));if(V(t))return t._id=!t._id||t._id.startsWith("__temp__")?t._rev:t._id,t._rootId=t._rootId||e,Object.entries(t).forEach((([n,r])=>{t[n]=et(r,e)})),t;throw new Error(`Unsupported type ${L(t)} in deep.addId`)};const nt=t=>{if(F(t))return t;if(J(t))return t.map((t=>nt(t)));if(V(t)){const e=P();return t._id=t._id||e,t._rev=t._rev||e,Object.values(t).map((t=>nt(t))),t}throw new Error(`Unsupported type ${L(t)} in addRandomId`)};const rt=t=>{if(F(t))return t;if(J(t))return t.map((t=>rt(t)));if(V(t))return z(t,(([t,e])=>["_owners","_readers"].includes(t)?[t,JSON.stringify(e)]:F(e)?[t,e]:[t,rt(e)]));throw new Error(`Unexpected type ${L(t)} in stringifyOwners`)};const st=t=>(t._owners&&(t._owners=JSON.parse(t._owners)),t._readers&&(t._readers=JSON.parse(t._readers)),t);const ot=t=>{if(F(t))return t;if(J(t)||V(t))return Object.entries(t).reduce(((t,[e,n])=>{const r=ot(n);return q(r)?Object.entries(r).forEach((([n,r])=>{t[`${e}_${n}`]=r})):t[e]=r,t}),{});throw new Error(`Unsupported type ${L(t)} in encodeArraysAsObjects`)};const it=t=>{const e={[t._id]:Object.entries(t).reduce(((t,[e,n])=>k.includes(e)?Object.assign(Object.assign({},t),{[e]:n}):F(n)?Object.assign(Object.assign({},t),{[`__basic__${e}`]:n}):Object.assign(Object.assign({},t),{[e]:n._id})),{})};return Object.values(t).filter((t=>!F(t))).reduce(((t,e)=>Object.assign(Object.assign({},t),it(e))),e)};const ct=t=>X(t,(([t])=>!t.startsWith("__basic__")));const at=(t,e)=>z(e,(([e,n])=>{const r=t[e];var s;return n.__change=(s=r)?W(s,n)?"same":"diff":"new",[e,n]}));const ut=(t,e)=>{const n=t[e];return n.__contains=Object.entries(n).reduce(((e,[n,r])=>["__contains",...k].includes(n)?e:"__change"===n?"new"===r||"diff"===r||e:ut(t,r)[r].__contains||e),!1),t};const dt=t=>t.reduce(((t,e,n)=>Object.assign(Object.assign({},t),{[e._id]:n})),{});const ht=(t,e)=>t.map((t=>Object.entries(t).reduce(((t,[n,r])=>{const s="string"==typeof r&&"undefined"!==L(e[r])?e[r]:r;return Object.assign(Object.assign({},t),{[n]:s})}),{})));const lt=(t,e)=>[e,...t].map((t=>{const e=h(t,["_id","_rev","__change","__contains"]);return X(e,(([t,e])=>k.includes(t)||"number"==typeof e))}));const ft=(t,e)=>{const n=nt(e);const r=n._id;const s=G(t);const o=G(n);const i=rt(s);const c=rt(o);const a=ot(i);const u=ot(c);const d=it(a);const h=it(u);const l=at(d,h);const f=Q(l,ct);const p=ut(f,r);const v=p[r];delete p[r];const g=Q(p,(t=>t._rev));const _=Y(p,(t=>t.__contains||Object.values(v).includes(t._id)));const w=Object.values(_);const[b,y]=Z(w,(t=>"new"===t.__change));const m=[...y,...b];const O=dt(m);const x=ht(m,O);const[S]=ht([v],O);const j=y.map((t=>t._rev));const[$,...I]=lt(x,S);return[j,I.map(st).map((t=>Object.entries(t).reduce(((t,[e,n])=>Object.assign(Object.assign({},t),{[e]:g[n]||n})),{}))),$]};function pt(t,e){let n=0;return e.map((e=>"__"===e?t[n++]:e))}class vt{constructor(t){this.db=t}get(t){return f(this,void 0,void 0,(function*(){const{txId:e,outIndex:n}=N(t);const{inRevs:r,outData:s}=yield this.db.fromTxId(e);if(!Array.isArray(r)||!Array.isArray(s)||0===s.length)return;const o=s[0].__index||{};const i=s[o.obj].__cls||"";const c=s[o.obj].__func||"";const a=s[o.obj].__args||[];const u=yield Promise.all(Object.values(o).map((t=>{const e=r[t];return e?this.get(e):Promise.resolve({})})));const d=Object.keys(o).map(((t,e)=>[t,u[e]]));const h=Object.fromEntries(d);let l=h.obj;delete h.obj;const f=Object.entries(h).reduce(((t,[e,n])=>{const r=parseInt(e,10);return Number.isNaN(r)||(t[r]=n),t}),[]);const p=pt(f,a);let v;if("constructor"===c){const t=eval(`(${i})`);l=Reflect.construct(t,p)}else v=Reflect.apply(l[c].bind(l),l,p);Object.entries(o).forEach((([t,n])=>{const r=parseInt(t,10);let o=f[r];"obj"===t?o=l:"res"===t&&(o=v),tt(o,s,n,e)}));const g=l._rootId||`${e}:${o.obj}`;return et([v,l,...f],g),[...f,l,v][n]}))}}function gt(t){return{smartArgs:t.filter((t=>t._rev)),dumbArgs:t.map((t=>t._rev?"__":t))}}class _t{constructor(t){this.db=t,_t.proxyDepth=_t.proxyDepth||0}static getUpdate(t){return f(this,void 0,void 0,(function*(){let e;let n;let r;let s;let o;let i;let c;if("Cls"in t){const{Cls:a,args:u}=t;e=a.toString(),n=null,r=Reflect.construct(a,u),s=G(u),o=u,i=null,c=void 0}else{const{target:a,property:u,args:d}=t;e=null,n=G(a),r=a,s=G(d),o=d,i=u,this.proxyDepth+=1,c=Reflect.apply(a[u],a,o),this.proxyDepth-=1}const{smartArgs:a,dumbArgs:u}=gt(s);const{smartArgs:d}=gt(o);const h=Object.assign(Object.assign(Object.assign({},a),{obj:n}),{_id:"index"});const l=Object.assign(Object.assign(Object.assign({},d),{obj:r}),{_id:"index"});["Object","Array"].includes(L(c))&&(l.res=c);const[f,p,v]=ft(h,l);void 0!==p[0]&&(p[0].__index=v);const g=v.obj;void 0!==p[g]&&(null!==e&&(p[g].__cls=e),p[g].__func=null===i?"constructor":String(i),p[g].__args=u);const _=v.res;return void 0!==p[_]&&"function Object() { [native code] }"!==c.constructor.toString()&&(p[_].__cls=c.constructor.toString()),[f,p,r,d,c,v]}))}allocate(t,e){return f(this,void 0,void 0,(function*(){const[n,r,s,o,,i]=yield _t.getUpdate({Cls:t,args:e});const[c]=yield this.db.update(n,r);const{txId:a}=N(c);Object.entries(i).forEach((([t,e])=>{const n=parseInt(t,10);let i=o[n];"obj"===t&&(i=s),tt(i,r,e,a)}));const u=`${a}:${i.obj}`;return et([s,...o],u),s}))}update(t,e,n){return f(this,void 0,void 0,(function*(){const[r,s,,o,i,c]=yield _t.getUpdate({target:t,property:e,args:n});const[a]=yield this.db.update(r,s);const{txId:u}=N(a);Object.entries(c).forEach((([e,n])=>{const r=parseInt(e,10);let c=o[r];"obj"===e?c=t:"res"===e&&(c=i),tt(c,s,n,u)}));const d="string"==typeof t._rootId?t._rootId:`${u}:${c.obj}`;return et([i,t,...o],d),i}))}get(t,e){return _t.proxyDepth>0||"function"!=typeof t[e]?Reflect.get(t,e):(...n)=>this.update(t,e,n)}}function wt(t,e){const n=[];let r=0;for(;r<t.length;){const s=r+e;n.push(t.slice(r,s)),r=s}return n}function bt(t,e){const n=new s;if(!Array.isArray(e))throw new Error("Owners is not defined");if(e.length>16)throw new Error("Too many owners");return n.add("OP_1"),e.forEach((t=>{n.add(o.fromString(t).toBuffer())})),n.add(`OP_${e.length}`),n.add("OP_CHECKMULTISIG"),n.add(t),n.add("OP_DROP"),n}function yt(t){const e=t.chunks.length;return!(!t.chunks[e-2].buf||t.chunks[e-1].opcodenum!==r.OP_DROP)}function mt(t,e){const{_amount:n,__vouts:r,_owners:s}=t,o=h(t,["_amount","__vouts","_owners"]);const i=Buffer.from(JSON.stringify(o));return(e.isNonStandard()?[i]:wt(i,x.SCRIPT_CHUNK_SIZE)).map((t=>bt(t,s)))}function Ot(t){if(yt(t))return t.chunks.slice(1,t.chunks.length-4).map((t=>{if(!t.buf)throw new Error("Illegal state");return new o(t.buf).toString()}));throw new Error("Cannot get owners from non-data script")}function xt(t){if(yt(t)){const e=t.chunks[t.chunks.length-2];if(!e.buf)throw new Error("Illegal state");const n=JSON.parse(e.buf.toString());const r=Ot(t);return void 0!==r&&(n._owners=r),n}throw new Error("Not a data script.")}function St(t){const{chunks:e}=t;return e[0].opcodenum===r.OP_HASH160&&e[e.length-1].opcodenum===r.OP_EQUAL}function jt(t){let e=0;const n=[];for(let r=0;r<t.length;r+=1)n.push(e),e+=t[r];return n}function $t(t,e){let n=0;for(let r=0;r<e.length;r+=1){const s=[];for(let t=0;t<e[r];t+=1)s.push(n),n+=1;if(s[0]===t)return s}throw new Error("No match found")}function It(t,e){let n=0;for(let r=0;r<e.length;r+=1){const s=[];for(let t=0;t<e[r];t+=1)s.push(n),n+=1;if(s[0]===t)return r}throw new Error("No match found")}var Et;const{Output:Ct}=e;const{MultiSigScriptHash:Rt}=e.Input;const{UnspentOutput:Bt}=e;let Tt=Et=class{constructor(t,n,r){const s=new e(r);s.feePerKb(x.DEFAULT_FEE),this.nodeConfig=t,this._tx=s,this._outData=[],this._privateKey=n}get chain(){return this.nodeConfig.chain}get network(){return this.nodeConfig.network}get restClient(){return new K(this.nodeConfig,this._privateKey)}get tx(){return this._tx}get inputs(){return this.tx.inputs.map((t=>`${t.prevTxId.toString("hex")}:${t.outputIndex}`))}get inRevs(){let t=0;const{opReturns:e}=this;if(0===e.length)return[];const[{__vins:n}]=e;return Array.isArray(n)?n.map((e=>{if(!this.tx.inputs[t])throw new Error("Input not found in inRevs");const{prevTxId:n,outputIndex:r}=this.tx.inputs[t];return t+=e,`${n.toString("hex")}:${r}`})):[]}get outRevs(){let t=0;const{opReturns:e}=this;if(0===e.length)return[];const[{__vouts:n}]=e;if(!Array.isArray(n))return[];const r=this.tx.id;return n.map((e=>{const n=`${r}:${t}`;return t+=e,n}))}get outData(){return this._outData}get opReturns(){const{outputs:t}=this.tx;return t.filter((t=>{let e;let n;try{e=new s(t.script.toBuffer());const{chunks:r}=e;if(!r[1]||!r[1].buf)return!1;n=JSON.parse(r[1].buf.toString())}catch(t){return!1}return n&&e.toString().startsWith("OP_RETURN")})).map((t=>{var e,n;const r=new s(t.script.toBuffer());const{chunks:o}=r;return JSON.parse((null===(n=null===(e=o[1])||void 0===e?void 0:e.buf)||void 0===n?void 0:n.toString())||"")}))}checkOutDataBCH(t){const e=t.map((t=>mt(h(t,["_amount"]),this.nodeConfig).map((t=>s.buildScriptHashOut(t))))).flat().map((t=>t.toString()));const n=this.tx.outputs.filter((t=>{try{return!!t.script}catch(t){return!1}})).map((t=>new s(t.script))).filter((t=>St(t))).map((t=>t.toString()));return U(n,e)}addMetaData(t){return t.map(((t,e)=>{const n=this.tx.outputs[e];const r="BSV"===this.chain?Ot(new s(n.script)):t._owners;const o=n.satoshis;return void 0!==r&&(t._owners=r),void 0!==o&&(t._amount=o),t}))}spendFromDataBsv(t){return f(this,void 0,void 0,(function*(){const e=t.map(N);const n=e.map((t=>t.txId));const r=yield this.restClient.getTransactions(n);for(let t=0;t<e.length;t+=1){const{txId:n,outIndex:o}=e[t];const{outputs:i}=r[t];const c=i[o];const a=new s(c.script);const u=Math.round(c.satoshis);const d=Ot(a);const h={txId:n,outputIndex:o,script:a,satoshis:u};this.tx.from([new Bt(h)],d,1)}return new Array(e.length).fill(1)}))}spendFromDataBch(t){return f(this,void 0,void 0,(function*(){const e=[];for(const n of t){const{txId:t,outIndex:r}=N(n);const o=yield Et.fromTxId(t,this.restClient.nodeConfig,this._privateKey);const{outData:i}=o;const[{__vouts:c}]=o.opReturns;const a=$t(r,c).map((e=>{const{script:n,satoshis:r}=o.tx.outputs[e];const s=n.toBuffer().toString("hex");return{txId:t,vout:e,scriptPubKey:s,satoshis:r,amount:r/1e8}}));const u=i[It(r,c)];const d=mt(h(u,["_amount"]),this.nodeConfig);d.forEach(((t,e)=>{const{scriptPubKey:n,satoshis:r,txId:o,vout:i}=a[e];const c=new Ct({script:new s(n),satoshis:r});const d=new s;const h=new Rt({prevTxId:o,output:c,outputIndex:i,script:d},u._owners||[],1,null,t);this.tx.addInput(h)})),e.push(d.length)}return e}))}spendFromData(t){return f(this,void 0,void 0,(function*(){return 0===t.length?[]:"BSV"===this.chain?this.spendFromDataBsv(t):this.spendFromDataBch(t)}))}createOpReturnOut(t){this.tx.addData(JSON.stringify(t))}createDataOut(t){const{_amount:e}=t,n=h(t,["_amount"]);const r=e||x.MIN_NON_DUST_AMOUNT;const o=mt(n,this.nodeConfig);if(this._outData.push(n),"BSV"===this.chain){const t=new Ct({script:o[0],satoshis:r});return this.tx.addOutput(t),1}return o.forEach((t=>{const e=new Ct({script:s.buildScriptHashOut(t),satoshis:r});this.tx.addOutput(e)})),o.length}static fromHexBSV(t,e,n){const r=new this(e,n);r.tx.fromString(t);const o=r.tx.outputs.filter((t=>{try{return yt(new s(t.script))}catch(t){return!1}})).map((t=>xt(new s(t.script))));return r._outData=r.addMetaData(o),r}static fromHexBCH(t,e,n,r){const s=new this(e,n);if(s.tx.fromString(t),!s.checkOutDataBCH(r))throw new Error("Invalid data from server in fromHexBCH.");return s._outData=s.addMetaData(r),s}static fromTxId(t,e,n){return f(this,void 0,void 0,(function*(){const r=new K(e,n);if("BSV"===e.chain){const s=yield r.getRawTx(t);return this.fromHexBSV(s,e,n)}const{hex:s,data:o}=yield r.getRawTxData(t);return this.fromHexBCH(s,e,n,o)}))}};function Dt(t){return Buffer.from(u.SHA256(t).toString(),"hex").toString("hex").substr(0,4)}function At(t,e){return Dt(t)===e}function Nt(t){return`${Dt(t)};${t}`}function Kt(t){const e=t.substr(0,4);const n=t.substr(5);if(!At(n,e))throw new Error("Decryption failure");return n}function Pt(){return a.randomBytes(32).toString("hex")}function kt(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const n=Buffer.from(e,"hex").toString("binary");const r=Nt(t);return u.AES.encrypt(r,n).toString()}function Ut(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const n=Buffer.from(e,"hex").toString("binary");return Kt(u.AES.decrypt(t,n).toString(u.enc.Utf8))}function Ht(t,e){if(!/^0[2-3][0-9a-f]{64}|04[0-9a-f]{128}$/.test(e))throw new Error("Invalid publicKey");const n=Nt(t);return d.encrypt(e,Buffer.from(n,"utf8")).toString("base64")}function Lt(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid privateKey");return Kt(d.decrypt(e,Buffer.from(t,"base64")).toString("utf8"))}function Ft(t,e){const n=Pt();return{__cypher:kt(t,n),__secrets:e.map((t=>Ht(n,t)))}}function Jt({__cypher:t,__secrets:e},n){let r="";if(n.forEach((n=>{e.forEach((e=>{try{const s=Lt(e,n);r=Ut(t,s)}catch(t){const e=["Decryption failure","Unsupported state or unable to authenticate data"];if(t instanceof Error&&!e.includes(t.message))throw t}}))})),r)return r;throw new Error("Decryption failure")}function Vt(t){if(void 0!==t._readers){const{_readers:e,_url:n,_owners:r,_amount:s}=t,o=h(t,["_readers","_url","_owners","_amount"]);const i=Ft(JSON.stringify(o),e);return void 0!==n&&(i._url=n),void 0!==r&&(i._owners=r),void 0!==s&&(i._amount=s),i}return t}function Mt(t,e){if(B(t)){const{__cypher:n,__secrets:r}=t,s=h(t,["__cypher","__secrets"]);return Object.assign(Object.assign(Object.assign({},s),JSON.parse(Jt({__cypher:n,__secrets:r},e))),{_readers:[]})}return t}function qt(t){return e=>f(this,void 0,void 0,(function*(){if(void 0!==e._url){const{_url:n,_owners:r,_amount:s}=e,o=h(e,["_url","_owners","_amount"]);const i=yield K.setSecretOutput({host:n,secretOutput:{data:JSON.stringify(o)},privateKey:t.getPrivateKey()});return void 0!==r&&(i._owners=r),void 0!==s&&(i._amount=s),i}return e}))}function Wt(t){return e=>f(this,void 0,void 0,(function*(){if(R(e)){const{_url:n}=e,r=h(e,["_url"]);const{host:s,data:o}=yield K.getSecretOutput({_url:n,privateKey:t.getPrivateKey()});return Object.assign(Object.assign(Object.assign({},r),JSON.parse(o)),{_url:s})}return e}))}Tt=Et=l([T()],Tt);class Gt{constructor(t){this.wallet=t}get chain(){return this.wallet.chain}get network(){return this.wallet.network}get nodeConfig(){return this.wallet.nodeConfig}fromDataTx(t,e=!0,n=!0){return f(this,void 0,void 0,(function*(){const r=t.tx.id;const{inputs:s,inRevs:o,outRevs:i,opReturns:c}=t;const a=this.wallet.getPrivateKey().toBuffer().toString("hex");return{inRevs:o,outRevs:i,inputs:s,outData:yield Promise.all(t.outData.map((t=>f(this,void 0,void 0,(function*(){const r=n?yield Wt(this.wallet)(t):t;return e?Mt(r,[a]):r}))))),opReturns:c,txId:r}}))}fromTxHex(t,e=!0,n=!0){return f(this,void 0,void 0,(function*(){const{wallet:r,nodeConfig:s}=this;const o=r.getPrivateKey();let i;if("BSV"===this.chain)i=Tt.fromHexBSV(t,s,o);else{i=new Tt(s,o),i.tx.fromString(t);const e=yield r.restClient.getOutData(i.tx.id);if(!i.checkOutDataBCH(e))throw new Error("Invalid data from server in fromTxHex.");i._outData=i.addMetaData(e)}return this.fromDataTx(i,e,n)}))}fromTxId(t,e=!0,n=!0){return f(this,void 0,void 0,(function*(){const{wallet:r,nodeConfig:s}=this;const o=r.getPrivateKey();const i=yield Tt.fromTxId(t,s,o);return this.fromDataTx(i,e,n)}))}get(t,e,n){return f(this,void 0,void 0,(function*(){const r=t.map(N);return Promise.all(r.map((({txId:t,outIndex:r})=>f(this,void 0,void 0,(function*(){const{outData:s,opReturns:o}=yield this.fromTxId(t,e,n);const[{__vouts:i}]=o;return s[It(r,i)]})))))}))}put(t){return this.update([],t)}update(t,e){return f(this,void 0,void 0,(function*(){const{wallet:n,nodeConfig:r}=this;const s=n.getPrivateKey();const o=new Tt(r,s);const i=e.map((t=>{var{_owners:e}=t,n=h(t,["_owners"]);return Object.assign({_owners:e||[this.wallet.getPublicKey().toString()]},n)})).map(Vt);const c=yield Promise.all(i.map(qt(this.wallet)));const a=yield o.spendFromData(t);const u=c.map(o.createDataOut.bind(o));o.createOpReturnOut({__vins:a,__vouts:u});const d=yield this.wallet.fundAndSendTransaction(o,!0);return jt(u).map((t=>`${d}:${t}`))}))}}function Zt(t){const e=t;for(let t=e.length-1;t>0;t-=1){const n=Math.floor(Math.random()*(t+1));[e[t],e[n]]=[e[n],e[t]]}}class zt{constructor(t,e,n={}){const{path:r="m/44'/0'/0'/0",passphrase:s=""}=n;let o=t.toHDPrivateKey(s,e.network);r&&(o=o.derive(r));const i=o.publicKey.toAddress(e.network);this.mnemonic=t,this.restClient=e,this.path=r,this.passphrase=s,this.hdPrivateKey=o,this.address=i}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get nodeConfig(){return this.restClient.nodeConfig}getMnemonic(){return this.mnemonic}getPath(){return this.path}derive(t="0"){const e=`${this.path}${this.path.length>0?"/":""}${t}`;return new zt(this.mnemonic,this.restClient,{path:e})}getPrivateKey(){return this.hdPrivateKey.privateKey}getPublicKey(){return this.hdPrivateKey.publicKey}getAddress(){return this.address}getBalance(){return f(this,void 0,void 0,(function*(){return this.restClient.getBalance(this.getAddress())}))}getUtxos(t=this.getAddress()){return f(this,void 0,void 0,(function*(){return this.restClient.getUtxosFromAddress(t)}))}selectUtxos(t,e){let n=0;const r=[];Zt(t);for(let s=0;s<t.length;s+=1){const o=t[s];if(n+=o.satoshis,r.push(o),n>=e)return r}const{network:s,chain:o}=this.restClient.nodeConfig;throw new Error(`Insufficient balance in address ${this.getAddress().toString()} on ${s} ${o}. Found ${n}, required ${e}.`)}fundAndSendTransaction(t,n=!1){return f(this,void 0,void 0,(function*(){t.tx.feePerKb(x.DEFAULT_FEE);const r=t.tx._getInputAmount();const s=t.tx._getOutputAmount()-r+(t.tx._estimateFee()+100);if(s>0){const n=yield this.getUtxos(this.getAddress());this.selectUtxos(n,s).forEach((n=>{t.tx.from([new e.UnspentOutput(n)])}))}t.tx.change(this.getAddress()),t.tx.sign(this.getPrivateKey());const o=yield this.restClient.sendTransaction(t.tx.toString());return n&&(yield this.storeResult(o,t)),o}))}storeResult(t,e){return f(this,void 0,void 0,(function*(){const{outData:n,inputs:r,inRevs:s,outRevs:o}=e;const i=JSON.stringify(n);yield this.restClient.postOutData({outData:i,txId:t,inputs:r,inRevs:s,outRevs:o})}))}send(t,e){return f(this,void 0,void 0,(function*(){const n=new Tt(this.restClient.nodeConfig,this.getPrivateKey());return n.tx.to(e,t),this.fundAndSendTransaction(n)}))}}class Qt{constructor(t,e){this.chain=t,this.network=e}isNonStandard(){return"BSV"===this.chain}}class Xt extends Qt{constructor(t,e,n){super(t,e),this.url=n}}class Yt{constructor(t){if(!t)throw new Error("Please provide a configuration object setting 'chain' and 'network'.");const{chain:e,network:n}=t;if(!e||!["BSV","BCH","LTC","BTC","DOGE"].includes(e.toUpperCase()))throw new Error("Please provide a configuration object setting 'chain' to 'BSV', 'BCH', 'LTC', 'BTC', or 'DOGE'");if(!n||!["mainnet","testnet","regtest"].includes(n.toLowerCase()))throw new Error("Please provide a configuration object setting 'network' to 'mainnet', 'testnet', or 'regtest'");const r=t.bbsUrl||"http://127.0.0.1:3000";const s=t.mnemonic||new i(t.seed);const o=t.path||"m/44'/0'/0'/0";const c=t.passphrase||"";const a=j(s,n,{path:o,passphrase:c});const u=new Xt(e,n,r);const d=new K(u,a);const h=t.db||new Gt(new zt(s,d,{path:o,passphrase:c}));this.db=h}get chain(){return this.db.chain}get network(){return this.db.network}parseContract(t){const e=t.startsWith("export ")?t.slice(7):t;const n=e.startsWith("default ")?e.slice(8):e;return eval(`(${n})`)}new(t,e){return f(this,void 0,void 0,(function*(){const n=t.toString();const r=yield this.parseContract(n);const s=new _t(this.db);const o=yield s.allocate(r,e);return new Proxy(o,s)}))}sync(t){return f(this,void 0,void 0,(function*(){A(t);const e=new vt(this.db);const n=new _t(this.db);const r=yield e.get(t);return new Proxy(r,n)}))}getOwnedRevs(t=this.db.wallet.getPublicKey()){return this.db.wallet.restClient.getOwnedRevs(t)}queryRevs(t){return f(this,void 0,void 0,(function*(){const{publicKey:e,contractName:n,contractHash:r}=t;const s=e?new o(e):void 0;return this.db.wallet.restClient.queryRevs({publicKey:s,contractName:n,contractHash:r})}))}getRevs(t=this.db.wallet.getPublicKey()){return f(this,void 0,void 0,(function*(){return(yield this.getOwnedRevs(t)).map((({rev:t})=>t))}))}getLatestRev(t){return f(this,void 0,void 0,(function*(){return this.db.wallet.restClient.getLatestRev(t)}))}getLatestRevs(t){return f(this,void 0,void 0,(function*(){return this.db.wallet.restClient.getLatestRevs(t)}))}}export{Yt as Computer};
