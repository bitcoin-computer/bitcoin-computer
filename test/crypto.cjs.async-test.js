"use strict";var e=require("tweetnacl");var t=require("eccrypto");var n=require("bitcoin-computer-bitcore");var o=require("chai");var c=require("tweetnacl-util");function i(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var r=i(e);var s=i(t);var u=i(c);function p(e,t,n,o){return new(n||(n=Promise))((function(c,i){function r(e){try{u(o.next(e))}catch(e){i(e)}}function s(e){try{u(o.throw(e))}catch(e){i(e)}}function u(e){var t;e.done?c(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(r,s)}u((o=o.apply(e,t||[])).next())}))}const{PublicKey:a}=n.Bitcoin;function f({iv:e,ephemPublicKey:t,ciphertext:n,mac:o}){return{iv:e,publicKey:t,cipherText:n,mac:o}}function l(e,t){return p(this,void 0,void 0,(function*(){const n=r.default.randomBytes(32);const o=r.default.randomBytes(24);const c=r.default.secretbox(u.default.decodeUTF8(e),o,n);const i=Buffer.concat([Buffer.from(o),Buffer.from(n)]);const l=t.map((e=>p(this,void 0,void 0,(function*(){return f(yield s.default.encrypt(a.fromString(e).toBuffer(),i))}))));return{cipherText:c,envelopes:yield Promise.all(l)}}))}function d(e,t,n){return p(this,void 0,void 0,(function*(){let o;try{o=yield s.default.decrypt(n.toBuffer(),function({iv:e,publicKey:t,cipherText:n,mac:o}){return{iv:e,ephemPublicKey:t,ciphertext:n,mac:o}}(t))}catch(e){throw new Error("Decryption failed.")}const c=o.subarray(0,r.default.secretbox.nonceLength);const i=o.subarray(r.default.secretbox.nonceLength);const p=r.default.secretbox.open(e.cipherText,new Uint8Array(c),new Uint8Array(i));if(null===p)throw new Error("Decryption failed.");return u.default.encodeUTF8(p)}))}const{PrivateKey:y}=n.Bitcoin;describe("Crypto",(()=>{describe("encrypt() and decrypt()",(()=>{it("encrypts a message",(()=>p(void 0,void 0,void 0,(function*(){const e=new y;const t=new y;const n=yield l("42",[e.toPublicKey().toString(),t.toPublicKey().toString()]);o.expect(n.cipherText).to.not.be.undefined,o.expect(n.cipherText).to.be.instanceof(Uint8Array),o.expect(n.envelopes).to.not.be.undefined,o.expect(n.envelopes.length).eq(2),o.expect(n.envelopes[0].cipherText).to.not.be.undefined,o.expect(n.envelopes[0].cipherText).to.be.instanceof(Buffer),o.expect(n.envelopes[0].iv).to.not.be.undefined,o.expect(n.envelopes[0].iv).to.be.instanceof(Buffer),o.expect(n.envelopes[0].mac).to.not.be.undefined,o.expect(n.envelopes[0].mac).to.be.instanceof(Buffer),o.expect(n.envelopes[0].publicKey).to.not.be.undefined,o.expect(n.envelopes[0].publicKey).to.be.instanceof(Buffer),o.expect(n.envelopes[1].cipherText).to.not.be.undefined,o.expect(n.envelopes[1].cipherText).to.be.instanceof(Buffer),o.expect(n.envelopes[1].iv).to.not.be.undefined,o.expect(n.envelopes[1].iv).to.be.instanceof(Buffer),o.expect(n.envelopes[1].mac).to.not.be.undefined,o.expect(n.envelopes[1].mac).to.be.instanceof(Buffer),o.expect(n.envelopes[1].publicKey).to.not.be.undefined,o.expect(n.envelopes[1].publicKey).to.be.instanceof(Buffer)})))),it("decrypts a message with other's key",(()=>p(void 0,void 0,void 0,(function*(){const e=new y;const t=new y;const n=yield l("some super secret message",[e.toPublicKey().toString(),t.toPublicKey().toString()]);const c=yield d(n,n.envelopes[1],t);o.expect(c).eq("some super secret message")})))),it("decrypts a message with my key",(()=>p(void 0,void 0,void 0,(function*(){const e=new y;const t=new y;const n=yield l("some super secret message",[e.toPublicKey().toString(),t.toPublicKey().toString()]);const c=yield d(n,n.envelopes[0],e);o.expect(c).eq("some super secret message")})))),it("throws when using a wrong secret key",(()=>p(void 0,void 0,void 0,(function*(){const e=new y;const t=new y;const n=yield l("some super secret message",[e.toPublicKey().toString(),t.toPublicKey().toString()]);d(n,n.envelopes[1],e).then((()=>{o.expect.fail("Did not throw an error.")})).catch((e=>{o.expect(e).to.be.instanceof(Error),o.expect(e.message).eq("Decryption failed.")}))})))),it("throws when decrypting a wrong cipher text",(()=>p(void 0,void 0,void 0,(function*(){const e=new y;const t=new y;const n=yield l("some super secret message",[e.toPublicKey().toString(),t.toPublicKey().toString()]);d({cipherText:new Uint8Array(16),envelopes:[]},n.envelopes[1],e).then((()=>{o.expect.fail("Did not throw an error.")})).catch((e=>{o.expect(e).to.be.instanceof(Error),o.expect(e.message).eq("Decryption failed.")}))})))),it("throws when using a wrong symmetric key",(()=>p(void 0,void 0,void 0,(function*(){const e=new y;const t=new y;d(yield l("some super secret message",[e.toPublicKey().toString(),t.toPublicKey().toString()]),f(yield s.default.encrypt(t.toPublicKey().toBuffer(),Buffer.alloc(r.default.secretbox.nonceLength+r.default.secretbox.keyLength))),t).then((()=>{o.expect.fail("Did not throw an error.")})).catch((e=>{o.expect(e).to.be.instanceof(Error),o.expect(e.message).eq("Decryption failed.")}))}))))}))}));
