"use strict";const e=["_id","_rev","_owners","_amount","_readers","_url","__vouts","__func","__index","__args"];const t=e=>(Object.prototype.toString.call(e).match(/\s([a-zA-Z]+)/)||[])[1];const o=e=>"object"==typeof e?t(e):t(e).toLowerCase();const r=e=>["number","string","boolean","undefined","Null"].includes(o(e));const i=e=>"Array"===o(e);const a=e=>"Object"===o(e);const d=e=>r(e)||["Array","Object"].includes(o(e));const _=e=>"Object"===o(e)&&Object.keys(e).every((e=>!Number.isNaN(parseInt(e,10))));const c=(e,t)=>{if(!d(e)||!d(t))throw new Error(`Unsupported data types for deep equals: ${o(e)} & ${o(t)}`);if(o(e)!==o(t))return!1;if(r(e)&&r(t))return e===t;const i=(e,t)=>Object.entries(e).every((([e,o])=>c(t[e],o)));return e&&t&&i(e,t)&&i(t,e)};const n=e=>{if(r(e))return e;if(i(e))return e.map(n);if(a(e)){const t=Object.keys(e).reduce(((t,o)=>(t[o]=n(e[o]),t)),{});const o=Object.create(Object.getPrototypeOf(e));return Object.assign(o,t)}throw new Error(`Unsupported data type for clone: ${o(e)}`)};const s=(e,t)=>e.reduce((([e,o],r,i)=>t(r,i)?[[...e,r],o]:[e,[...o,r]]),[[],[]]);const b=(e,t)=>Object.fromEntries(Object.entries(e).map((e=>t(e))));const p=(e,t)=>b(e,(([e,o])=>[e,t(o)]));const u=(e,t)=>Object.fromEntries(Object.entries(e).filter((e=>t(e))));const l=(e,t)=>u(e,(([,e])=>t(e)));const v=(e,t)=>{if(!r(e)){if(i(e))return e.find((e=>v(e,t)));if(a(e))return e._rev===t?e:Object.values(e).find((e=>v(e,t)));throw new Error(`Unsupported type ${o(e)} in findByRev`)}};const x=(e,t,d,_)=>{if(r(e))return e;if(i(e))return e.map((e=>x(e,t,d,_)));if(a(e)){e._rev=`${_}/${d}`;const o=t[d];return Object.entries(e).forEach((([r,i])=>{"object"==typeof o&&Object.keys(o).includes(r)&&(e[r]=x(i,t,o[r],_))})),e}throw new Error(`Unsupported type ${o(e)} in deep.updateRev`)};const h=(e,t)=>{if(r(e))return e;if(i(e))return e.map((e=>h(e,t)));if(a(e))return e._id=!e._id||e._id.startsWith("__temp__")?e._rev:e._id,e._root=e._root||t,Object.entries(e).forEach((([o,r])=>{e[o]=h(r,t)})),e;throw new Error(`Unsupported type ${o(e)} in deep.addId`)};const f=e=>{if(r(e))return e;if(i(e))return e.map((e=>f(e)));if(a(e)){const t=`__temp__/${Math.random()}`;return e._id=e._id||t,e._rev=e._rev||t,Object.values(e).map((e=>f(e))),e}throw new Error(`Unsupported type ${o(e)} in addRandomId`)};const w=e=>{if(r(e))return e;if(i(e))return e.map((e=>w(e)));if(a(e))return b(e,(([e,t])=>["_owners","_readers"].includes(e)?[e,JSON.stringify(t)]:r(t)?[e,t]:[e,w(t)]));throw new Error(`Unexpected type ${o(e)} in stringifyOwners`)};const B=e=>(e._owners&&(e._owners=JSON.parse(e._owners)),e._readers&&(e._readers=JSON.parse(e._readers)),e);const j=e=>{if(r(e))return e;if(i(e)||a(e))return Object.entries(e).reduce(((e,[t,o])=>{const r=j(o);return _(r)?Object.entries(r).forEach((([o,r])=>{e[`${t}_${o}`]=r})):e[t]=r,e}),{});throw new Error(`Unsupported type ${o(e)} in encodeArraysAsObjects`)};const g=t=>{const o={[t._id]:Object.entries(t).reduce(((t,[o,i])=>e.includes(o)?Object.assign(Object.assign({},t),{[o]:i}):r(i)?Object.assign(Object.assign({},t),{[`__basic__${o}`]:i}):Object.assign(Object.assign({},t),{[o]:i._id})),{})};return Object.values(t).filter((e=>!r(e))).reduce(((e,t)=>Object.assign(Object.assign({},e),g(t))),o)};const m=e=>u(e,(([e])=>!e.startsWith("__basic__")));const y=(e,t)=>b(t,(([t,o])=>{const r=e[t];var i;return o.__change=(i=r)?c(i,o)?"same":"diff":"new",[t,o]}));const E=(t,o)=>{const r=t[o];return r.__contains=Object.entries(r).reduce(((o,[r,i])=>["__contains",...e].includes(r)?o:"__change"===r?"new"===i||"diff"===i||o:E(t,i)[i].__contains||o),!1),t};const O=e=>e.reduce(((e,t,o)=>Object.assign(Object.assign({},e),{[t._id]:o})),{});const k=(e,t)=>e.map((e=>Object.entries(e).reduce(((e,[r,i])=>{const a="string"==typeof i&&"undefined"!==o(t[i])?t[i]:i;return Object.assign(Object.assign({},e),{[r]:a})}),{})));const q=(t,o)=>{const r=f(o);const i=r._id;const a=n(t);const d=n(r);const _=w(a);const c=w(d);const b=j(_);const v=j(c);const x=g(b);const h=g(v);const q=y(x,h);const S=p(q,m);const I=E(S,i);const $=I[i];delete I[i];const N=p(I,(e=>e._rev));const U=l(I,(e=>e.__contains||Object.values($).includes(e._id)));const A=Object.values(U);const[M,D]=s(A,(e=>"new"===e.__change));const R=[...D,...M];const J=O(R);const P=k(R,J);const[C]=k([$],J);const T=D.map((e=>e._rev));const[z,...F]=((t,o)=>[o,...t].map((t=>{const o=function(e,t){var o={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(o[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(r=Object.getOwnPropertySymbols(e);i<r.length;i++)t.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(e,r[i])&&(o[r[i]]=e[r[i]])}return o}(t,["_id","_rev","__change","__contains"]);return u(o,(([t,o])=>e.includes(t)||"number"==typeof o))})))(P,C);return[T,F.map(B).map((e=>Object.entries(e).reduce(((e,[t,o])=>Object.assign(Object.assign({},e),{[t]:N[o]||o})),{}))),z]};describe("deep",(()=>{describe("type",(()=>{it("should return the type of a variable",(()=>{expect(o(void 0)).toBe("undefined"),expect(o(null)).toBe("Null"),expect(o(NaN)).toBe("number"),expect(o(4)).toBe("number"),expect(o(new Number(4))).toBe("Number"),expect(o("abc")).toBe("string"),expect(o(new String("abc"))).toBe("String"),expect(o(!0)).toBe("boolean"),expect(o(new Boolean(!0))).toBe("Boolean"),expect(o({a:4})).toBe("Object"),expect(o({a:{b:3}})).toBe("Object"),expect(o([1,2,3])).toBe("Array"),expect(o([1,2,[1,2,3]])).toBe("Array"),expect(o(new ReferenceError)).toBe("Error"),expect(o(new Date)).toBe("Date"),expect(o(new Map)).toBe("Map"),expect(o(new Set)).toBe("Set"),expect(o(new Set([1,2,3]))).toBe("Set"),expect(o(/a-z/)).toBe("RegExp"),expect(o(Math)).toBe("Math"),expect(o(JSON)).toBe("JSON");const e=new class{constructor(e){this.val=e}setVal(e){this.val=e}}(3);expect(o(e)).toBe("Object")}))})),describe("isBasic",(()=>{it("should return true for values of basic type",(()=>{expect(r(1)).toBe(!0),expect(r("1")).toBe(!0),expect(r(!0)).toBe(!0),expect(r(null)).toBe(!0),expect(r(void 0)).toBe(!0),expect(r({})).toBe(!1),expect(r([])).toBe(!1)}))})),describe("isArray",(()=>{it("should return true for arrays",(()=>{expect(i(1)).toBe(!1),expect(i("1")).toBe(!1),expect(i(!0)).toBe(!1),expect(i(null)).toBe(!1),expect(i(void 0)).toBe(!1),expect(i({})).toBe(!1),expect(i([])).toBe(!0)}))})),describe("isObject",(()=>{it("should return true for objects",(()=>{expect(a(1)).toBe(!1),expect(a("1")).toBe(!1),expect(a(!0)).toBe(!1),expect(a(null)).toBe(!1),expect(a(void 0)).toBe(!1),expect(a({})).toBe(!0),expect(a([])).toBe(!1)}))})),describe("isSupported",(()=>{it("should return true for supported objects",(()=>{expect(d(1)).toBe(!0),expect(d("1")).toBe(!0),expect(d(!0)).toBe(!0),expect(d(null)).toBe(!0),expect(d(void 0)).toBe(!0),expect(d({})).toBe(!0),expect(d([])).toBe(!0),expect(d(new Number)).toBe(!1)}))})),describe("encodesArray",(()=>{it("should return true for objects that encode arrays",(()=>{expect(_({a:1})).toBe(!1),expect(_({0:1,a:2})).toBe(!1),expect(_({0:1})).toBe(!0),expect(_({0:1,2345234:2})).toBe(!0)}))})),describe("equals",(()=>{it("Should work for numbers",(()=>{expect(c(1,1)).toBe(!0),expect(c(1,0)).toBe(!1),expect(c(1,null)).toBe(!1),expect(c(1,void 0)).toBe(!1)})),it("Should work for strings",(()=>{expect(c("a","a")).toBe(!0),expect(c("a","b")).toBe(!1),expect(c("a",null)).toBe(!1),expect(c("a",void 0)).toBe(!1)})),it("Should work for booleans",(()=>{expect(c(!0,!0)).toBe(!0),expect(c(!0,!1)).toBe(!1),expect(c(!0,null)).toBe(!1),expect(c(!0,void 0)).toBe(!1)})),it("Should work for flat arrays",(()=>{expect(c([1,2,3],[1,2,3])).toBe(!0),expect(c([1,2,3],[1,3,2])).toBe(!1),expect(c([1,2,3],null)).toBe(!1),expect(c(null,[1,2,3])).toBe(!1),expect(c([1,2,3],void 0)).toBe(!1),expect(c([1,2,3],[[1,2,3]])).toBe(!1),expect(c([1,2,3],{a:"a"})).toBe(!1),expect(c([1,2,3],[])).toBe(!1),expect(c([1,2,3],{})).toBe(!1);const e=[1,2,3];e.yo="hi",expect(c(e,[1,2,3])).toBe(!1),expect(c([1,2,3],e)).toBe(!1)})),it("Should work for flat objects",(()=>{expect(c({a:"a",b:"b"},{b:"b",a:"a"})).toBe(!0),expect(c({a:"a",b:"b"},{a:"a"})).toBe(!1),expect(c({a:"a"},[["a","a"]])).toBe(!1),expect(c({a:"a",b:"b"},null)).toBe(!1),expect(c({a:"a",b:"b"},void 0)).toBe(!1),expect(c({a:"a",b:"b"},{a:"a",b:{a:"a",b:"b"}})).toBe(!1),expect(c({a:"a",b:"b"},[])).toBe(!1),expect(c({a:"a",b:"b"},{})).toBe(!1)})),it("Should work for nested objects",(()=>{expect(c({a:{b:"b"}},{a:{b:"b"}})).toBe(!0),expect(c({a:{b:"b"}},{a:[["b","b"]]})).toBe(!1),expect(c({a:[["b","b"]]},{a:{b:"b"}})).toBe(!1),expect(c(["a",{b:"b"}],["a",{b:"b"}])).toBe(!0),expect(c(["a",{b:"b"}],[{b:"b"},"a"])).toBe(!1),expect(c(["a",{b:"b"}],["a",[["b","b"]]])).toBe(!1),expect(c(["a",[["b","b"]]],["a",{b:"b"}])).toBe(!1)})),it("Should throw an error all other values",(()=>{expect((()=>c(new Set,new Set))).toThrow(),expect((()=>c(new Map,new Map))).toThrow(),expect((()=>c(new Date,new Date))).toThrow()}))})),describe("clone",(()=>{it("should work for null and the empty object",(()=>{expect(n(null)).toBe(null),expect(n({})).toStrictEqual({}),expect(n(void 0)).toStrictEqual(void 0)})),it("should work for objects without functions",(()=>{const e={a:"a",b:"b"};const t=n(e);expect(c(e,t)).toBe(!0),expect(t).toEqual(e),expect(t).not.toBe(e),expect(t.a).toBe(e.a),expect(t.b).toBe(e.b),e.a="aa",t.b="bb",expect(e.b).toBe("b"),expect(t.a).toBe("a")})),it("should work for objects in arrays",(()=>{const e=[,{a:"a",b:"b"}];expect(n(e)).toEqual(e)})),it("should work for objects with functions",(()=>{class e{constructor(e){this.val=e}mult(e){this.val*=e}}const t=new class{constructor(e,t,o,r){this.x=e,this.y=t,this.xx=o,this.yy=r}appendX(e){this.x+=e}}("x","y",new e(3),new e(4));const o=n(t);expect(t).toEqual(o),expect(c(t,o)).toBe(!0),t.a="a",expect(o.a).toBe(void 0),t.xx.a="a",expect(o.xx.a).toBe(void 0),o.appendX("x"),expect(o.x).toBe("xx"),expect(t.x).toBe("x"),o.xx.mult(2),expect(o.xx.val).toBe(6),expect(t.xx.val).toBe(3)}))})),describe("partition",(()=>{it("should work",(()=>{expect(s([1,2,3],(e=>e>2))).toEqual([[3],[1,2]]),expect(s([1,2,3],(e=>e>20))).toEqual([[],[1,2,3]]),expect(s([1,2,3],(e=>e>0))).toEqual([[1,2,3],[]])}))})),describe("objectEntryMap",(()=>{it("should work for an object",(()=>{expect(b({a:1,b:2},(e=>[e[0].repeat(2),2*e[1]]))).toEqual({aa:2,bb:4})}))})),describe("objectMap",(()=>{it("should work for an object",(()=>{expect(p({a:1,b:2},(e=>2*e))).toEqual({a:2,b:4})}))})),describe("objectEntryFilter",(()=>{it("should work for an object",(()=>{expect(u({a:1,b:2},(e=>e[1]>1))).toEqual({b:2})}))})),describe("objectFilter",(()=>{it("should work",(()=>{expect(l({a:1,b:2},(e=>e>1))).toEqual({b:2})}))})),describe("findByRev",(()=>{it("should work for a flat object",(()=>{expect(v({_id:"id",_rev:"rev",_root:"root"},"rev")).toEqual({_id:"id",_rev:"rev",_root:"root"})})),it("should work for a nested object",(()=>{expect(v({_id:"id1",_rev:"rev1",_root:"root",a:{_id:"id2",_rev:"rev2",_root:"root"}},"rev1")).toEqual({_id:"id1",_rev:"rev1",_root:"root",a:{_id:"id2",_rev:"rev2",_root:"root"}})})),it("should work for a nested object",(()=>{expect(v({_id:"id1",_rev:"rev1",_root:"root",a:{_id:"id2",_rev:"rev2",_root:"root"}},"rev2")).toEqual({_id:"id2",_rev:"rev2",_root:"root"})})),it("should return undefined if rev does not exist",(()=>{expect(v({_id:"id1",_rev:"rev1",_root:"root",a:{_id:"id2",_rev:"rev2",_root:"root"}},"rev3")).toBeUndefined()})),it("should work if rev is undefined",(()=>{expect(v({_id:"id1",_rev:"rev1",_root:"root",a:{_id:"id2",_rev:"rev2",_root:"root"}},void 0)).toBeUndefined()}))})),describe("updateRev",(()=>{it("should work for objects of basic type",(()=>{expect(x(1,[{}],0,"txId")).toEqual(1)})),it("should work for a flat object",(()=>{expect(x({a:1,_id:"id",_rev:"rev"},[{}],0,"txId")).toEqual({a:1,_id:"id",_rev:"txId/0"})})),it("should work for a nested object",(()=>{expect(x({a1:1,_id:"id1",_rev:"rev1",a2:{_id:"id1",_rev:"rev1",b:2}},[{a2:1},{}],0,"txId")).toEqual({a1:1,_id:"id1",_rev:"txId/0",a2:{_id:"id1",_rev:"txId/1",b:2}})})),it("should work for an array",(()=>{expect(x([{a:1,_id:"id",_rev:"rev"}],[{}],0,"txId")).toEqual([{_id:"id",_rev:"txId/0",a:1}])}))})),describe("addId",(()=>{it("should set an id that starts with __temp__ by the rev",(()=>{expect(h({_id:"__temp__",_rev:"rev"},"root")).toStrictEqual({_id:"rev",_rev:"rev",_root:"root"})})),it("should leave an id that does not start with __temp__ as it is",(()=>{expect(h({_id:"id",_rev:"rev"},"root")).toStrictEqual({_id:"id",_rev:"rev",_root:"root"})})),it("should work for a nested object",(()=>{expect(h({_id:"id1",_rev:"rev1",_root:"root",a:{_id:"__temp__",_rev:"rev2",_root:"root"}},"root")).toStrictEqual({_id:"id1",_rev:"rev1",_root:"root",a:{_id:"rev2",_rev:"rev2",_root:"root"}})})),it("should work with an array",(()=>{expect(h([{_id:"__temp__",_rev:"rev1"},{_id:"__temp__",_rev:"rev2"}],"root")).toStrictEqual([{_id:"rev1",_rev:"rev1",_root:"root"},{_id:"rev2",_rev:"rev2",_root:"root"}])}))})),describe("addRandomId",(()=>{it("should modify a simple object",(()=>{const e={a:1};f(e),expect(e._id).toBeDefined()})),it("should work for a nested object",(()=>{const e={a:{b:1}};f(e),expect(e).toEqual({a:{b:1,_id:expect.any(String),_rev:expect.any(String)},_id:expect.any(String),_rev:expect.any(String)})})),it("should work for a nested object",(()=>{f({obj:{n:{m:1}},_id:"index"})})),it("should work for an array",(()=>{const e=[1,2,3];f(e),expect(e).toEqual([1,2,3])})),it("should work for an object containing an array",(()=>{const e={a:[1,2,3]};f(e),expect(e._id).toBeDefined(),expect(e.a._id).toBeUndefined()})),it("should work for an object containing an array of objects",(()=>{const e={a:[{b:1},{c:2}]};f(e),expect(e._id).toBeDefined(),expect(e.a._id).toBeUndefined(),expect(e.a[0]._id).toBeDefined(),expect(e.a[1]._id).toBeDefined()}))})),describe("stringifyOwners",(()=>{it("should work for an empty array",(()=>{expect(w({_id:"id",_rev:"rev",_owners:[],_amount:0})).toEqual({_id:"id",_rev:"rev",_owners:"[]",_amount:0})})),it("should work for a non empty array",(()=>{expect(w({_id:"id",_rev:"rev",_owners:["publicKey"],_amount:0,a:{_id:"id",_rev:"rev",_owners:[],_amount:0}})).toEqual({_id:"id",_rev:"rev",_owners:'["publicKey"]',_amount:0,a:{_id:"id",_rev:"rev",_owners:"[]",_amount:0}})}))})),describe("encodeArraysAsObjects",(()=>{it("should work on unnested objects",(()=>{expect(j({a:1,b:2})).toEqual({a:1,b:2})})),it("should work on nested objects",(()=>{expect(j({a:{b:2}})).toEqual({a:{b:2}})})),it("should work with an object inside an array",(()=>{expect(j([{a:1}])).toEqual({0:{a:1}})})),it("should work with an array inside an object",(()=>{expect(j({a:[1,2,3]})).toEqual({a_0:1,a_1:2,a_2:3})})),it("should work on multiple levels of nesting",(()=>{expect(j({a:[{b:1}]})).toEqual({a_0:{b:1}})})),it("should work with even more levels of nesting",(()=>{expect(j({a:[[{b:1}]]})).toEqual({a_0_0:{b:1}})})),it("should work if the object has keywords",(()=>{expect(j({a:1,_id:"id",_rev:"rev",_owners:"[laks, lasjnd]"})).toEqual({_id:"id",_rev:"rev",_owners:"[laks, lasjnd]",a:1})}))})),describe("groupById",(()=>{it("should work for a simple object",(()=>{expect(g({_id:"id",_rev:"rev",a:1})).toEqual({id:{_id:"id",_rev:"rev",__basic__a:1}})})),it("should work for a object with one child",(()=>{expect(g({_id:"id0",b:{_id:"id1",a:1},c:2})).toEqual({id0:{_id:"id0",b:"id1",__basic__c:2},id1:{_id:"id1",__basic__a:1}})})),it("should work for an object with two children",(()=>{expect(g({_id:"id0",a:{_id:"id1",aa:1},b:{_id:"id2",bb:2}})).toEqual({id0:{_id:"id0",a:"id1",b:"id2"},id1:{_id:"id1",__basic__aa:1},id2:{_id:"id2",__basic__bb:2}})})),it("should work for an object with a grandchild",(()=>{expect(g({_id:"id0",a:{_id:"id1",b:{_id:"id2",c:1}}})).toEqual({id0:{_id:"id0",a:"id1"},id1:{_id:"id1",b:"id2"},id2:{_id:"id2",__basic__c:1}})}))})),describe("getChange",(()=>{it("should work for json objects",(()=>{expect(y({"id:0":{_id:"id:0",a:"id:1",__basic__aa:2},"id:1":{_id:"id:1",__basic__b:1,__basic__bb:2}},{"id:0":{_id:"id:0",a:"id:1",__basic__aa:2},"id:1":{_id:"id:1",__basic__b:2,__basic__bb:3}})).toEqual({"id:0":{_id:"id:0",a:"id:1",__basic__aa:2,__change:"same"},"id:1":{_id:"id:1",__basic__b:2,__basic__bb:3,__change:"diff"}})}))})),describe("containsChange",(()=>{it("should work for a flat object that is not changed",(()=>{expect(E({"id:1":{_rev:"rev:0",_owners:"['a', 'b']",_amount:1,__change:"same"}},"id:1")).toEqual({"id:1":{_rev:"rev:0",_owners:"['a', 'b']",_amount:1,__change:"same",__contains:!1}})})),it("should work for an object that is not changed",(()=>{expect(E({id1:{a:"id2",__change:"same"},id2:{__change:"same"}},"id1")).toEqual({id1:{a:"id2",__change:"same",__contains:!1},id2:{__change:"same",__contains:!1}})})),it("should work for an object that is changed at the top level",(()=>{expect(E({id1:{a:"id2",b:"id3",__change:"diff"},id2:{__change:"same"},id3:{__change:"same"}},"id1")).toEqual({id1:{a:"id2",b:"id3",__change:"diff",__contains:!0},id2:{__change:"same",__contains:!1},id3:{__change:"same",__contains:!1}})})),it("should work for an object that is changed at a lower level",(()=>{expect(E({id1:{a:"id2",b:"id3",__change:"same"},id2:{__change:"diff"},id3:{__change:"same"}},"id1")).toEqual({id1:{a:"id2",b:"id3",__change:"same",__contains:!0},id2:{__change:"diff",__contains:!0},id3:{__change:"same",__contains:!1}})})),it.skip("should work for an object with a cycle",(()=>{expect(E({id1:{a:"id2",__change:"same"},id2:{b:"id1",__change:"diff"}},"id1")).toEqual({id1:{a:"id2",__change:"same",__contains:!0},id2:{b:"id1",__change:"diff",__contains:!0}})}))})),describe("parseOwners",(()=>{it("should work with a simple object",(()=>{const e="03bf2dc338dd8133a3184657eb67bed5f61647a8a7364bf2906e3db77bff89e241";expect(B({a:1,_owners:`["${e}"]`})).toEqual({a:1,_owners:[e]})}))})),describe("getIdPosMap",(()=>{it("should work",(()=>{expect(O([{_id:"id:1",_rev:"rev:1",_root:"root",__change:"same",__contains:!1},{_id:"id:2",_rev:"rev:2",_root:"root",b:"__temp__:3",__change:"diff",__contains:!0},{_id:"__temp__:3",_rev:"__temp__:3",_root:"root",__change:"new",__contains:!0}])).toEqual({"__temp__:3":2,"id:1":0,"id:2":1})}))})),describe("resolveIds",(()=>{it("should work",(()=>{const e=[{_id:"id:1",_rev:"rev:1",_root:"root",__change:"same",__contains:!1},{_id:"id:2",_rev:"rev:2",_root:"root",b:"__temp__:3",__change:"diff",__contains:!0},{_id:"__temp__:3",_rev:"__temp__:3",_root:"root",__change:"new",__contains:!0}];const t=O(e);expect(t).toEqual({"id:1":0,"id:2":1,"__temp__:3":2}),expect(k(e,t)).toEqual([{__change:"same",__contains:!1,_id:0,_rev:"rev:1",_root:"root"},{__change:"diff",__contains:!0,_id:1,_rev:"rev:2",_root:"root",b:2},{__change:"new",__contains:!0,_id:2,_root:"root",_rev:2}])}))})),describe("diff",(()=>{it("should not throw an error if an id is set",(()=>{expect(q({_id:"1",_rev:"rev",_amount:1,_owners:[{}]},{_id:"1",_rev:"2"})).toEqual([[],[],{}])})),it("should not throw an error if an id is set",(()=>{expect(q({},{n:1})).toEqual([[],[],{}])})),it("should update a root object even if it is not changed",(()=>{expect(q({_id:"id:0",_rev:"rev:0",obj:{_id:"id:1",_rev:"rev:1",a:1}},{_id:"id:0",_rev:"rev:0",obj:{_id:"id:1",_rev:"rev:1",a:1}})).toEqual([["rev:1"],[{}],{obj:0}])})),it("should update a root object that is changed",(()=>{expect(q({_id:"id:0",_rev:"rev:0",0:{_id:"id:1",_rev:"rev:1",a:1}},{_id:"id:0",_rev:"rev:0",0:{_id:"id:1",_rev:"rev:1",a:2}})).toEqual([["rev:1"],[{}],{0:0}])})),it("should update a root object that is changed on the top level but not any of its children",(()=>{expect(q({_id:"id:0",_rev:"rev:0",obj:{_id:"id:1",_rev:"rev:1",a:{_id:"id:2",_rev:"rev:2",aa:1},b:{_id:"id:3",_rev:"rev:3",bb:1},c:1}},{_id:"id:0",_rev:"rev:0",obj:{_id:"id:1",_rev:"rev:1",a:{_id:"id:2",_rev:"rev:2",aa:1},b:{_id:"id:3",_rev:"rev:3",bb:1},c:2}})).toEqual([["rev:1"],[{}],{obj:0}])})),it("should update a lower level object that is changed as well as all node on its root path",(()=>{expect(q({_id:"id:0",_rev:"rev:0",obj:{_id:"id:1",_rev:"rev:1",a:{_id:"id:2",_rev:"rev:2",b:{_id:"id:3",_rev:"rev:3",bb:1}}}},{_id:"id:0",_rev:"rev:0",obj:{_id:"id:1",_rev:"rev:1",a:{_id:"id:2",_rev:"rev:2",b:{_id:"id:3",_rev:"rev:3",bb:2}}}})).toEqual([["rev:1","rev:2","rev:3"],[{a:1},{b:2},{}],{obj:0}])})),it("should work for creating an object with arguments",(()=>{expect(q({_id:"id:0",_rev:"rev:0",arg:{_id:"id:3",_rev:"rev:3"}},{_id:"id:0",_rev:"rev:0",obj:{_id:"id:1",_rev:"rev:1",a:{_id:"id:2",_rev:"rev:2",aa:2}},arg:{_id:"id:3",_rev:"rev:3"}})).toEqual([["rev:3"],[{},{a:2},{}],{arg:0,obj:1}])})),it("should update a root object that is changed",(()=>{const e="03bf2dc338dd8133a3184657eb67bed5f61647a8a7364bf2906e3db77bff89e241";const t="02141c63825cad04ea507ea62464e926ed4cb4fbaef9eae5a3e8e1f0febcda2c77";expect(q({_id:"id:0",_rev:"rev:0",_owners:[e],0:{_id:"id:1",_rev:"rev:1",_owners:[t],a:1}},{_id:"id:0",_rev:"rev:0",_owners:[e],0:{_id:"id:1",_rev:"rev:1",_owners:[t],a:2}})).toEqual([["rev:1"],[{_owners:[expect.any(String)]}],{0:0,_owners:`["${e}"]`}])}))}))}));
