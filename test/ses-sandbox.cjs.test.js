"use strict";require("ses");var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};class t{constructor(e){Object.defineProperty(this,"getItem",{enumerable:!1,value:e.fn((e=>this[e]||null))}),Object.defineProperty(this,"setItem",{enumerable:!1,value:e.fn(((e,t="")=>{this[e]=t+""}))}),Object.defineProperty(this,"removeItem",{enumerable:!1,value:e.fn((e=>{delete this[e]}))}),Object.defineProperty(this,"clear",{enumerable:!1,value:e.fn((()=>{Object.keys(this).map((e=>delete this[e]))}))}),Object.defineProperty(this,"toString",{enumerable:!1,value:e.fn((()=>"[object Storage]"))}),Object.defineProperty(this,"key",{enumerable:!1,value:e.fn((e=>Object.keys(this)[e]||null))})}get length(){return Object.keys(this).length}get __STORE__(){return this}}void 0!==e._localStorage?Object.defineProperty(e,"_localStorage",{value:new t(jest),writable:!1}):e.localStorage=new t(jest),void 0!==e._sessionStorage?Object.defineProperty(e,"_sessionStorage",{value:new t(jest),writable:!1}):e.sessionStorage=new t(jest);const o=e=>new Compartment({}).evaluate(e);describe("secureEval",(()=>{it("Should parse a string to a number",(()=>{expect(o("100")).toEqual(100)})),it("Should parse a string to a function",(()=>{class e{constructor(e){this.n=e}}const t=o(`(${e})`);expect(new t(1)).toEqual(new e(1))})),it("Should be able to evaluate an addition",(()=>{expect(o("1 + 1")).toEqual(2)})),it("Should be able to evaluate Math.abs",(()=>{expect(o("Math.abs(-500)")).toEqual(500)})),it("Should throw an error when trying to access localStorage",(()=>{localStorage.setItem("x","5"),expect(localStorage.getItem("x")).toEqual("5"),expect((()=>o("localStorage.getItem('x')"))).toThrow()})),it("Should throw an error when using the console",(()=>{expect((()=>o("console.log('x')"))).toThrow()}))})),describe("secureApply",(()=>{it("it should work with Math.floor",(()=>{var e,t;expect((e=Math.floor,t=[1.75],new Compartment({target:e,thisArgument:void 0,argumentsList:t}).evaluate("Reflect.apply(target, thisArgument, argumentsList)"))).toBe(1)}))})),describe("secureConstruct",(()=>{it("it should work with Math.floor",(()=>{class e{constructor(e){this.n=e}}var t,o;expect((t=e,o=[1],new Compartment({target:t,argumentsList:o}).evaluate(`Reflect.construct(${t}, argumentsList)`))).toEqual(new e(1))})),it("it should work with Math.floor",(()=>{class e{constructor(e){this.n=e}}expect(Reflect.construct(e,[1])).toEqual(new e(1))}))}));
