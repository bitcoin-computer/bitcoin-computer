"use strict";var t=require("bitcoin-computer-bitcore");var e=require("axios");require("crypto");var n=require("crypto-js");var r=require("eciesjs");var o=require("http");var s=require("https");var i=require("url");function a(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}function c(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,r.get?r:{enumerable:!0,get:function(){return t[n]}})}})),e.default=t,Object.freeze(e)}require("util"),require("ses");var u=a(e);var d=a(n);var l=c(r);var h=a(o);var p=a(s);var f=a(i);function g(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(r=Object.getOwnPropertySymbols(t);o<r.length;o++)e.indexOf(r[o])<0&&Object.prototype.propertyIsEnumerable.call(t,r[o])&&(n[r[o]]=t[r[o]])}return n}function v(t,e,n,r){var o,s=arguments.length,i=s<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,r);else for(var a=t.length-1;a>=0;a--)(o=t[a])&&(i=(s<3?o(i):s>3?o(e,n,i):o(e,n))||i);return s>3&&i&&Object.defineProperty(e,n,i),i}function w(t,e,n,r){return new(n||(n=Promise))((function(o,s){function i(t){try{c(r.next(t))}catch(t){s(t)}}function a(t){try{c(r.throw(t))}catch(t){s(t)}}function c(t){var e;t.done?o(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(i,a)}c((r=r.apply(t,e||[])).next())}))}const m=process.env.CHAIN||"LTC";const y=process.env.NETWORK||"testnet";const x=process.env.BCN_URL||"https://node.bitcoincomputer.io";const b=parseInt(process.env.BC_DUST_LIMIT||"",10)||1546;const S=parseInt(process.env.BC_DEFAULT_FEE||"",10)||2500;var B={CHAIN:m,NETWORK:y,BCN_URL:x,MIN_NON_DUST_AMOUNT:b,SCRIPT_CHUNK_SIZE:parseInt(process.env.BC_SCRIPT_CHUNK_SIZE||"",10)||479,DEFAULT_FEE:S,SIGHASH_ALL:1,FEE_PER_KB:2e4,PUBLIC_KEY_SIZE:65,ANYONE_CAN_SPEND_SEED:"replace this seed",PASSPHRASE:"",ENCODING_LENGTH:3,ENCODING_NUMBER_LENGTH:3,MAX_PUBKEYS_PER_SCRIPT:3,OP_RETURN_SIZE:80};const{crypto:T}=t.Bitcoin;const E=(t,e)=>{const n=Date.now();const r=T.Hash.sha256(Buffer.from(e+n));const o=[T.ECDSA.sign(r,t,"big").toString("hex"),t.publicKey.toString(),n];return`Bearer ${Buffer.from(o.join(":")).toString("base64")}`};const{Transaction:O}=t.Bitcoin;function N(t){return w(this,void 0,void 0,(function*(){if(!function(t){return void 0!==t.config}(t))throw new Error("Unknown error");const{message:e,config:n,response:r}=t;const o=function(t){try{const e=JSON.parse(t);if("object"!=typeof e)throw new Error("Invalid object");if("string"!=typeof e.txhex)throw new Error("Invalid object");return new O(e.txhex)}catch(t){return null}}(null==n?void 0:n.data);const s=`message\t${e}`;const i=`request\t${null==n?void 0:n.method} ${null==n?void 0:n.url}`;const a=o?`transaction\t ${JSON.stringify(o.toJSON(),null,2)}`:"";const c="post"===(null==n?void 0:n.method)?`data\t${null==n?void 0:n.data}`:"";const u=r?`response\t${JSON.stringify(r.data)}`:"";const d=o?a:c;throw t.message=`\n    Communication Error\n    ${s}\n    ${i}\n    ${d}\n    ${u}`,t}))}class _{constructor(t,e,n={}){this.baseUrl=t,this.headers=n,this.privateKey=e}get(t){return w(this,void 0,void 0,(function*(){const e=`${this.baseUrl}${t}`;try{let t={};return this.privateKey&&(t={Authentication:E(this.privateKey,this.baseUrl)}),(yield u.default.get(e,{headers:Object.assign(Object.assign({},this.headers),t)})).data}catch(t){return N(t)}}))}post(t,e){return w(this,void 0,void 0,(function*(){const n=`${this.baseUrl}${t}`;try{let t={};return this.privateKey&&(t={Authentication:E(this.privateKey,this.baseUrl)}),(yield u.default.post(n,e,{headers:Object.assign(Object.assign({},this.headers),t)})).data}catch(t){return N(t)}}))}delete(t){return w(this,void 0,void 0,(function*(){const e=`${this.baseUrl}${t}`;try{let t={};return this.privateKey&&(t={Authentication:E(this.privateKey,this.baseUrl)}),(yield u.default.delete(e,{headers:Object.assign(Object.assign({},this.headers),t)})).data}catch(t){return N(t)}}))}}const{PrivateKey:C,Transaction:P}=t.Bitcoin;function A(t){if(!/^[0-9A-Fa-f]{64}$/.test(t))throw new Error(`Invalid txId: ${t}`)}function R(t){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(t))throw new Error(`Invalid outId: ${t}`)}function I(t){R(t);const[e,n]=t.split("/");return{txId:e,outputIndex:parseInt(n,10)}}let D=class{constructor(t,e=new C){this.nodeConfig=t,this.bcn=new _(t.url,e)}get chain(){return this.nodeConfig.chain}get network(){return this.nodeConfig.network}getBalance(t){return w(this,void 0,void 0,(function*(){const{chain:e,network:n}=this;return yield this.bcn.get(`/v1/${e}/${n}/address/${t}/balance`)}))}getTransaction(t){return w(this,void 0,void 0,(function*(){return new P(yield this.getRawTx(t))}))}getRawTx(t){return w(this,void 0,void 0,(function*(){A(t);const{chain:e,network:n}=this;return this.bcn.get(`/v1/${e}/${n}/tx/${t}`)}))}getRawTxData(t){return w(this,void 0,void 0,(function*(){A(t);const{chain:e,network:n}=this;return this.bcn.get(`/v1/${e}/${n}/tx-data/${t}`)}))}getTransactions(t){return w(this,void 0,void 0,(function*(){return(yield this.getRawTxs(t)).map((t=>new P(t)))}))}getRawTxs(t){return w(this,void 0,void 0,(function*(){t.map(A);const{chain:e,network:n}=this;return this.bcn.post(`/v1/${e}/${n}/tx/bulk/`,{txIds:t})}))}sendTransaction(t){return w(this,void 0,void 0,(function*(){return this.bcn.post(`/v1/${this.chain}/${this.network}/tx/send`,{rawTx:t})}))}getUtxosFromAddress(t){return w(this,void 0,void 0,(function*(){const{chain:e,network:n}=this;return this.bcn.get(`/v1/${e}/${n}/wallet/${t.toString()}/utxos`)}))}postNonStandardUtxo(t){return w(this,void 0,void 0,(function*(){const{chain:e,network:n}=this;return this.bcn.post(`/v1/${e}/${n}/non-standard-utxo`,t)}))}getOwnedRevs(t){return w(this,void 0,void 0,(function*(){const{chain:e,network:n}=this;return this.bcn.get(`/v1/${e}/${n}/wallet/${t.toString()}/non-standard-utxos`)}))}queryRevs(t){return w(this,void 0,void 0,(function*(){const{publicKey:e,contractName:n,contractHash:r}=t;if(void 0===e&&void 0===n&&void 0===r)throw new Error("Filter parameter for queryRevs endpoint cannot be empty.");let o="";e&&(o+=`?publicKey=${e}`),n&&(o+=0===o.length?"?":"&",o+=`contractName=${n}`),r&&(o+=0===o.length?"?":"&",o+=`contractHash=${r}`);const{chain:s,network:i}=this;return this.bcn.get(`/v1/${s}/${i}/non-standard-utxos${o}`)}))}getLatestRev(t){return w(this,void 0,void 0,(function*(){R(t);const{chain:e,network:n}=this;const[{rev:r}]=yield this.bcn.get(`/v1/${e}/${n}/rev/${t}`);return r}))}getLatestRevs(t){return w(this,void 0,void 0,(function*(){t.map(R),t.map(R);const{chain:e,network:n}=this;return yield this.bcn.post(`/v1/${e}/${n}/revs`,{ids:t})}))}static getSecretOutput({_url:t,privateKey:e}){return w(this,void 0,void 0,(function*(){const n=t.split("/");const r=n[n.length-1];const o=n.slice(0,-2).join("/");const s=new _(o,e);return{host:o,data:yield s.get(`/v1/store/${r}`)}}))}static setSecretOutput({secretOutput:t,host:e,privateKey:n}){return w(this,void 0,void 0,(function*(){return new _(e,n).post("/v1/store/",t)}))}static deleteSecretOutput({_url:t,privateKey:e}){return w(this,void 0,void 0,(function*(){const n=t.split("/");const r=n[n.length-1];const o=n.slice(0,-2).join("/");const s=new _(o,e);yield s.delete(`/v1/store/${r}`)}))}};D=v([t=>t],D);const{PublicKey:K,crypto:U}=t.Bitcoin;const{Point:j}=U;function $(t){return Buffer.from(t,"hex").toString().replace(/\0/g,"")}function k(t,e){return t.slice(e)+t.slice(0,e)}function M(t,e,n){if(t.length*Math.log2(e)>53)throw new Error(`Input too large ${t.length} ${Math.log2(e)}`);if(![2,10,16].includes(e)||![2,10,16].includes(n))throw new Error("ToBase or FromBase invalid in covertNumber.");if(2===e&&t.length%8!=0)throw new Error("Binary strings must be byte aligned.");if(16===e&&t.length%2!=0)throw new Error("Hex strings must be of even length.");const r=parseInt(t,e).toString(n);return 2===n?r.padStart(8*Math.ceil(r.length/8),"0"):16===n?r.padStart(2*Math.ceil(r.length/2),"0"):r}function H(t,e){const n=new RegExp(`.{1,${e}}`,"g");return t.match(n)||[]}function L(t){return H(t,2).map((t=>M(t,16,2))).join("")}function q(t){return H(t,8).map((t=>M(t,2,16))).join("")}function F(t){return t.toString(16).padStart(B.ENCODING_NUMBER_LENGTH,"0")}function G(t){return parseInt(t,16)}function W(t){if(62!==t.length)throw new Error("Input to hexToPublicKey must be of length 62");let e=!1;let n=0;let r;for(;!e;){if(n>=256)throw new Error("Something went wrong storing data");const o=n.toString(16).padStart(2,"0")+q(k(L(t).padStart(64,"0"),n));try{r=j.fromX(!1,o),e=!0}catch(t){n+=1}}if(!r)throw new Error("Something went wrong storing data");return new K(r)}function J(t){const e=t.point.getX().toString("hex").padStart(64,"0");const n=M(e.slice(0,2),16,10);return q((o=parseInt(n,10),(r=L(e.slice(2))).slice(-o)+r.slice(0,-o)));var r,o}function z(t,e){return`m/44'/${function(t,e){if("testnet"===e||"regtest"===e)return"1";if("BTC"===t)return"0";if("LTC"===t)return"2";if("DOGE"===t)return"3";if("BCH"===t)return"145";if("BSV"===t)return"236";throw new Error(`Unsupported chain ${t}`)}(t,e)}'/0'/0/0`}const{PublicKey:Y,Script:Z}=t.Bitcoin;function X(t){if(t.length>B.MAX_PUBKEYS_PER_SCRIPT)throw new Error("Too many owners");return function(t){const e=new Z;return e.add("OP_1"),t.forEach((t=>{e.add(t)})),e.add(`OP_${t.length}`),e.add("OP_CHECKMULTISIG"),e}(t.map((t=>t.toBuffer())))}function Q(t){return function(t){return t.chunks.filter((t=>t.buf)).map((t=>t.buf))}(t).map((t=>Y.fromBuffer(t)))}function V(t){const e=t.substr(0,4);const n=t.substr(5);if(!function(t,e){return function(t){return Buffer.from(d.default.SHA256(t).toString(),"hex").toString("hex").substr(0,4)}(t)===e}(n,e))throw new Error("Decryption failure");return n}const{Transaction:tt}=t.Bitcoin;const{Output:et}=tt;const{UnspentOutput:nt}=tt;let rt=class{constructor(t,e,n){const r=new tt(n);r.feePerKb(B.FEE_PER_KB),this.nodeConfig=t,this.tx=r,this.outData=[],this.privateKey=e}get txId(){return this.tx.id}get chain(){return this.nodeConfig.chain}get network(){return this.nodeConfig.network}get restClient(){return new D(this.nodeConfig,this.privateKey)}get inputs(){return this.tx.inputs.map((t=>`${t.prevTxId.toString("hex")}/${t.outputIndex}`))}get inRevs(){const{enc:t}=this;let[e]=t;return e=Number.isFinite(e)?e:0,this.tx.inputs.slice(0,e).map((({prevTxId:t,outputIndex:e})=>`${t.toString("hex")}/${e}`))}get outRevs(){const{enc:t}=this;let[,e]=t;return e=Number.isFinite(e)?e:0,Array.from(Array(e).keys()).map((t=>`${this.tx.id}/${t}`))}get opReturns(){try{const{outputs:t}=this.tx;return t.filter((({script:t})=>t.isDataOut())).map((({script:t})=>t.getData())).map((t=>t.toString())).join()}catch(t){return""}}get enc(){return H(this.opReturns.slice(0,B.ENCODING_LENGTH*B.ENCODING_NUMBER_LENGTH),B.ENCODING_NUMBER_LENGTH).map(G)}get dataPrefix(){return this.opReturns.slice(9)}getOwnerOutputs(){const{enc:t}=this;const[,e=0]=t;return this.tx.outputs.slice(0,e)}getDataOutputs(){const{enc:t}=this;const[,e,n]=t;return this.tx.outputs.slice(e,n)}getOutData(t){return w(this,void 0,void 0,(function*(){try{const e=this.getDataOutputs().map((t=>t.script)).map((t=>Q(t))).flat().map(J).map($).join("");const{dataPrefix:n}=this;const r=JSON.parse(n+e);const o=t.toBuffer().toString("hex");const s=this.getOwnerOutputs();if(s.length!==r.length)throw new Error("Inconsistent state");const i=s.map(((t,e)=>Object.assign(Object.assign({},r[e]),{_owners:Q(t.script).map((t=>t.toString())),_amount:t.satoshis})));return Promise.all(i.map((e=>w(this,void 0,void 0,(function*(){try{const n=yield function(t){return e=>w(this,void 0,void 0,(function*(){if(function(t){return void 0!==t._url}(e)){const{_url:n}=e,r=g(e,["_url"]);const{host:o,data:s}=yield D.getSecretOutput({_url:n,privateKey:t});return Object.assign(Object.assign(Object.assign({},r),JSON.parse(s)),{_url:o})}return e}))}(t)(e);return function(t,e){if(function(t){return void 0!==t.__cypher&&void 0!==t.__secrets}(t)){const{__cypher:n,__secrets:r}=t,o=g(t,["__cypher","__secrets"]);return Object.assign(Object.assign(Object.assign({},o),JSON.parse(function({__cypher:t,__secrets:e},n){let r="";if(n.forEach((n=>{e.forEach((e=>{try{const o=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid privateKey");return V(l.decrypt(e,Buffer.from(t,"base64")).toString("utf8"))}(e,n);r=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const n=Buffer.from(e,"hex").toString("binary");return V(d.default.AES.decrypt(t,n).toString(d.default.enc.Utf8))}(t,o)}catch(t){const e=["Decryption failure","Unsupported state or unable to authenticate data"];if(t instanceof Error&&!e.includes(t.message))throw t}}))})),r)return r;throw new Error("Decryption failure")}({__cypher:n,__secrets:r},e))),{_readers:[]})}return t}(n,[o])}catch(t){return null}})))))}catch(t){return[]}}))}getOwners(){return this.getOwnerOutputs().map((t=>Q(t.script).map((t=>t.toString()))))}getAmounts(){return this.getOwnerOutputs().map((t=>t.satoshis))}spendFromData(e){return w(this,void 0,void 0,(function*(){if(!e.length)return;const n=e.map(I);const r=n.map((t=>t.txId));const o=yield this.restClient.getTransactions(r);for(let e=0;e<n.length;e+=1){const{txId:r,outputIndex:s}=n[e];const{outputs:i}=o[e];const a=i[s];const c=Math.round(a.satoshis);const u=new t.Bitcoin.Script(a.script);const d=new nt({txId:r,outputIndex:s,satoshis:c,script:u});const l=Q(u).map((t=>t.toString()));this.tx.from([d],l,1)}}))}createOpReturnOut(t){this.tx.addData(JSON.stringify(t))}createDataOuts(e){e.forEach((({_amount:e,_owners:n=[]})=>{if(Array.isArray(n)&&n.length>B.MAX_PUBKEYS_PER_SCRIPT)throw new Error("Too many owners.");const r=n.map((e=>t.Bitcoin.PublicKey.fromString(e)));const o=e||B.MIN_NON_DUST_AMOUNT;const s=X(r);this.tx.addOutput(new et({script:s,satoshis:o}))}));const n=e.map((t=>g(t,["_amount","_owners"])));const r=B.MIN_NON_DUST_AMOUNT;const o=JSON.stringify(n);const s=B.OP_RETURN_SIZE-B.ENCODING_LENGTH*B.ENCODING_NUMBER_LENGTH;const i=o.slice(0,s);const a=function(t){var e;return function(t,e){const n=[];for(let r=0;r<t.length;r+=e)n.push(t.slice(r,r+e));return n}(H((e=t,Buffer.from(e).toString("hex")),62).map((t=>t.padStart(62,"0"))).map(W),B.MAX_PUBKEYS_PER_SCRIPT).map((t=>X(t)))}(o.slice(s));const c=F(this.tx.inputs.length)+F(this.tx.outputs.length)+F(this.tx.outputs.length+a.length);a.forEach((t=>{this.tx.addOutput(new et({script:t,satoshis:r}))})),this.tx.addData(c+i)}static fromTxHex(t,e,n){return w(this,void 0,void 0,(function*(){const r=new this(e,n);r.tx.fromString(t);const o=yield r.getOutData(n);const s=r.getOwners();const i=r.getAmounts();return r.outData=o.map(((t,e)=>Object.assign(Object.assign({},t),{_owners:s[e],_amount:i[e]}))),r}))}static fromTxId(t,e,n){return w(this,void 0,void 0,(function*(){const r=new D(e,n);const o=yield r.getRawTx(t);return this.fromTxHex(o,e,n)}))}};rt=v([t=>t],rt);class ot{constructor(t,e,n={}){const{chain:r,network:o}=e;const{path:s=z(r,o),passphrase:i=""}=n;let a=t.toHDPrivateKey(i,o);s&&(a=a.derive(s));const c=a.publicKey.toAddress(o);this.mnemonic=t,this.restClient=e,this.path=s,this.passphrase=i,this.hdPrivateKey=a,this.address=c}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get nodeConfig(){return this.restClient.nodeConfig}getMnemonic(){return this.mnemonic}derive(t="0"){const e=`${this.path}${this.path.length>0?"/":""}${t}`;return new ot(this.mnemonic,this.restClient,{path:e})}getPrivateKey(){return this.hdPrivateKey.privateKey}getPublicKey(){return this.hdPrivateKey.publicKey}getAddress(){return this.address}getBalance(){return w(this,void 0,void 0,(function*(){return this.restClient.getBalance(this.getAddress())}))}getUtxos(t=this.getAddress()){return w(this,void 0,void 0,(function*(){return this.restClient.getUtxosFromAddress(t)}))}selectUtxos(t,e){let n=0;const r=[];!function(t){const e=t;for(let t=e.length-1;t>0;t-=1){const n=Math.floor(Math.random()*(t+1));[e[t],e[n]]=[e[n],e[t]]}}(t);for(let o=0;o<t.length;o+=1){const s=t[o];if(n+=1e8*s.amount,r.push(s),n>=e)return r}const{network:o,chain:s}=this.restClient.nodeConfig;throw new Error(`Insufficient balance in address ${this.getAddress().toString()} on ${o} ${s}. Found ${n}, required ${e}.`)}fundAndSendTransaction(e){return w(this,void 0,void 0,(function*(){e.tx.feePerKb(B.FEE_PER_KB);const{chain:n,network:r}=this.nodeConfig;const o=e.tx._estimateFee()*function(t){if("LTC"===t)return 1;if("BTC"===t)return.01;if("DOGE"===t)return.3;if("BCH"===t)return 1;throw new Error(`Unsupported chain ${t}`)}(n);const s=.001*e.tx._getOutputAmount();const i=Math.max(B.MIN_NON_DUST_AMOUNT,o+s);e.tx.to(function(t,e){const n={"any-testnet":"gLjNGbKQzxqKA9bv2nhn1Ewf7rxYVXgrtR","BTC-mainnet":"84ZHRqRPTcUv6AFGMVC1KmSUeC9Y8SNfMm","LTC-mainnet":"mov5ivrsqWut5ffZhiz18uAkwy2D4y98iz","DOGE-mainnet":"1MVukPYmWdbEoxy3Sqq1ES4nYqDfpB5e68","BCH-mainnet":"P9CmJszhvARfQc8YjUW1K2oBnus1ZQWEqk","BSV-mainnet":"G2wxQ74zX48WMo7sfiX1faGGNQB8ebVth"};return k("testnet"===e||"regtest"===e?n["any-testnet"]:n[`${t}-${e}`],19)}(n,r),Math.round(i));let a=e.tx._getInputAmount();const c=e.tx._getOutputAmount();const u=e.tx._estimateFee();let d=c-a+Math.round(u);for(;d>0;){const n=yield this.getUtxos(this.getAddress());this.selectUtxos(n,d).forEach((n=>{e.tx.from([new t.Bitcoin.Transaction.UnspentOutput(n)])})),a=e.tx._getInputAmount(),d=c-a+Math.round(e.tx._estimateFee())}e.tx.change(this.getAddress()),e.tx.sign(this.getPrivateKey(),B.SIGHASH_ALL);const l=yield this.restClient.sendTransaction(e.tx.toString());return yield this.storeResult(l,e),l}))}storeResult(t,e){return w(this,void 0,void 0,(function*(){const{inputs:n,inRevs:r,outRevs:o}=e;const s=yield e.getOutData(this.getPrivateKey());const i=JSON.stringify(s);yield this.restClient.postNonStandardUtxo({outData:i,txId:t,inputs:n,inRevs:r,outRevs:o})}))}send(t,e){return w(this,void 0,void 0,(function*(){const n=new rt(this.restClient.nodeConfig,this.getPrivateKey());return n.tx.to(e,t),this.fundAndSendTransaction(n)}))}}var st=h.default;var at=p.default;var ct=f.default;function ut(t){"string"==typeof t&&(t=function(t){var e=ct.parse(t);var n=e.hostname;var r=parseInt(e.port,10);var o=e.protocol;o=o.substring(0,o.length-1);var s=e.auth.split(":");return{host:n,port:r,protocol:o,user:s[0]?decodeURIComponent(s[0]):null,pass:s[1]?decodeURIComponent(s[1]):null}}(t)),t=t||{},this.host=t.host||"127.0.0.1",this.port=t.port||8332,this.user=t.user||"user",this.pass=t.pass||"pass",this.protocol="http"===t.protocol?st:at,this.batchedCalls=null,this.disableAgent=t.disableAgent||!1;var e=void 0!==t.rejectUnauthorized;this.rejectUnauthorized=!e||t.rejectUnauthorized,ut.config.log?this.log=ut.config.log:this.log=ut.loggers[ut.config.logger||"normal"]}var dt=console.log.bind(console);var lt=function(){};function ht(t,e){var n=this;t=JSON.stringify(t);var r=this.user+":"+this.pass;var o=Buffer.from&&Buffer.from!==Uint8Array.from?Buffer.from(r):new Buffer(r);this.auth=o.toString("base64");var s={host:n.host,path:"/",method:"POST",port:n.port,rejectUnauthorized:n.rejectUnauthorized,agent:!n.disableAgent&&void 0};if(n.httpOptions)for(var i in n.httpOptions)s[i]=n.httpOptions[i];var a=!1;var c="Bitcoin JSON-RPC: ";var u=this.protocol.request(s,(function(t){var r="";t.on("data",(function(t){r+=t})),t.on("end",(function(){if(!a)if(a=!0,401!==t.statusCode)if(403!==t.statusCode){if(500===t.statusCode&&"Work queue depth exceeded"===r.toString("utf8")){var o=new Error("Bitcoin JSON-RPC: "+r.toString("utf8"));return o.code=429,void e(o)}var s;try{s=JSON.parse(r)}catch(o){n.log.err(o.stack),n.log.err(r),n.log.err("HTTP Status code:"+t.statusCode);var i=new Error(c+"Error Parsing JSON: "+o.message);return void e(i)}e(s.error,s)}else e(new Error(c+"Connection Rejected: 403 Forbidden"));else e(new Error(c+"Connection Rejected: 401 Unnauthorized"))}))}));u.on("error",(function(t){var n=new Error(c+"Request Error: "+t.message);a||(a=!0,e(n))})),u.setHeader("Content-Length",t.length),u.setHeader("Content-Type","application/json"),u.setHeader("Authorization","Basic "+n.auth),u.write(t),u.end()}ut.loggers={none:{info:lt,warn:lt,err:lt,debug:lt},normal:{info:dt,warn:dt,err:dt,debug:lt},debug:{info:dt,warn:dt,err:dt,debug:dt}},ut.config={logger:"normal"},ut.prototype.batch=function(t,e){this.batchedCalls=[],t(),ht.call(this,this.batchedCalls,e),this.batchedCalls=null},ut.callspec={abandonTransaction:"str",abortRescan:"",addMultiSigAddress:"",addNode:"",analyzePSBT:"str",backupWallet:"",bumpFee:"str",clearBanned:"",combinePSBT:"obj",combineRawTransaction:"obj",convertToPSBT:"str",createMultiSig:"",createPSBT:"obj",createRawTransaction:"obj obj",createWallet:"str",decodePSBT:"str",decodeScript:"str",decodeRawTransaction:"",deriveAddresses:"str",disconnectNode:"",dumpPrivKey:"",dumpWallet:"str",encryptWallet:"",enumerateSigners:"",estimateFee:"",estimateSmartFee:"int str",estimatePriority:"int",generate:"int",generateBlock:"str obj",generateToAddress:"int str",generateToDescriptor:"int str",getAccount:"",getAccountAddress:"str",getAddedNodeInfo:"",getAddressMempool:"obj",getAddressUtxos:"obj",getAddressBalance:"obj",getAddressDeltas:"obj",getAddressesByLabel:"str",getAddressInfo:"str",getAddressTxids:"obj",getAddressesByAccount:"",getBalance:"str int",getBalances:"",getBestBlockHash:"",getBlockDeltas:"str",getBlock:"str int",getBlockchainInfo:"",getBlockCount:"",getBlockFilter:"str",getBlockHashes:"int int obj",getBlockHash:"int",getBlockHeader:"str",getBlockNumber:"",getBlockStats:"str",getBlockTemplate:"",getConnectionCount:"",getChainTips:"",getChainTxStats:"",getDescriptorInfo:"str",getDifficulty:"",getGenerate:"",getHashesPerSec:"",getIndexInfo:"",getInfo:"",getMemoryInfo:"",getMemoryPool:"",getMemPoolAncestors:"str",getMemPoolDescendants:"str",getMemPoolEntry:"str",getMemPoolInfo:"",getMiningInfo:"",getNetTotals:"",getNetworkHashPS:"",getNetworkInfo:"",getNewAddress:"str str",getNodeAddresses:"",getPeerInfo:"",getRawChangeAddress:"",getRawMemPool:"bool",getRawTransaction:"str int",getReceivedByAccount:"str int",getReceivedByAddress:"str int",getReceivedByLabel:"str",getRpcInfo:"",getSpentInfo:"obj",getTransaction:"",getTxOut:"str int bool",getTxOutProof:"",getTxOutSetInfo:"",getUnconfirmedBalance:"",getWalletInfo:"",getWork:"",getZmqNotifications:"",finalizePSBT:"str",fundRawTransaction:"str",help:"",importAddress:"str str bool",importDescriptors:"str",importMulti:"obj obj",importPrivKey:"str str bool",importPrunedFunds:"str, str",importPubKey:"str",importWallet:"str",invalidateBlock:"str",joinPSBTs:"obj",keyPoolRefill:"",listAccounts:"int",listAddressGroupings:"",listBanned:"",listDescriptors:"",listLabels:"",listLockUnspent:"bool",listReceivedByAccount:"int bool",listReceivedByAddress:"int bool",listReceivedByLabel:"",listSinceBlock:"str int",listTransactions:"str int int",listUnspent:"int int",listWalletDir:"",listWallets:"",loadWallet:"str",lockUnspent:"",logging:"",move:"str str float int str",ping:"",preciousBlock:"str",prioritiseTransaction:"str float int",pruneBlockChain:"int",psbtBumpFee:"str",removePrunedFunds:"str",reScanBlockChain:"",saveMemPool:"",send:"obj",setHDSeed:"",setLabel:"str str",setWalletFlag:"str",scanTxOutSet:"str",sendFrom:"str str float int str str",sendMany:"str obj int str",sendRawTransaction:"str",sendToAddress:"str float str str",setAccount:"",setBan:"str str",setNetworkActive:"bool",setGenerate:"bool int",setTxFee:"float",signMessage:"",signMessageWithPrivKey:"str str",signRawTransaction:"",signRawTransactionWithKey:"str obj",signRawTransactionWithWallet:"str",stop:"",submitBlock:"str",submitHeader:"str",testMemPoolAccept:"obj",unloadWallet:"",upgradeWallet:"",uptime:"",utxoUpdatePSBT:"str",validateAddress:"",verifyChain:"",verifyMessage:"",verifyTxOutProof:"str",walletCreateFundedPSBT:"",walletDisplayAddress:"str",walletLock:"",walletPassPhrase:"string int",walletPassphraseChange:"",walletProcessPSBT:"str"};var pt=function(t,e,n){return Array.prototype.slice.call(t,e,n)};function ft(){return parseInt(1e5*Math.random())}!function(t,e,n){function r(t,e){return function(){var r=arguments.length-1;this.batchedCalls&&(r=arguments.length);for(var o=0;o<r;o++)e[o]&&(arguments[o]=e[o](arguments[o]));this.batchedCalls?this.batchedCalls.push({jsonrpc:"2.0",method:t,params:pt(arguments),id:ft()}):n.call(this,{method:t,params:pt(arguments,0,arguments.length-1),id:ft()},arguments[arguments.length-1])}}var o={str:function(t){return t.toString()},int:function(t){return parseFloat(t)},float:function(t){return parseFloat(t)},bool:function(t){return!0===t||"1"==t||"true"==t||"true"==t.toString().toLowerCase()},obj:function(t){return"string"==typeof t?JSON.parse(t):t}};for(var s in e){var i=[];if(e[s].length){i=e[s].split(" ");for(var a=0;a<i.length;a++)o[i[a]]?i[a]=o[i[a]]:i[a]=o.str}var c=s.toLowerCase();t.prototype[s]=r(c,i),t.prototype[c]=t.prototype[s]}}(ut,ut.callspec,ht);const gt=["travel upgrade inside soda birth essence junk merit never twenty system opinion","hover harsh text dice wealth pill across trade soccer olive view acquire","damp comfort scan couple absurd enter slogan cheap ketchup print syrup hurdle one document diamond","notable rose silver indicate wreck mean raise together jar fish seat air","lens release coil rain forward lemon cube satisfy inject visa ring segment"];const{CHAIN:vt="LTC",NETWORK:wt="regtest",RPC_USER:mt,RPC_PASSWORD:yt,RPC_HOST:xt}=process.env;const bt="LTC"===process.env.CHAIN?19332:8332;var St=Object.assign(Object.assign({},B),{CHAIN:vt,NETWORK:wt,BCN_URL:"http://127.0.0.1:3000",RPC_PROTOCOL:"http",RPC_USER:mt,RPC_PASSWORD:yt,RPC_HOST:xt,RPC_PORT:bt,TEST_ADDRESSES:"moMoH1vTgCc2dkDfGSKYPnafxy22wSqgrr;mmQEk8VwtSehRryLF8jhVapYg553hJGhNa;miKQVhZbFKSsJcQZ8eXwBQ89xNyetpN34q;mzoGRNh55y9j57TPdwRGi3nt9X4CFwpqUS;n1X6JFDyxibtdhYrc7mrkuft6o168ELFNW;mjLcig6eTZVJkgRgJFMkwrYHpfMnZ1t4kk;mfYkMQAe7afeRSkgLxAtwnMVryjLTfr95Q"});class Bt extends class{constructor(t,e){this.chain=t,this.network=e}}{constructor(t,e,n){super(t,e),this.url=n}}const{PrivateKey:Tt,Opcode:Et,Script:Ot,Mnemonic:Nt,crypto:_t,Transaction:Ct,encoding:Pt}=t.Bitcoin;function At(t=0){return new Nt(gt[t])}new Bt(St.CHAIN,St.NETWORK,St.BCN_URL);const Rt=new Bt(St.CHAIN,St.NETWORK,St.BCN_URL);const It=At(0);const Dt=new D(Rt,((t,e,n={})=>{const{path:r,passphrase:o}=n;let s=t.toHDPrivateKey(o,e);return r&&(s=s.derive(r)),s.privateKey})(It,Rt.network));const{Mnemonic:Kt}=t.Bitcoin;describe("Wallet",(()=>{describe("constructor",(()=>{it("Should initialize",(()=>{const t=new ot(new Kt,new D(Rt));expect(t).toBeDefined(),expect(t.chain).toBe(St.CHAIN),expect(t.network).toBe(St.NETWORK),expect(t.hdPrivateKey).toBeDefined(),expect(t.address).toBeDefined(),expect(t.path).toEqual("m/44'/0'/0'/0"),expect(t.mnemonic).toBeDefined(),expect(t.restClient).toBeDefined(),expect(t.restClient.chain).toBe(St.CHAIN)})),it("Should initialize with custom path",(()=>{const t=new ot(new Kt,new D(Rt),{path:"m/0"});expect(t).toBeDefined(),expect(t.chain).toBe(St.CHAIN),expect(t.network).toBe(St.NETWORK),expect(t.hdPrivateKey).toBeDefined(),expect(t.address).toBeDefined(),expect(t.path).toEqual("m/0"),expect(t.mnemonic).toBeDefined(),expect(t.restClient).toBeDefined(),expect(t.restClient.chain).toBe(St.CHAIN)}))})),describe("Passphrase",(()=>{it("Different passphrase should result in different key",(()=>{const t=new ot(new Kt,new D(Rt),{passphrase:""});const e=new ot(new Kt,new D(Rt),{passphrase:"super secret passphrase"});expect(t.hdPrivateKey).toBeDefined(),expect(t.path).toEqual("m/44'/0'/0'/0"),expect(e.hdPrivateKey).toBeDefined(),expect(e.path).toEqual("m/44'/0'/0'/0"),expect(e.getPrivateKey()).not.toEqual(t.getPrivateKey()),expect(e.getPublicKey()).not.toEqual(t.getPublicKey()),expect(e.getAddress()).not.toEqual(t.getAddress())}))})),describe("derive",(()=>{it("Should return a child wallet",(()=>{const t=new ot(new Kt,new D(Rt));const e=t.derive();expect(e).toBeDefined(),expect(e.hdPrivateKey).toBeDefined(),expect(e.address).toBeDefined(),expect(e.path).toEqual("m/44'/0'/0'/0/0"),expect(e.mnemonic).toEqual(t.mnemonic)})),it("Should return a child wallet for a given index",(()=>{const t=new ot(new Kt,new D(Rt));const e=t.derive("1");expect(e).toBeDefined(),expect(e.hdPrivateKey).toBeDefined(),expect(e.address).toBeDefined(),expect(e.path).toEqual("m/44'/0'/0'/0/1"),expect(e.mnemonic).toEqual(t.mnemonic)})),it("Should return different child wallets for different indices",(()=>{const t=new ot(new Kt,new D(Rt));const e=t.derive();const n=t.derive("1");expect(e).not.toEqual(n)})),it("should work when deriving a grandchild wallet",(()=>{const t=new ot(new Kt,new D(Rt));const e=t.derive("1");const n=e.derive("5");expect(e.mnemonic).toEqual(t.mnemonic),expect(n.mnemonic).toEqual(e.mnemonic),expect(n.path).toEqual("m/44'/0'/0'/0/1/5")})),it("should derive from a specific wallet wallet",(()=>{const t=new Kt("motion shoulder road awful wedding bacon legal skill mesh pledge polar pulse");const e=new ot(t,new D(Rt),{path:""}).derive("m").derive("44'").derive("145'").derive("0").derive("0").derive("1'");expect(e.path).toBe("m/44'/145'/0/0/1'");const n=e.getAddress();expect(n).toBeDefined()}))})),describe("getPrivateKey",(()=>{it("Should return the private key",(()=>{const t=new ot(new Kt,new D(Rt)).getPrivateKey();expect(t).toBeDefined(),expect(t.constructor.name).toBe("PrivateKey")}))})),describe("getPublicKey",(()=>{it("Should return the public key",(()=>{const t=new ot(new Kt,new D(Rt)).getPublicKey();expect(t).toBeDefined(),expect(t.constructor.name).toBe("PublicKey")}))})),describe("getAddress",(()=>{it("Should return and store the address on livenet",(()=>{const t=new ot(new Kt,new D(new Bt(St.CHAIN,"livenet",St.BCN_URL)));const e=t.getAddress();expect(e).toBeDefined(),expect(t.address).toBeDefined(),expect(e.constructor.name).toBe("Address")})),it("Should return and store the address on testnet",(()=>{const t=new ot(new Kt,new D(new Bt(St.CHAIN,"testnet",St.BCN_URL)));const e=t.getAddress();expect(e).toBeDefined(),expect(t.address).toBeDefined(),expect(e.constructor.name).toBe("Address")})),it("Should return and store the address in different formats",(()=>{const t=new ot(new Kt,new D(Rt)).getAddress();const e=t.toString("legacy");const n=t.toString("bitpay");expect(e).toBeDefined(),expect(n).toBeDefined()}))})),describe("getBalance",(()=>{it("should return the balance of the test keys",(()=>w(void 0,void 0,void 0,(function*(){const t=new ot(At(0),new D(Rt));expect(yield t.getBalance()).toBeGreaterThan(0);const e=new ot(At(1),new D(Rt));expect(yield e.getBalance()).toBeGreaterThan(0);const n=new ot(At(2),new D(Rt));expect(yield n.getBalance()).toBeGreaterThan(0);const r=new ot(At(3),new D(Rt));expect(yield r.getBalance()).toBeGreaterThan(0);const o=new ot(At(4),new D(Rt));expect(yield o.getBalance()).toBeGreaterThan(0)}))),2e4),it("should return the balance ",(()=>w(void 0,void 0,void 0,(function*(){const t=new ot(new Kt,new D(Rt));const e=yield t.getBalance();expect(e).toBeDefined(),expect(e).toBe(Math.round(e)),e>0&&expect(e).toBeGreaterThan(1),expect(typeof e).toBe("number")}))),2e4)})),describe("fundAndSendTransaction",(()=>{it("Should build and broadcast a transaction with pubkey hash output",(()=>w(void 0,void 0,void 0,(function*(){const t=new ot(It,Dt);const e=t.getAddress();const n=new rt(Rt,t.getPrivateKey());n.tx.to(e,1e4),n.tx.to(e,St.MIN_NON_DUST_AMOUNT);const r=yield t.getUtxos();const o=yield t.fundAndSendTransaction(n);const s=yield t.getUtxos();expect(o).toBeDefined(),expect(Array.isArray(n.tx.inputs)).toBe(!0),expect(n.tx.inputs.length).toBeGreaterThan(0),expect(Array.isArray(n.tx.outputs)).toBe(!0),expect(n.tx.outputs.length).toBe(4),expect(n).toBeDefined(),n.tx.inputs.forEach((t=>{expect(r.find((e=>e.txid===t.prevTxId.toString("hex")&&e.vout===t.outputIndex))).toBeDefined()})),n.tx.inputs.forEach((t=>{expect(s.find((e=>e.txid===t.prevTxId.toString("hex")&&e.vout===t.outputIndex))).toBeUndefined()}))}))),2e4)})),describe("send",(()=>{it("Should send a transaction with pubkey hash output",(()=>w(void 0,void 0,void 0,(function*(){const t=new ot(It,Dt);const e=t.getAddress();const n=St.MIN_NON_DUST_AMOUNT;const r=yield t.send(n,e.toString());expect(r).toBeDefined()})))),it("Should display the correct error message if the wallet is empty",(()=>w(void 0,void 0,void 0,(function*(){const t=new ot(new Kt,Dt);const e=t.getAddress();const n=St.MIN_NON_DUST_AMOUNT;yield expect(t.send(n,e.toString())).rejects.toThrow(new RegExp(String.raw`Insufficient balance in address ${e.toString()} on ${St.NETWORK} ${St.CHAIN}. Found 0, required`))}))))}))}));
