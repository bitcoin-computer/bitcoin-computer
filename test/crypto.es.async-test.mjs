import e from"tweetnacl";import t from"eccrypto";import{Bitcoin as n}from"bitcoin-computer-bitcore";import{expect as o}from"chai";import i from"tweetnacl-util";function r(e,t,n,o){return new(n||(n=Promise))((function(i,r){function c(e){try{u(o.next(e))}catch(e){r(e)}}function s(e){try{u(o.throw(e))}catch(e){r(e)}}function u(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(c,s)}u((o=o.apply(e,t||[])).next())}))}const{PublicKey:c}=n;function s({iv:e,ephemPublicKey:t,ciphertext:n,mac:o}){return{iv:e,publicKey:t,cipherText:n,mac:o}}function u(n,o){return r(this,void 0,void 0,(function*(){const u=e.randomBytes(32);const f=e.randomBytes(24);const a=e.secretbox(i.decodeUTF8(n),f,u);const l=Buffer.concat([Buffer.from(f),Buffer.from(u)]);const p=o.map((e=>r(this,void 0,void 0,(function*(){return s(yield t.encrypt(c.fromString(e).toBuffer(),l))}))));return{cipherText:a,envelopes:yield Promise.all(p)}}))}function f(n,o,c){return r(this,void 0,void 0,(function*(){let r;try{r=yield t.decrypt(c.toBuffer(),function({iv:e,publicKey:t,cipherText:n,mac:o}){return{iv:e,ephemPublicKey:t,ciphertext:n,mac:o}}(o))}catch(e){throw new Error("Decryption failed.")}const s=r.subarray(0,e.secretbox.nonceLength);const u=r.subarray(e.secretbox.nonceLength);const f=e.secretbox.open(n.cipherText,new Uint8Array(s),new Uint8Array(u));if(null===f)throw new Error("Decryption failed.");return i.encodeUTF8(f)}))}const{PrivateKey:a}=n;describe("Crypto",(()=>{describe("encrypt() and decrypt()",(()=>{it("encrypts a message",(()=>r(void 0,void 0,void 0,(function*(){const e=new a;const t=new a;const n=yield u("42",[e.toPublicKey().toString(),t.toPublicKey().toString()]);o(n.cipherText).to.not.be.undefined,o(n.cipherText).to.be.instanceof(Uint8Array),o(n.envelopes).to.not.be.undefined,o(n.envelopes.length).eq(2),o(n.envelopes[0].cipherText).to.not.be.undefined,o(n.envelopes[0].cipherText).to.be.instanceof(Buffer),o(n.envelopes[0].iv).to.not.be.undefined,o(n.envelopes[0].iv).to.be.instanceof(Buffer),o(n.envelopes[0].mac).to.not.be.undefined,o(n.envelopes[0].mac).to.be.instanceof(Buffer),o(n.envelopes[0].publicKey).to.not.be.undefined,o(n.envelopes[0].publicKey).to.be.instanceof(Buffer),o(n.envelopes[1].cipherText).to.not.be.undefined,o(n.envelopes[1].cipherText).to.be.instanceof(Buffer),o(n.envelopes[1].iv).to.not.be.undefined,o(n.envelopes[1].iv).to.be.instanceof(Buffer),o(n.envelopes[1].mac).to.not.be.undefined,o(n.envelopes[1].mac).to.be.instanceof(Buffer),o(n.envelopes[1].publicKey).to.not.be.undefined,o(n.envelopes[1].publicKey).to.be.instanceof(Buffer)})))),it("decrypts a message with other's key",(()=>r(void 0,void 0,void 0,(function*(){const e=new a;const t=new a;const n=yield u("some super secret message",[e.toPublicKey().toString(),t.toPublicKey().toString()]);const i=yield f(n,n.envelopes[1],t);o(i).eq("some super secret message")})))),it("decrypts a message with my key",(()=>r(void 0,void 0,void 0,(function*(){const e=new a;const t=new a;const n=yield u("some super secret message",[e.toPublicKey().toString(),t.toPublicKey().toString()]);const i=yield f(n,n.envelopes[0],e);o(i).eq("some super secret message")})))),it("throws when using a wrong secret key",(()=>r(void 0,void 0,void 0,(function*(){const e=new a;const t=new a;const n=yield u("some super secret message",[e.toPublicKey().toString(),t.toPublicKey().toString()]);f(n,n.envelopes[1],e).then((()=>{o.fail("Did not throw an error.")})).catch((e=>{o(e).to.be.instanceof(Error),o(e.message).eq("Decryption failed.")}))})))),it("throws when decrypting a wrong cipher text",(()=>r(void 0,void 0,void 0,(function*(){const e=new a;const t=new a;const n=yield u("some super secret message",[e.toPublicKey().toString(),t.toPublicKey().toString()]);f({cipherText:new Uint8Array(16),envelopes:[]},n.envelopes[1],e).then((()=>{o.fail("Did not throw an error.")})).catch((e=>{o(e).to.be.instanceof(Error),o(e.message).eq("Decryption failed.")}))})))),it("throws when using a wrong symmetric key",(()=>r(void 0,void 0,void 0,(function*(){const n=new a;const i=new a;f(yield u("some super secret message",[n.toPublicKey().toString(),i.toPublicKey().toString()]),s(yield t.encrypt(i.toPublicKey().toBuffer(),Buffer.alloc(e.secretbox.nonceLength+e.secretbox.keyLength))),i).then((()=>{o.fail("Did not throw an error.")})).catch((e=>{o(e).to.be.instanceof(Error),o(e.message).eq("Decryption failed.")}))}))))}))}));
