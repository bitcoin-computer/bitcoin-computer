"use strict";var t=require("bitcoin-computer-bitcore");require("ses");var e=require("axios");var o=require("crypto");var n=require("crypto-js");var r=require("eciesjs");var i=require("http");var c=require("https");var s=require("url");var a=require("util");function d(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}function u(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(o){if("default"!==o){var n=Object.getOwnPropertyDescriptor(t,o);Object.defineProperty(e,o,n.get?n:{enumerable:!0,get:function(){return t[o]}})}})),e.default=t,Object.freeze(e)}var l=d(e);var _=d(o);var p=d(n);var v=u(r);var h=d(i);var g=d(c);var f=d(s);var y=d(a);function x(t,e){var o={};for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&e.indexOf(n)<0&&(o[n]=t[n]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(n=Object.getOwnPropertySymbols(t);r<n.length;r++)e.indexOf(n[r])<0&&Object.prototype.propertyIsEnumerable.call(t,n[r])&&(o[n[r]]=t[n[r]])}return o}function S(t,e,o,n){var r,i=arguments.length,c=i<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,o):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)c=Reflect.decorate(t,e,o,n);else for(var s=t.length-1;s>=0;s--)(r=t[s])&&(c=(i<3?r(c):i>3?r(e,o,c):r(e,o))||c);return i>3&&c&&Object.defineProperty(e,o,c),c}function w(t,e,o,n){return new(o||(o=Promise))((function(r,i){function c(t){try{a(n.next(t))}catch(t){i(t)}}function s(t){try{a(n.throw(t))}catch(t){i(t)}}function a(t){var e;t.done?r(t.value):(e=t.value,e instanceof o?e:new o((function(t){t(e)}))).then(c,s)}a((n=n.apply(t,e||[])).next())}))}const b=t=>new Compartment({}).evaluate(t);const m=(t,e,o)=>new Compartment({target:t,thisArgument:e,argumentsList:o}).evaluate("Reflect.apply(target, thisArgument, argumentsList)");const E=(t,e)=>new Compartment({target:t,argumentsList:e}).evaluate(`Reflect.construct(${t}, argumentsList)`);const{crypto:O}=t.Bitcoin;const N=(t,e)=>{const o=Date.now();const n=O.Hash.sha256(Buffer.from(e+o));const r=[O.ECDSA.sign(n,t,"big").toString("hex"),t.publicKey.toString(),o];return`Bearer ${Buffer.from(r.join(":")).toString("base64")}`};const{Transaction:B}=t.Bitcoin;function j(t){return w(this,void 0,void 0,(function*(){if(!function(t){return void 0!==t.config}(t))throw new Error("Unknown error");const{message:e,config:o,response:n}=t;const r=function(t){try{const e=JSON.parse(t);if("object"!=typeof e)throw new Error("Invalid object");if("string"!=typeof e.txhex)throw new Error("Invalid object");return new B(e.txhex)}catch(t){return null}}(null==o?void 0:o.data);const i=`message\t${e}`;const c=`request\t${null==o?void 0:o.method} ${null==o?void 0:o.url}`;const s=r?`transaction\t ${JSON.stringify(r.toJSON(),null,2)}`:"";const a="post"===(null==o?void 0:o.method)?`data\t${null==o?void 0:o.data}`:"";const d=n?`response\t${JSON.stringify(n.data)}`:"";const u=r?s:a;throw t.message=`\n    Communication Error\n    ${i}\n    ${c}\n    ${u}\n    ${d}`,t}))}class T{constructor(t,e,o={}){this.baseUrl=t,this.headers=o,this.privateKey=e}get(t){return w(this,void 0,void 0,(function*(){const e=`${this.baseUrl}${t}`;try{let t={};return this.privateKey&&(t={Authentication:N(this.privateKey,this.baseUrl)}),(yield l.default.get(e,{headers:Object.assign(Object.assign({},this.headers),t)})).data}catch(t){return j(t)}}))}post(t,e){return w(this,void 0,void 0,(function*(){const o=`${this.baseUrl}${t}`;try{let t={};return this.privateKey&&(t={Authentication:N(this.privateKey,this.baseUrl)}),(yield l.default.post(o,e,{headers:Object.assign(Object.assign({},this.headers),t)})).data}catch(t){return j(t)}}))}delete(t){return w(this,void 0,void 0,(function*(){const e=`${this.baseUrl}${t}`;try{let t={};return this.privateKey&&(t={Authentication:N(this.privateKey,this.baseUrl)}),(yield l.default.delete(e,{headers:Object.assign(Object.assign({},this.headers),t)})).data}catch(t){return j(t)}}))}}const{PrivateKey:R,Transaction:I}=t.Bitcoin;function A(t){if(!/^[0-9A-Fa-f]{64}$/.test(t))throw new Error(`Invalid txId: ${t}`)}function U(t){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(t))throw new Error(`Invalid outId: ${t}`)}function C(t){U(t);const[e,o]=t.split("/");return{txId:e,outputIndex:parseInt(o,10)}}let q=class{constructor(t,e=new R){this.nodeConfig=t,this.bcn=new T(t.url,e)}get chain(){return this.nodeConfig.chain}get network(){return this.nodeConfig.network}getBalance(t){return w(this,void 0,void 0,(function*(){const{chain:e,network:o}=this;return yield this.bcn.get(`/v1/${e}/${o}/address/${t}/balance`)}))}getTransaction(t){return w(this,void 0,void 0,(function*(){return new I(yield this.getRawTx(t))}))}getRawTx(t){return w(this,void 0,void 0,(function*(){A(t);const{chain:e,network:o}=this;return this.bcn.get(`/v1/${e}/${o}/tx/${t}`)}))}getRawTxData(t){return w(this,void 0,void 0,(function*(){A(t);const{chain:e,network:o}=this;return this.bcn.get(`/v1/${e}/${o}/tx-data/${t}`)}))}getTransactions(t){return w(this,void 0,void 0,(function*(){return(yield this.getRawTxs(t)).map((t=>new I(t)))}))}getRawTxs(t){return w(this,void 0,void 0,(function*(){t.map(A);const{chain:e,network:o}=this;return this.bcn.post(`/v1/${e}/${o}/tx/bulk/`,{txIds:t})}))}sendTransaction(t){return w(this,void 0,void 0,(function*(){return this.bcn.post(`/v1/${this.chain}/${this.network}/tx/send`,{rawTx:t})}))}getUtxosFromAddress(t){return w(this,void 0,void 0,(function*(){const{chain:e,network:o}=this;return this.bcn.get(`/v1/${e}/${o}/wallet/${t.toString()}/utxos`)}))}postNonStandardUtxo(t){return w(this,void 0,void 0,(function*(){const{chain:e,network:o}=this;return this.bcn.post(`/v1/${e}/${o}/non-standard-utxo`,t)}))}getOwnedRevs(t){return w(this,void 0,void 0,(function*(){const{chain:e,network:o}=this;return this.bcn.get(`/v1/${e}/${o}/wallet/${t.toString()}/non-standard-utxos`)}))}queryRevs(t){return w(this,void 0,void 0,(function*(){const{publicKey:e,contractName:o,contractHash:n}=t;if(void 0===e&&void 0===o&&void 0===n)throw new Error("Filter parameter for queryRevs endpoint cannot be empty.");let r="";e&&(r+=`?publicKey=${e}`),o&&(r+=0===r.length?"?":"&",r+=`contractName=${o}`),n&&(r+=0===r.length?"?":"&",r+=`contractHash=${n}`);const{chain:i,network:c}=this;return this.bcn.get(`/v1/${i}/${c}/non-standard-utxos${r}`)}))}getLatestRev(t){return w(this,void 0,void 0,(function*(){U(t);const{chain:e,network:o}=this;const[{rev:n}]=yield this.bcn.get(`/v1/${e}/${o}/rev/${t}`);return n}))}getLatestRevs(t){return w(this,void 0,void 0,(function*(){t.map(U),t.map(U);const{chain:e,network:o}=this;return yield this.bcn.post(`/v1/${e}/${o}/revs`,{ids:t})}))}static getSecretOutput({_url:t,privateKey:e}){return w(this,void 0,void 0,(function*(){const o=t.split("/");const n=o[o.length-1];const r=o.slice(0,-2).join("/");const i=new T(r,e);return{host:r,data:yield i.get(`/v1/store/${n}`)}}))}static setSecretOutput({secretOutput:t,host:e,privateKey:o}){return w(this,void 0,void 0,(function*(){return new T(e,o).post("/v1/store/",t)}))}static deleteSecretOutput({_url:t,privateKey:e}){return w(this,void 0,void 0,(function*(){const o=t.split("/");const n=o[o.length-1];const r=o.slice(0,-2).join("/");const i=new T(r,e);yield i.delete(`/v1/store/${n}`)}))}};q=S([t=>t],q);const P=["_id","_rev","_owners","_amount","_readers","_url","__vouts","__func","__index","__args"];const M=t=>(Object.prototype.toString.call(t).match(/\s([a-zA-Z]+)/)||[])[1];const k=t=>"object"==typeof t?M(t):M(t).toLowerCase();const $=t=>["number","string","boolean","undefined","Null"].includes(k(t));const D=t=>"Array"===k(t);const L=t=>"Object"===k(t);const K=t=>$(t)||["Array","Object"].includes(k(t));const H=(t,e)=>{if(!K(t)||!K(e))throw new Error(`Unsupported data types for deep equals: ${k(t)} & ${k(e)}`);if(k(t)!==k(e))return!1;if($(t)&&$(e))return t===e;const o=(t,e)=>Object.entries(t).every((([t,o])=>H(e[t],o)));return t&&e&&o(t,e)&&o(e,t)};const W=t=>{if($(t))return t;if(D(t))return t.map(W);if(L(t)){const e=Object.keys(t).reduce(((e,o)=>(e[o]=W(t[o]),e)),{});const o=Object.create(Object.getPrototypeOf(t));return Object.assign(o,e)}throw new Error(`Unsupported data type for clone: ${k(t)}`)};const F=(t,e)=>Object.fromEntries(Object.entries(t).map((t=>e(t))));const G=(t,e)=>F(t,(([t,o])=>[t,e(o)]));const J=(t,e)=>Object.fromEntries(Object.entries(t).filter((t=>e(t))));const z=(t,e,o,n)=>{if($(t))return t;if(D(t))return t.map((t=>z(t,e,o,n)));if(L(t)){t._rev=`${n}/${o}`;const r=e[o];return Object.entries(t).forEach((([o,i])=>{"object"==typeof r&&Object.keys(r).includes(o)&&(t[o]=z(i,e,r[o],n))})),t}throw new Error(`Unsupported type ${k(t)} in deep.updateRev`)};const Y=(t,e)=>{if($(t))return t;if(D(t))return t.map((t=>Y(t,e)));if(L(t))return t._id=!t._id||t._id.startsWith("__temp__")?t._rev:t._id,t._root=t._root||e,Object.entries(t).forEach((([o,n])=>{t[o]=Y(n,e)})),t;throw new Error(`Unsupported type ${k(t)} in deep.addId`)};const Z=t=>{if($(t))return t;if(D(t))return t.map((t=>Z(t)));if(L(t)){const e=`__temp__/${Math.random()}`;return t._id=t._id||e,t._rev=t._rev||e,Object.values(t).map((t=>Z(t))),t}throw new Error(`Unsupported type ${k(t)} in addRandomId`)};const V=t=>{if($(t))return t;if(D(t))return t.map((t=>V(t)));if(L(t))return F(t,(([t,e])=>["_owners","_readers"].includes(t)?[t,JSON.stringify(e)]:$(e)?[t,e]:[t,V(e)]));throw new Error(`Unexpected type ${k(t)} in stringifyOwners`)};const X=t=>(t._owners&&(t._owners=JSON.parse(t._owners)),t._readers&&(t._readers=JSON.parse(t._readers)),t);const Q=t=>{if($(t))return t;if(D(t)||L(t))return Object.entries(t).reduce(((t,[e,o])=>{const n=Q(o);return(t=>"Object"===k(t)&&Object.keys(t).every((t=>!Number.isNaN(parseInt(t,10)))))(n)?Object.entries(n).forEach((([o,n])=>{t[`${e}_${o}`]=n})):t[e]=n,t}),{});throw new Error(`Unsupported type ${k(t)} in encodeArraysAsObjects`)};const tt=t=>{const e={[t._id]:Object.entries(t).reduce(((t,[e,o])=>P.includes(e)?Object.assign(Object.assign({},t),{[e]:o}):$(o)?Object.assign(Object.assign({},t),{[`__basic__${e}`]:o}):Object.assign(Object.assign({},t),{[e]:o._id})),{})};return Object.values(t).filter((t=>!$(t))).reduce(((t,e)=>Object.assign(Object.assign({},t),tt(e))),e)};const et=t=>J(t,(([t])=>!t.startsWith("__basic__")));const ot=(t,e)=>{const o=t[e];return o.__contains=Object.entries(o).reduce(((e,[o,n])=>["__contains",...P].includes(o)?e:"__change"===o?"new"===n||"diff"===n||e:ot(t,n)[n].__contains||e),!1),t};const nt=(t,e)=>t.map((t=>Object.entries(t).reduce(((t,[o,n])=>{const r="string"==typeof n&&"undefined"!==k(e[n])?e[n]:n;return Object.assign(Object.assign({},t),{[o]:r})}),{})));class rt{constructor(t){this.db=t}get(t){return w(this,void 0,void 0,(function*(){const{txId:e,outputIndex:o}=C(t);const{inRevs:n,outData:r}=yield this.db.fromTxId(e);if(!Array.isArray(n)||!Array.isArray(r)||0===r.length)return;const i=r[0].__index||{};const c=r[i.obj].__cls||"";const s=r[i.obj].__func||"";const a=r[i.obj].__args||[];const d=yield Promise.all(Object.values(i).map((t=>{const e=n[t];return e?this.get(e):Promise.resolve({})})));const u=Object.keys(i).map(((t,e)=>[t,d[e]]));const l=Object.fromEntries(u);let _=l.obj;delete l.obj;const p=Object.entries(l).reduce(((t,[e,o])=>{const n=parseInt(e,10);return Number.isNaN(n)||(t[n]=o),t}),[]);const v=function(t,e){let o=0;return e.map((e=>"__"===e?t[o++]:e))}(p,a);let h;if("constructor"===s){const t=b(`(${c})`);_=E(t,v)}else h=m(_[s].bind(_),_,v);Object.entries(i).forEach((([t,o])=>{const n=parseInt(t,10);let i=p[n];"obj"===t?i=_:"res"===t&&(i=h),z(i,r,o,e)}));const g=_._root||`${e}/${i.obj}`;return Y([h,_,...p],g),[...p,_,h][o]}))}}function ct(t){return{smartArgs:t.filter((t=>t._rev)),dumbArgs:t.map((t=>t._rev?"__":t))}}class st{constructor(t){this.db=t,st.proxyDepth=st.proxyDepth||0}static getUpdate(t){return w(this,void 0,void 0,(function*(){let e;let o;let n;let r;let i;let c;let s;if("Cls"in t){const{Cls:a}=t;const d=t.args||[];e=a.toString(),o=null,n=E(a,d),r=W(d),i=d,c=null,s=void 0}else{const{target:a,property:d,args:u}=t;e=null,o=W(a),n=a,r=W(u),i=u,c=d,this.proxyDepth+=1,s=m(a[d],a,i),this.proxyDepth-=1}const{smartArgs:a,dumbArgs:d}=ct(r);const{smartArgs:u}=ct(i);const l=Object.assign(Object.assign(Object.assign({},a),{obj:o}),{_id:"index"});const _=Object.assign(Object.assign(Object.assign({},u),{obj:n}),{_id:"index"});["Object","Array"].includes(k(s))&&(_.res=s);const[p,v,h]=((t,e)=>{const o=Z(e);const n=o._id;const r=W(t);const i=W(o);const c=V(r);const s=V(i);const a=Q(c);const d=Q(s);const u=((t,e)=>F(e,(([e,o])=>{const n=t[e];var r;return o.__change=(r=n)?H(r,o)?"same":"diff":"new",[e,o]})))(tt(a),tt(d));const l=G(u,et);const _=ot(l,n);const p=_[n];delete _[n];const v=G(_,(t=>t._rev));const h=(g=t=>t.__contains||Object.values(p).includes(t._id),J(_,(([,t])=>g(t))));var g;const f=Object.values(h);const[y,S]=(w=t=>"new"===t.__change,f.reduce((([t,e],o,n)=>w(o)?[[...t,o],e]:[t,[...e,o]]),[[],[]]));var w;const b=[...S,...y];const m=(t=>t.reduce(((t,e,o)=>Object.assign(Object.assign({},t),{[e._id]:o})),{}))(b);const E=nt(b,m);const[O]=nt([p],m);const N=S.map((t=>t._rev));const[B,...j]=((t,e)=>[e,...t].map((t=>{const e=x(t,["_id","_rev","__change","__contains"]);return J(e,(([t,e])=>P.includes(t)||"number"==typeof e))})))(E,O);return[N,j.map(X).map((t=>Object.entries(t).reduce(((t,[e,o])=>Object.assign(Object.assign({},t),{[e]:v[o]||o})),{}))),B]})(l,_);void 0!==v[0]&&(v[0].__index=h);const g=h.obj;void 0!==v[g]&&(null!==e&&(v[g].__cls=e),v[g].__func=null===c?"constructor":String(c),v[g].__args=d);const f=h.res;return void 0!==v[f]&&"function Object() { [native code] }"!==s.constructor.toString()&&(v[f].__cls=s.constructor.toString()),[p,v,n,u,s,h]}))}allocate(t,e){return w(this,void 0,void 0,(function*(){const[o,n,r,i,,c]=yield st.getUpdate({Cls:t,args:e});const[s]=yield this.db.update(o,n);const{txId:a}=C(s);Object.entries(c).forEach((([t,e])=>{const o=parseInt(t,10);let c=i[o];"obj"===t&&(c=r),z(c,n,e,a)}));const d=`${a}/${c.obj}`;return Y([r,...i],d),r}))}update(t,e,o){return w(this,void 0,void 0,(function*(){const[n,r,,i,c,s]=yield st.getUpdate({target:t,property:e,args:o});const[a]=yield this.db.update(n,r);const{txId:d}=C(a);Object.entries(s).forEach((([e,o])=>{const n=parseInt(e,10);let s=i[n];"obj"===e?s=t:"res"===e&&(s=c),z(s,r,o,d)}));const u="string"==typeof t._root?t._root:`${d}/${s.obj}`;return Y([c,t,...i],u),c}))}get(t,e){return st.proxyDepth>0||"function"!=typeof t[e]?Reflect.get(t,e):(...o)=>this.update(t,e,o)}}const at=process.env.CHAIN||"LTC";const dt=process.env.NETWORK||"testnet";const ut=process.env.BCN_URL||"https://node.bitcoincomputer.io";const lt=parseInt(process.env.BC_DUST_LIMIT||"",10)||1546;const _t=parseInt(process.env.BC_DEFAULT_FEE||"",10)||2500;var pt={CHAIN:at,NETWORK:dt,BCN_URL:ut,MIN_NON_DUST_AMOUNT:lt,SCRIPT_CHUNK_SIZE:parseInt(process.env.BC_SCRIPT_CHUNK_SIZE||"",10)||479,DEFAULT_FEE:_t,SIGHASH_ALL:1,FEE_PER_KB:2e4,PUBLIC_KEY_SIZE:65,ANYONE_CAN_SPEND_SEED:"replace this seed",PASSPHRASE:"",ENCODING_LENGTH:3,ENCODING_NUMBER_LENGTH:3,MAX_PUBKEYS_PER_SCRIPT:3,OP_RETURN_SIZE:80};const{PublicKey:vt,crypto:ht}=t.Bitcoin;const{Point:gt}=ht;function ft(t){return Buffer.from(t,"hex").toString().replace(/\0/g,"")}function yt(t,e){return t.slice(e)+t.slice(0,e)}function xt(t,e,o){if(t.length*Math.log2(e)>53)throw new Error(`Input too large ${t.length} ${Math.log2(e)}`);if(![2,10,16].includes(e)||![2,10,16].includes(o))throw new Error("ToBase or FromBase invalid in covertNumber.");if(2===e&&t.length%8!=0)throw new Error("Binary strings must be byte aligned.");if(16===e&&t.length%2!=0)throw new Error("Hex strings must be of even length.");const n=parseInt(t,e).toString(o);return 2===o?n.padStart(8*Math.ceil(n.length/8),"0"):16===o?n.padStart(2*Math.ceil(n.length/2),"0"):n}function St(t,e){const o=new RegExp(`.{1,${e}}`,"g");return t.match(o)||[]}function wt(t){return St(t,2).map((t=>xt(t,16,2))).join("")}function bt(t){return St(t,8).map((t=>xt(t,2,16))).join("")}function mt(t){return t.toString(16).padStart(pt.ENCODING_NUMBER_LENGTH,"0")}function Et(t){return parseInt(t,16)}function Ot(t){if(62!==t.length)throw new Error("Input to hexToPublicKey must be of length 62");let e=!1;let o=0;let n;for(;!e;){if(o>=256)throw new Error("Something went wrong storing data");const r=o.toString(16).padStart(2,"0")+bt(yt(wt(t).padStart(64,"0"),o));try{n=gt.fromX(!1,r),e=!0}catch(t){o+=1}}if(!n)throw new Error("Something went wrong storing data");return new vt(n)}function Nt(t){const e=t.point.getX().toString("hex").padStart(64,"0");const o=xt(e.slice(0,2),16,10);return bt((r=parseInt(o,10),(n=wt(e.slice(2))).slice(-r)+n.slice(0,-r)));var n,r}function Bt(t){return new Promise((e=>{setTimeout(e,t)}))}function jt(t,e){return`m/44'/${function(t,e){if("testnet"===e||"regtest"===e)return"1";if("BTC"===t)return"0";if("LTC"===t)return"2";if("DOGE"===t)return"3";if("BCH"===t)return"145";if("BSV"===t)return"236";throw new Error(`Unsupported chain ${t}`)}(t,e)}'/0'/0/0`}const{PublicKey:Tt,Script:Rt}=t.Bitcoin;function It(t){if(t.length>pt.MAX_PUBKEYS_PER_SCRIPT)throw new Error("Too many owners");return function(t){const e=new Rt;return e.add("OP_1"),t.forEach((t=>{e.add(t)})),e.add(`OP_${t.length}`),e.add("OP_CHECKMULTISIG"),e}(t.map((t=>t.toBuffer())))}function At(t){return function(t){return t.chunks.filter((t=>t.buf)).map((t=>t.buf))}(t).map((t=>Tt.fromBuffer(t)))}function Ut(t){return Buffer.from(p.default.SHA256(t).toString(),"hex").toString("hex").substr(0,4)}function Ct(t){return`${Ut(t)};${t}`}function qt(t){const e=t.substr(0,4);const o=t.substr(5);if(!function(t,e){return Ut(t)===e}(o,e))throw new Error("Decryption failure");return o}function Pt(t){if(void 0!==t._readers){const{_readers:e,_url:o,_owners:n,_amount:r}=t,i=x(t,["_readers","_url","_owners","_amount"]);const c=function(t,e){const o=_.default.randomBytes(32).toString("hex");const n=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const o=Buffer.from(e,"hex").toString("binary");const n=Ct(t);return p.default.AES.encrypt(n,o).toString()}(t,o);const r=e.map((t=>function(t,e){if(!/^0[2-3][0-9a-f]{64}|04[0-9a-f]{128}$/.test(e))throw new Error("Invalid publicKey");const o=Ct(t);return v.encrypt(e,Buffer.from(o,"utf8")).toString("base64")}(o,t)));return{__cypher:n,__secrets:r}}(JSON.stringify(i),e);return void 0!==o&&(c._url=o),void 0!==n&&(c._owners=n),void 0!==r&&(c._amount=r),c}return t}const{Transaction:Mt}=t.Bitcoin;const{Output:kt}=Mt;const{UnspentOutput:$t}=Mt;let Dt=class{constructor(t,e,o){const n=new Mt(o);n.feePerKb(pt.FEE_PER_KB),this.nodeConfig=t,this.tx=n,this.outData=[],this.privateKey=e}get txId(){return this.tx.id}get chain(){return this.nodeConfig.chain}get network(){return this.nodeConfig.network}get restClient(){return new q(this.nodeConfig,this.privateKey)}get inputs(){return this.tx.inputs.map((t=>`${t.prevTxId.toString("hex")}/${t.outputIndex}`))}get inRevs(){const{enc:t}=this;let[e]=t;return e=Number.isFinite(e)?e:0,this.tx.inputs.slice(0,e).map((({prevTxId:t,outputIndex:e})=>`${t.toString("hex")}/${e}`))}get outRevs(){const{enc:t}=this;let[,e]=t;return e=Number.isFinite(e)?e:0,Array.from(Array(e).keys()).map((t=>`${this.tx.id}/${t}`))}get opReturns(){try{const{outputs:t}=this.tx;return t.filter((({script:t})=>t.isDataOut())).map((({script:t})=>t.getData())).map((t=>t.toString())).join()}catch(t){return""}}get enc(){return St(this.opReturns.slice(0,pt.ENCODING_LENGTH*pt.ENCODING_NUMBER_LENGTH),pt.ENCODING_NUMBER_LENGTH).map(Et)}get dataPrefix(){return this.opReturns.slice(9)}getOwnerOutputs(){const{enc:t}=this;const[,e=0]=t;return this.tx.outputs.slice(0,e)}getDataOutputs(){const{enc:t}=this;const[,e,o]=t;return this.tx.outputs.slice(e,o)}getOutData(t){return w(this,void 0,void 0,(function*(){try{const e=this.getDataOutputs().map((t=>t.script)).map((t=>At(t))).flat().map(Nt).map(ft).join("");const{dataPrefix:o}=this;const n=JSON.parse(o+e);const r=t.toBuffer().toString("hex");const i=this.getOwnerOutputs();if(i.length!==n.length)throw new Error("Inconsistent state");const c=i.map(((t,e)=>Object.assign(Object.assign({},n[e]),{_owners:At(t.script).map((t=>t.toString())),_amount:t.satoshis})));return Promise.all(c.map((e=>w(this,void 0,void 0,(function*(){try{const o=yield function(t){return e=>w(this,void 0,void 0,(function*(){if(function(t){return void 0!==t._url}(e)){const{_url:o}=e,n=x(e,["_url"]);const{host:r,data:i}=yield q.getSecretOutput({_url:o,privateKey:t});return Object.assign(Object.assign(Object.assign({},n),JSON.parse(i)),{_url:r})}return e}))}(t)(e);return function(t,e){if(function(t){return void 0!==t.__cypher&&void 0!==t.__secrets}(t)){const{__cypher:o,__secrets:n}=t,r=x(t,["__cypher","__secrets"]);return Object.assign(Object.assign(Object.assign({},r),JSON.parse(function({__cypher:t,__secrets:e},o){let n="";if(o.forEach((o=>{e.forEach((e=>{try{const r=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid privateKey");return qt(v.decrypt(e,Buffer.from(t,"base64")).toString("utf8"))}(e,o);n=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const o=Buffer.from(e,"hex").toString("binary");return qt(p.default.AES.decrypt(t,o).toString(p.default.enc.Utf8))}(t,r)}catch(t){const e=["Decryption failure","Unsupported state or unable to authenticate data"];if(t instanceof Error&&!e.includes(t.message))throw t}}))})),n)return n;throw new Error("Decryption failure")}({__cypher:o,__secrets:n},e))),{_readers:[]})}return t}(o,[r])}catch(t){return null}})))))}catch(t){return[]}}))}getOwners(){return this.getOwnerOutputs().map((t=>At(t.script).map((t=>t.toString()))))}getAmounts(){return this.getOwnerOutputs().map((t=>t.satoshis))}spendFromData(e){return w(this,void 0,void 0,(function*(){if(!e.length)return;const o=e.map(C);const n=o.map((t=>t.txId));const r=yield this.restClient.getTransactions(n);for(let e=0;e<o.length;e+=1){const{txId:n,outputIndex:i}=o[e];const{outputs:c}=r[e];const s=c[i];const a=Math.round(s.satoshis);const d=new t.Bitcoin.Script(s.script);const u=new $t({txId:n,outputIndex:i,satoshis:a,script:d});const l=At(d).map((t=>t.toString()));this.tx.from([u],l,1)}}))}createOpReturnOut(t){this.tx.addData(JSON.stringify(t))}createDataOuts(e){e.forEach((({_amount:e,_owners:o=[]})=>{if(Array.isArray(o)&&o.length>pt.MAX_PUBKEYS_PER_SCRIPT)throw new Error("Too many owners.");const n=o.map((e=>t.Bitcoin.PublicKey.fromString(e)));const r=e||pt.MIN_NON_DUST_AMOUNT;const i=It(n);this.tx.addOutput(new kt({script:i,satoshis:r}))}));const o=e.map((t=>x(t,["_amount","_owners"])));const n=pt.MIN_NON_DUST_AMOUNT;const r=JSON.stringify(o);const i=pt.OP_RETURN_SIZE-pt.ENCODING_LENGTH*pt.ENCODING_NUMBER_LENGTH;const c=r.slice(0,i);const s=function(t){var e;return function(t,e){const o=[];for(let n=0;n<t.length;n+=e)o.push(t.slice(n,n+e));return o}(St((e=t,Buffer.from(e).toString("hex")),62).map((t=>t.padStart(62,"0"))).map(Ot),pt.MAX_PUBKEYS_PER_SCRIPT).map((t=>It(t)))}(r.slice(i));const a=mt(this.tx.inputs.length)+mt(this.tx.outputs.length)+mt(this.tx.outputs.length+s.length);s.forEach((t=>{this.tx.addOutput(new kt({script:t,satoshis:n}))})),this.tx.addData(a+c)}static fromTxHex(t,e,o){return w(this,void 0,void 0,(function*(){const n=new this(e,o);n.tx.fromString(t);const r=yield n.getOutData(o);const i=n.getOwners();const c=n.getAmounts();return n.outData=r.map(((t,e)=>Object.assign(Object.assign({},t),{_owners:i[e],_amount:c[e]}))),n}))}static fromTxId(t,e,o){return w(this,void 0,void 0,(function*(){const n=new q(e,o);const r=yield n.getRawTx(t);return this.fromTxHex(r,e,o)}))}};Dt=S([t=>t],Dt);class Lt{constructor(t){this.wallet=t}get chain(){return this.wallet.chain}get network(){return this.wallet.network}get nodeConfig(){return this.wallet.nodeConfig}fromTxHex(t){return w(this,void 0,void 0,(function*(){const{wallet:e,nodeConfig:o}=this;const n=e.getPrivateKey();return Dt.fromTxHex(t,o,n)}))}fromTxId(t){return w(this,void 0,void 0,(function*(){const{wallet:e,nodeConfig:o}=this;const n=new q(o,e.getPrivateKey());const r=yield n.getRawTx(t);return this.fromTxHex(r)}))}get(t){return w(this,void 0,void 0,(function*(){const e=t.map(C);return Promise.all(e.map((({txId:t,outputIndex:e})=>w(this,void 0,void 0,(function*(){const{outData:o}=yield this.fromTxId(t);if(e>o.length)throw new Error("Index out of bounds");return o[e]})))))}))}put(t){return this.update([],t)}createTx(t,e){return w(this,void 0,void 0,(function*(){const{wallet:o,nodeConfig:n}=this;const r=o.getPrivateKey();const i=new Dt(n,r);const c=e.map((t=>{var{_owners:e}=t,o=x(t,["_owners"]);return Object.assign({_owners:e||[this.wallet.getPublicKey().toString()]},o)})).map(Pt);const s=yield Promise.all(c.map(function(t){return e=>w(this,void 0,void 0,(function*(){if(void 0!==e._url){const{_url:o,_owners:n,_amount:r}=e,i=x(e,["_url","_owners","_amount"]);const c=yield q.setSecretOutput({host:o,secretOutput:{data:JSON.stringify(i)},privateKey:t});return void 0!==n&&(c._owners=n),void 0!==r&&(c._amount=r),c}return e}))}(r)));return yield i.spendFromData(t),yield i.createDataOuts(s),i}))}update(t,e){return w(this,void 0,void 0,(function*(){const o=yield this.createTx(t,e);return yield this.wallet.fundAndSendTransaction(o),o.outRevs}))}}class Kt{constructor(t,e,o={}){const{chain:n,network:r}=e;const{path:i=jt(n,r),passphrase:c=""}=o;let s=t.toHDPrivateKey(c,r);i&&(s=s.derive(i));const a=s.publicKey.toAddress(r);this.mnemonic=t,this.restClient=e,this.path=i,this.passphrase=c,this.hdPrivateKey=s,this.address=a}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get nodeConfig(){return this.restClient.nodeConfig}getMnemonic(){return this.mnemonic}derive(t="0"){const e=`${this.path}${this.path.length>0?"/":""}${t}`;return new Kt(this.mnemonic,this.restClient,{path:e})}getPrivateKey(){return this.hdPrivateKey.privateKey}getPublicKey(){return this.hdPrivateKey.publicKey}getAddress(){return this.address}getBalance(){return w(this,void 0,void 0,(function*(){return this.restClient.getBalance(this.getAddress())}))}getUtxos(t=this.getAddress()){return w(this,void 0,void 0,(function*(){return this.restClient.getUtxosFromAddress(t)}))}selectUtxos(t,e){let o=0;const n=[];!function(t){const e=t;for(let t=e.length-1;t>0;t-=1){const o=Math.floor(Math.random()*(t+1));[e[t],e[o]]=[e[o],e[t]]}}(t);for(let r=0;r<t.length;r+=1){const i=t[r];if(o+=1e8*i.amount,n.push(i),o>=e)return n}const{network:r,chain:i}=this.restClient.nodeConfig;throw new Error(`Insufficient balance in address ${this.getAddress().toString()} on ${r} ${i}. Found ${o}, required ${e}.`)}fundAndSendTransaction(e){return w(this,void 0,void 0,(function*(){e.tx.feePerKb(pt.FEE_PER_KB);const{chain:o,network:n}=this.nodeConfig;const r=e.tx._estimateFee()*function(t){if("LTC"===t)return 1;if("BTC"===t)return.01;if("DOGE"===t)return.3;if("BCH"===t)return 1;throw new Error(`Unsupported chain ${t}`)}(o);const i=.001*e.tx._getOutputAmount();const c=Math.max(pt.MIN_NON_DUST_AMOUNT,r+i);e.tx.to(function(t,e){const o={"any-testnet":"gLjNGbKQzxqKA9bv2nhn1Ewf7rxYVXgrtR","BTC-mainnet":"84ZHRqRPTcUv6AFGMVC1KmSUeC9Y8SNfMm","LTC-mainnet":"mov5ivrsqWut5ffZhiz18uAkwy2D4y98iz","DOGE-mainnet":"1MVukPYmWdbEoxy3Sqq1ES4nYqDfpB5e68","BCH-mainnet":"P9CmJszhvARfQc8YjUW1K2oBnus1ZQWEqk","BSV-mainnet":"G2wxQ74zX48WMo7sfiX1faGGNQB8ebVth"};return yt("testnet"===e||"regtest"===e?o["any-testnet"]:o[`${t}-${e}`],19)}(o,n),Math.round(c));let s=e.tx._getInputAmount();const a=e.tx._getOutputAmount();const d=e.tx._estimateFee();let u=a-s+Math.round(d);for(;u>0;){const o=yield this.getUtxos(this.getAddress());this.selectUtxos(o,u).forEach((o=>{e.tx.from([new t.Bitcoin.Transaction.UnspentOutput(o)])})),s=e.tx._getInputAmount(),u=a-s+Math.round(e.tx._estimateFee())}e.tx.change(this.getAddress()),e.tx.sign(this.getPrivateKey(),pt.SIGHASH_ALL);const l=yield this.restClient.sendTransaction(e.tx.toString());return yield this.storeResult(l,e),l}))}storeResult(t,e){return w(this,void 0,void 0,(function*(){const{inputs:o,inRevs:n,outRevs:r}=e;const i=yield e.getOutData(this.getPrivateKey());const c=JSON.stringify(i);yield this.restClient.postNonStandardUtxo({outData:c,txId:t,inputs:o,inRevs:n,outRevs:r})}))}send(t,e){return w(this,void 0,void 0,(function*(){const o=new Dt(this.restClient.nodeConfig,this.getPrivateKey());return o.tx.to(e,t),this.fundAndSendTransaction(o)}))}}class Ht extends class{constructor(t,e){this.chain=t,this.network=e}}{constructor(t,e,o){super(t,e),this.url=o}}const{Mnemonic:Wt,PublicKey:Ft}=t.Bitcoin;class Gt{constructor(t={}){var e,o;const{seed:n}=t;const r=(null===(e=t.chain)||void 0===e?void 0:e.toUpperCase())||pt.CHAIN;const i=(null===(o=t.network)||void 0===o?void 0:o.toLowerCase())||pt.NETWORK;const c=t.url||pt.BCN_URL;const s=t.passphrase||pt.PASSPHRASE;const a=t.path||jt(r,i);const d=t.mnemonic||new Wt(n);if(!r||!["BTC","LTC","DOGE","BCH","BSV"].includes(r.toUpperCase()))throw new Error("We are currently only supporting 'BTC', 'LTC', 'DOGE', 'BCH', and 'BSV'");if(!i||!["mainnet","testnet","regtest"].includes(i.toLowerCase()))throw new Error("Please set 'network' to 'testnet', or 'regtest'");const u=((t,e,o={})=>{const{path:n,passphrase:r}=o;let i=t.toHDPrivateKey(r,e);return n&&(i=i.derive(n)),i.privateKey})(d,i,{path:a,passphrase:s});const l=new Ht(r,i,c);const _=new q(l,u);this.db=t.db||new Lt(new Kt(d,_,{path:a,passphrase:s}))}get chain(){return this.db.chain}get network(){return this.db.network}parseContract(t){const e=t.startsWith("export ")?t.slice(7):t;const o=e.startsWith("default ")?e.slice(8):e;return b(`(${o})`)}new(t,e){return w(this,void 0,void 0,(function*(){const o=t.toString();const n=yield this.parseContract(o);const r=new st(this.db);const i=yield r.allocate(n,e);return new Proxy(i,r)}))}sync(t){return w(this,void 0,void 0,(function*(){U(t);const e=new rt(this.db);const o=new st(this.db);const n=yield e.get(t);return new Proxy(n,o)}))}getOwnedRevs(t=this.db.wallet.getPublicKey()){return this.db.wallet.restClient.getOwnedRevs(t)}queryRevs(t){return w(this,void 0,void 0,(function*(){const{publicKey:e,contractName:o,contractHash:n}=t;const r=e?new Ft(e):void 0;return this.db.wallet.restClient.queryRevs({publicKey:r,contractName:o,contractHash:n})}))}getRevs(t=this.db.wallet.getPublicKey()){return w(this,void 0,void 0,(function*(){return(yield this.getOwnedRevs(t)).map((({rev:t})=>t))}))}getLatestRev(t){return w(this,void 0,void 0,(function*(){return this.db.wallet.restClient.getLatestRev(t)}))}getLatestRevs(t){return w(this,void 0,void 0,(function*(){return this.db.wallet.restClient.getLatestRevs(t)}))}}var Jt=h.default;var zt=g.default;var Yt=f.default;function Zt(t){"string"==typeof t&&(t=function(t){var e=Yt.parse(t);var o=e.hostname;var n=parseInt(e.port,10);var r=e.protocol;r=r.substring(0,r.length-1);var i=e.auth.split(":");return{host:o,port:n,protocol:r,user:i[0]?decodeURIComponent(i[0]):null,pass:i[1]?decodeURIComponent(i[1]):null}}(t)),t=t||{},this.host=t.host||"127.0.0.1",this.port=t.port||8332,this.user=t.user||"user",this.pass=t.pass||"pass",this.protocol="http"===t.protocol?Jt:zt,this.batchedCalls=null,this.disableAgent=t.disableAgent||!1;var e=void 0!==t.rejectUnauthorized;this.rejectUnauthorized=!e||t.rejectUnauthorized,Zt.config.log?this.log=Zt.config.log:this.log=Zt.loggers[Zt.config.logger||"normal"]}var Vt=console.log.bind(console);var Xt=function(){};function Qt(t,e){var o=this;t=JSON.stringify(t);var n=this.user+":"+this.pass;var r=Buffer.from&&Buffer.from!==Uint8Array.from?Buffer.from(n):new Buffer(n);this.auth=r.toString("base64");var i={host:o.host,path:"/",method:"POST",port:o.port,rejectUnauthorized:o.rejectUnauthorized,agent:!o.disableAgent&&void 0};if(o.httpOptions)for(var c in o.httpOptions)i[c]=o.httpOptions[c];var s=!1;var a="Bitcoin JSON-RPC: ";var d=this.protocol.request(i,(function(t){var n="";t.on("data",(function(t){n+=t})),t.on("end",(function(){if(!s)if(s=!0,401!==t.statusCode)if(403!==t.statusCode){if(500===t.statusCode&&"Work queue depth exceeded"===n.toString("utf8")){var r=new Error("Bitcoin JSON-RPC: "+n.toString("utf8"));return r.code=429,void e(r)}var i;try{i=JSON.parse(n)}catch(r){o.log.err(r.stack),o.log.err(n),o.log.err("HTTP Status code:"+t.statusCode);var c=new Error(a+"Error Parsing JSON: "+r.message);return void e(c)}e(i.error,i)}else e(new Error(a+"Connection Rejected: 403 Forbidden"));else e(new Error(a+"Connection Rejected: 401 Unnauthorized"))}))}));d.on("error",(function(t){var o=new Error(a+"Request Error: "+t.message);s||(s=!0,e(o))})),d.setHeader("Content-Length",t.length),d.setHeader("Content-Type","application/json"),d.setHeader("Authorization","Basic "+o.auth),d.write(t),d.end()}Zt.loggers={none:{info:Xt,warn:Xt,err:Xt,debug:Xt},normal:{info:Vt,warn:Vt,err:Vt,debug:Xt},debug:{info:Vt,warn:Vt,err:Vt,debug:Vt}},Zt.config={logger:"normal"},Zt.prototype.batch=function(t,e){this.batchedCalls=[],t(),Qt.call(this,this.batchedCalls,e),this.batchedCalls=null},Zt.callspec={abandonTransaction:"str",abortRescan:"",addMultiSigAddress:"",addNode:"",analyzePSBT:"str",backupWallet:"",bumpFee:"str",clearBanned:"",combinePSBT:"obj",combineRawTransaction:"obj",convertToPSBT:"str",createMultiSig:"",createPSBT:"obj",createRawTransaction:"obj obj",createWallet:"str",decodePSBT:"str",decodeScript:"str",decodeRawTransaction:"",deriveAddresses:"str",disconnectNode:"",dumpPrivKey:"",dumpWallet:"str",encryptWallet:"",enumerateSigners:"",estimateFee:"",estimateSmartFee:"int str",estimatePriority:"int",generate:"int",generateBlock:"str obj",generateToAddress:"int str",generateToDescriptor:"int str",getAccount:"",getAccountAddress:"str",getAddedNodeInfo:"",getAddressMempool:"obj",getAddressUtxos:"obj",getAddressBalance:"obj",getAddressDeltas:"obj",getAddressesByLabel:"str",getAddressInfo:"str",getAddressTxids:"obj",getAddressesByAccount:"",getBalance:"str int",getBalances:"",getBestBlockHash:"",getBlockDeltas:"str",getBlock:"str int",getBlockchainInfo:"",getBlockCount:"",getBlockFilter:"str",getBlockHashes:"int int obj",getBlockHash:"int",getBlockHeader:"str",getBlockNumber:"",getBlockStats:"str",getBlockTemplate:"",getConnectionCount:"",getChainTips:"",getChainTxStats:"",getDescriptorInfo:"str",getDifficulty:"",getGenerate:"",getHashesPerSec:"",getIndexInfo:"",getInfo:"",getMemoryInfo:"",getMemoryPool:"",getMemPoolAncestors:"str",getMemPoolDescendants:"str",getMemPoolEntry:"str",getMemPoolInfo:"",getMiningInfo:"",getNetTotals:"",getNetworkHashPS:"",getNetworkInfo:"",getNewAddress:"str str",getNodeAddresses:"",getPeerInfo:"",getRawChangeAddress:"",getRawMemPool:"bool",getRawTransaction:"str int",getReceivedByAccount:"str int",getReceivedByAddress:"str int",getReceivedByLabel:"str",getRpcInfo:"",getSpentInfo:"obj",getTransaction:"",getTxOut:"str int bool",getTxOutProof:"",getTxOutSetInfo:"",getUnconfirmedBalance:"",getWalletInfo:"",getWork:"",getZmqNotifications:"",finalizePSBT:"str",fundRawTransaction:"str",help:"",importAddress:"str str bool",importDescriptors:"str",importMulti:"obj obj",importPrivKey:"str str bool",importPrunedFunds:"str, str",importPubKey:"str",importWallet:"str",invalidateBlock:"str",joinPSBTs:"obj",keyPoolRefill:"",listAccounts:"int",listAddressGroupings:"",listBanned:"",listDescriptors:"",listLabels:"",listLockUnspent:"bool",listReceivedByAccount:"int bool",listReceivedByAddress:"int bool",listReceivedByLabel:"",listSinceBlock:"str int",listTransactions:"str int int",listUnspent:"int int",listWalletDir:"",listWallets:"",loadWallet:"str",lockUnspent:"",logging:"",move:"str str float int str",ping:"",preciousBlock:"str",prioritiseTransaction:"str float int",pruneBlockChain:"int",psbtBumpFee:"str",removePrunedFunds:"str",reScanBlockChain:"",saveMemPool:"",send:"obj",setHDSeed:"",setLabel:"str str",setWalletFlag:"str",scanTxOutSet:"str",sendFrom:"str str float int str str",sendMany:"str obj int str",sendRawTransaction:"str",sendToAddress:"str float str str",setAccount:"",setBan:"str str",setNetworkActive:"bool",setGenerate:"bool int",setTxFee:"float",signMessage:"",signMessageWithPrivKey:"str str",signRawTransaction:"",signRawTransactionWithKey:"str obj",signRawTransactionWithWallet:"str",stop:"",submitBlock:"str",submitHeader:"str",testMemPoolAccept:"obj",unloadWallet:"",upgradeWallet:"",uptime:"",utxoUpdatePSBT:"str",validateAddress:"",verifyChain:"",verifyMessage:"",verifyTxOutProof:"str",walletCreateFundedPSBT:"",walletDisplayAddress:"str",walletLock:"",walletPassPhrase:"string int",walletPassphraseChange:"",walletProcessPSBT:"str"};var te=function(t,e,o){return Array.prototype.slice.call(t,e,o)};function ee(){return parseInt(1e5*Math.random())}!function(t,e,o){function n(t,e){return function(){var n=arguments.length-1;this.batchedCalls&&(n=arguments.length);for(var r=0;r<n;r++)e[r]&&(arguments[r]=e[r](arguments[r]));this.batchedCalls?this.batchedCalls.push({jsonrpc:"2.0",method:t,params:te(arguments),id:ee()}):o.call(this,{method:t,params:te(arguments,0,arguments.length-1),id:ee()},arguments[arguments.length-1])}}var r={str:function(t){return t.toString()},int:function(t){return parseFloat(t)},float:function(t){return parseFloat(t)},bool:function(t){return!0===t||"1"==t||"true"==t||"true"==t.toString().toLowerCase()},obj:function(t){return"string"==typeof t?JSON.parse(t):t}};for(var i in e){var c=[];if(e[i].length){c=e[i].split(" ");for(var s=0;s<c.length;s++)r[c[s]]?c[s]=r[c[s]]:c[s]=r.str}var a=i.toLowerCase();t.prototype[i]=n(a,c),t.prototype[a]=t.prototype[i]}}(Zt,Zt.callspec,Qt);var oe=Zt;const ne=["travel upgrade inside soda birth essence junk merit never twenty system opinion","hover harsh text dice wealth pill across trade soccer olive view acquire","damp comfort scan couple absurd enter slogan cheap ketchup print syrup hurdle one document diamond","notable rose silver indicate wreck mean raise together jar fish seat air","lens release coil rain forward lemon cube satisfy inject visa ring segment"];const{CHAIN:re="LTC",NETWORK:ie="regtest",RPC_USER:ce,RPC_PASSWORD:se,RPC_HOST:ae}=process.env;const de="LTC"===process.env.CHAIN?19332:8332;var ue=Object.assign(Object.assign({},pt),{CHAIN:re,NETWORK:ie,BCN_URL:"http://127.0.0.1:3000",RPC_PROTOCOL:"http",RPC_USER:ce,RPC_PASSWORD:se,RPC_HOST:ae,RPC_PORT:de,TEST_ADDRESSES:"moMoH1vTgCc2dkDfGSKYPnafxy22wSqgrr;mmQEk8VwtSehRryLF8jhVapYg553hJGhNa;miKQVhZbFKSsJcQZ8eXwBQ89xNyetpN34q;mzoGRNh55y9j57TPdwRGi3nt9X4CFwpqUS;n1X6JFDyxibtdhYrc7mrkuft6o168ELFNW;mjLcig6eTZVJkgRgJFMkwrYHpfMnZ1t4kk;mfYkMQAe7afeRSkgLxAtwnMVryjLTfr95Q"});const{PrivateKey:le,Opcode:_e,Script:pe,Mnemonic:ve,crypto:he,Transaction:ge,encoding:fe}=t.Bitcoin;function ye(t=0){return new ve(ne[t])}function xe(t=0){return new Gt(function(t=0){return{mnemonic:ye(t),chain:ue.CHAIN,network:ue.NETWORK}}(t))}new Ht(ue.CHAIN,ue.NETWORK,ue.BCN_URL);const Se=t=>w(void 0,void 0,void 0,(function*(){const e=(()=>{const t=ue.RPC_PROTOCOL;const e=ue.RPC_USER;const o=ue.RPC_PASSWORD;const n=ue.RPC_HOST;const r=ue.RPC_PORT;return new oe({protocol:t,user:e,pass:o,host:n,port:r})})();const o=y.default.promisify(oe.prototype.generateToAddress.bind(e));yield o(1,t)}));const we=new Ht(ue.CHAIN,ue.NETWORK,ue.BCN_URL);const be=xe(1);const{db:me}=be;const Ee=xe(2);const{db:Oe}=Ee;const Ne=new rt(me);const Be=t=>t.split("/")[0];const je=t=>{const[e,o]=t.split("/");const n=parseFloat(o);return[64,65].includes(e.length)&&!Number.isNaN(n)&&Number.isFinite(n)};const Te=ue.TEST_ADDRESSES?ue.TEST_ADDRESSES.split(";"):[];beforeEach((()=>{for(let t=0;t<Te.length;t+=1)Se(Te[t])})),describe("Computer",(()=>{jest.setTimeout(3e4),describe("new",(()=>{describe("Should create a smart object without argument",(()=>{class t{constructor(){this.n=1}}let e;beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=e||(yield be.new(t))})))),it("Should create a smart object when computer.new is called",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:1,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(e._id).toBe(e._rev),expect(e._id).toBe(e._root),expect(je(e._id)),expect(je(e._rev)),expect(je(e._root))})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield me.get([e._rev])).toEqual([{__func:"constructor",__args:[],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}])})))),it("should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.sync(e._rev)).toEqual(e)}))))})),describe("Should create a smart object with a dumb argument",(()=>{class t{constructor(t){this.n=t}}let e;const o=Math.random();beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=e||(yield be.new(t,[o]))})))),it("Should create a smart object when computer.new is called",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:o,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(e._id).toBe(e._rev),expect(e._id).toBe(e._root),expect(je(e._id)),expect(je(e._rev)),expect(je(e._root))})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield me.get([e._rev])).toEqual([{__func:"constructor",__args:[o],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}])})))),it("should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.sync(e._rev)).toEqual(e)}))))})),describe("Should create a smart object with a smart argument",(()=>{class t{constructor(){this.n=1}}class e{constructor(t){this.a=t}}let o;let n;beforeEach((()=>w(void 0,void 0,void 0,(function*(){o=o||(yield be.new(t,[])),n=n||(yield be.new(e,[o]))}))),6e4),it("Should create a smart object when computer.new is called",(()=>w(void 0,void 0,void 0,(function*(){expect(o).toEqual({n:1,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n).toEqual({a:{n:1,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)},_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n.a).toEqual(o)}))),6e4),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(je(o._id)),expect(je(o._rev)),expect(je(o._root)),expect(je(n._id)),expect(je(n._rev)),expect(je(n._root));const t=Be(o._id);const e=Be(n._id);expect(t).not.toBe(e),expect(o._id).toBe(`${t}/0`),expect(o._rev).toBe(`${e}/0`),expect(n._id).toBe(`${e}/1`),expect(n._rev).toBe(`${e}/1`),expect(n.a._id).toBe(o._id),expect(n.a._rev).toBe(o._rev),expect(o._root).toBe(o._id),expect(n._root).toBe(n._id)}))),6e4),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get(o._rev)).toEqual(o)}))),6e4),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield me.get([o._id])).toEqual([{__func:"constructor",__args:[],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}]);const r=Be(n._id);expect(yield me.get([`${r}/0`,`${r}/1`])).toEqual([{__index:{0:0,obj:1},_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT},{a:0,__func:"constructor",__args:["__"],__cls:e.toString(),_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}])}))),6e4),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.getLatestRev(n._id)).toBe(n._rev),expect(yield be.getLatestRev(o._id)).toBe(o._rev)}))),6e4),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.sync(o._rev)).toEqual(o),expect(yield Ee.sync(n._rev)).toEqual(n)}))))})),describe("Should create a smart object with a sub-object",(()=>{class t{constructor(){this.n={m:1}}}let e;beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=e||(yield be.new(t,[]))})))),it("Should create a smart object when computer.new is called",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:{_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),m:1},_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(e._id).toBe(e._rev),expect(e.n._id).toBe(e.n._rev),expect(e._root).toBe(e._id),expect(e.n._root).toBe(e._id)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){const t=yield Ne.get(e._rev);expect(t).toEqual(e),expect(e.n._id.startsWith("__temp__")).toBe(!1),expect(e.n._rev.startsWith("__temp__")).toBe(!1);const o=yield Ne.get(e.n._rev);expect(o).toBeUndefined()})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield me.get([e._rev])).toEqual([{n:1,__func:"constructor",__args:[],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.sync(e._rev)).toEqual(e)}))))})),describe("Should create a smart object with a smart sub-object",(()=>{class t{constructor(e){this.b=e?new t(!1):void 0}}let e;beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=e||(yield be.new(t,[!0]))})))),it("Should create a smart object when computer.new is called",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({b:{_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),b:void 0},_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(e._id).toBe(e._rev),expect(e.b._id).toBe(e.b._rev),expect(e._root).toBe(e._id),expect(e.b._root).toBe(e._id)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){const t=yield Ne.get(e._rev);expect(t).toEqual(e),expect(e.b._id.startsWith("__temp__")).toBe(!1),expect(e.b._rev.startsWith("__temp__")).toBe(!1);const o=yield Ne.get(e.b._rev);expect(o).toBeUndefined()})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield me.get([e._rev])).toEqual([{b:1,__func:"constructor",__args:[!0],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.sync(e._rev)).toEqual(e)}))))})),describe("Should create a smart object with an owner defined",(()=>{class t{constructor(t,e){this.n=t,this._owners=[e]}}let e;const o=Math.random();const n=be.db.wallet.getPublicKey().toString();beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=e||(yield be.new(t,[o,n]))})))),it("Should create a smart object when computer.new is called",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:o,_owners:[n],_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(e._id).toBe(e._rev),expect(e._id).toBe(e._root),expect(je(e._id)),expect(je(e._rev)),expect(je(e._root))})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield me.get([e._rev])).toEqual([{__func:"constructor",__args:[o,n],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}])})))),it("should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.sync(e._rev)).toEqual(e)}))))})),describe("Should create an encrypted smart object",(()=>{class t{constructor(t,e){this.n=t,this._readers=[e]}}let e;const o=Math.random();const n=be.db.wallet.getPublicKey().toString();beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=e||(yield be.new(t,[o,n]))})))),it("Should create a smart object when computer.new is called",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:o,_readers:[n],_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(e._id).toBe(e._rev),expect(e._id).toBe(e._root),expect(je(e._id)),expect(je(e._rev)),expect(je(e._root))})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with encoded data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield me.get([e._id])).toEqual([{__func:"constructor",__args:[o,n],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_readers:[],_amount:ue.MIN_NON_DUST_AMOUNT}])})))),it("Should be able to decode the output when db has access",(()=>w(void 0,void 0,void 0,(function*(){expect(yield me.get([e._rev])).toEqual([{_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT,__cls:t.toString(),__index:{obj:0},__func:"constructor",__args:[o,n],_readers:[]}])})))),it("Should be not able to decode the output when db does not has access",(()=>w(void 0,void 0,void 0,(function*(){try{yield Oe.get([e._rev])}catch(t){expect(t).toBeInstanceOf(Error),expect(t).toHaveProperty("message","Decryption failure")}})))),it("should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.sync(e._rev)).toEqual(e);try{yield Ee.sync(e._rev),expect(!0).toBe(!1)}catch(t){expect(t.message).toBe("Cannot read properties of undefined (reading '__cls')")}}))))})),describe("Should create an off-chain object",(()=>{class t{constructor(t){this.n=t,this._url="http://127.0.0.1:3000"}}let e;const o=Math.random();beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=e||(yield be.new(t,[o]))})))),it("Should create a smart object when computer.new is called",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:o,_url:"http://127.0.0.1:3000",_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with encoded data data",(()=>w(void 0,void 0,void 0,(function*(){const n=e._rev.split("/")[0];const r=yield Dt.fromTxId(n,we,be.db.wallet.getPrivateKey());const{outData:i}=r;expect(i).toEqual([{__args:[o],__cls:t.toString(),__func:"constructor",__index:{obj:0},_url:expect.any(String),_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}])})))),it("Should be able to get the output from the server when db has access",(()=>w(void 0,void 0,void 0,(function*(){expect(yield me.get([e._rev])).toEqual([{__func:"constructor",__args:[o],__index:{obj:0},__cls:t.toString(),_url:"http://127.0.0.1:3000",_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}])})))),it("Should give all users access to the server",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Oe.get([e._rev])).toEqual([{__func:"constructor",__args:[o],__index:{obj:0},__cls:t.toString(),_url:"http://127.0.0.1:3000",_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}])})))),it("should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.sync(e._rev)).toEqual(e)}))))})),describe("Should work if the contract is a string",(()=>{let t=null;beforeEach((()=>w(void 0,void 0,void 0,(function*(){t=yield be.new("class A {\n        constructor(n) {\n          this.n = n\n        }\n      }",[1]),yield Bt(2e3)})))),it("should work",(()=>{expect(t).toBeDefined(),expect(typeof t).toBe("object"),expect(t).toEqual({n:1,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(t._id).toBe(t._rev)})),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){const e=xe();expect(yield e.sync(t._rev)).toEqual(t)}))))})),describe("Should not create a smart object if no args as passed to the constructor",(()=>{class t{constructor(t,e){this.n=t,this._owners=[e]}}let e;it("Should throw an error",(()=>w(void 0,void 0,void 0,(function*(){try{e=e||(yield be.new(t,[])),expect(!0).toBe(!1)}catch(t){expect(e).toBeUndefined(),expect(t.message).toBeDefined()}}))))}))})),describe("function calls",(()=>{describe("Should work for a function call with a dumb argument",(()=>{class t{constructor(t){this.n=t}inc(t){return this.n+=t,this.n}}let e;let o=!1;beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=e||(yield be.new(t,[1])),o||(yield e.inc(1),o=!0)})))),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:2,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(je(e._id)).toBe(!0),expect(je(e._rev)).toBe(!0),expect(je(e._root)).toBe(!0),expect(e._id).not.toBe(e._rev),expect(e._id).toBe(e._root)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield me.get([e._id])).toEqual([{__func:"constructor",__args:[1],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}]),expect(yield me.get([e._rev])).toEqual([{__func:"inc",__args:[1],__index:{obj:0},_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.sync(e._rev)).toEqual(e)}))))})),describe("Should work for a function call on an encrypted object",(()=>{class t{constructor(t,e){this.n=t,this._readers=[e]}inc(t){return this.n+=t,this.n}}let e;const o=Math.random();let n=!1;const r=be.db.wallet.getPublicKey().toString();beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=e||(yield be.new(t,[o,r])),n||(yield e.inc(1),n=!0)})))),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:expect.any(Number),_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),_readers:[r]})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(je(e._id)).toBe(!0),expect(je(e._rev)).toBe(!0),expect(je(e._root)).toBe(!0),expect(e._id).not.toBe(e._rev),expect(e._id).toBe(e._root)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield me.get([e._id])).toEqual([{__func:"constructor",__args:[o,r],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_readers:[],_amount:ue.MIN_NON_DUST_AMOUNT}]),expect(yield me.get([e._rev])).toEqual([{__func:"inc",__args:[1],__index:{obj:0},_owners:[expect.any(String)],_readers:[],_amount:ue.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.sync(e._rev)).toEqual(e);try{yield Ee.sync(e._rev),expect(!0).toBe(!1)}catch(t){expect(t.message).toBe("Cannot read properties of undefined (reading '__cls')")}}))))})),describe("Should work for a function call on an off chain object",(()=>{class t{constructor(t){this.n=t,this._url="http://127.0.0.1:3000"}inc(t){return this.n+=t,this.n}}let e;const o=Math.random();let n=!1;beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=e||(yield be.new(t,[o])),n||(yield e.inc(1),n=!0)})))),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:expect.any(Number),_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),_url:"http://127.0.0.1:3000"})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(je(e._id)).toBe(!0),expect(je(e._rev)).toBe(!0),expect(je(e._root)).toBe(!0),expect(e._id).not.toBe(e._rev),expect(e._id).toBe(e._root)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield me.get([e._id])).toEqual([{__func:"constructor",__args:[o],__index:{obj:0},__cls:t.toString(),_url:"http://127.0.0.1:3000",_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}]),expect(yield me.get([e._rev])).toEqual([{__func:"inc",__args:[1],__index:{obj:0},_url:"http://127.0.0.1:3000",_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.sync(e._rev)).toEqual(e)}))))})),describe("Should work for a function with a smart argument",(()=>{class t{constructor(){this.n=1}}class e{constructor(){this.m=2}objInc(t){return t.n+=1,this.m+=t.n,this.m}}let o;let n;let r;let i=!1;beforeEach((()=>w(void 0,void 0,void 0,(function*(){o=o||(yield be.new(t,[])),n=n||(yield be.new(e,[])),i||(r=yield n.objInc(o),i=!0)})))),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(o).toEqual({n:2,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n).toEqual({m:4,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should return the correct value",(()=>{expect(r).toBe(4)})),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(je(o._id)).toBe(!0),expect(je(o._rev)).toBe(!0),expect(je(o._root)).toBe(!0),expect(je(n._id)).toBe(!0),expect(je(n._rev)).toBe(!0),expect(je(n._root)).toBe(!0);const t=Be(o._id);const e=Be(n._id);const r=Be(n._rev);expect(t).not.toBe(e),expect(e).not.toBe(r),expect(r).not.toBe(t),expect(o._id).toBe(`${t}/0`),expect(n._id).toBe(`${e}/0`),expect(o._rev).toBe(`${r}/0`),expect(n._rev).toBe(`${r}/1`),expect(o._root).toBe(o._id),expect(n._root).toBe(n._id)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get(o._rev)).toEqual(o),expect(yield Ne.get(n._rev)).toEqual(n)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield me.get([o._id])).toEqual([{__func:"constructor",__args:[],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}]);const r=Be(n._id);expect(yield me.get([`${r}/0`])).toEqual([{__index:{obj:0},__func:"constructor",__args:[],__cls:e.toString(),_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}]);const i=Be(n._rev);expect(yield me.get([`${i}/0`,`${i}/1`])).toEqual([{__index:{0:0,obj:1},_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT},{__func:"objInc",__args:["__"],_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.getLatestRev(o._id)).toBe(o._rev),expect(yield be.getLatestRev(n._id)).toBe(n._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.sync(o._rev)).toEqual(o),expect(yield Ee.sync(n._rev)).toEqual(n)}))))})),describe("Should work for a function that returns a dumb object",(()=>{class t{getJson(){return{n:1}}}let e;let o;let n=!1;beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=e||(yield be.new(t,[])),n||(o=o||(yield e.getJson(3)),n=!0)})))),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(o).toEqual({n:1,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(je(e._id)).toBe(!0),expect(je(e._rev)).toBe(!0),expect(je(e._root)).toBe(!0),expect(je(o._id)).toBe(!0),expect(je(o._rev)).toBe(!0),expect(je(o._root)).toBe(!0);const t=Be(e._id);const n=Be(o._id);expect(t).not.toBe(n),expect(e._id).toBe(`${t}/0`),expect(o._id).toBe(`${n}/1`),expect(e._rev).toBe(`${n}/0`),expect(o._rev).toBe(`${n}/1`),expect(e._root).toBe(e._id),expect(o._root).toBe(e._id)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get(e._rev)).toEqual(e),expect(yield Ne.get(o._rev)).toEqual(o)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield me.get([e._id])).toEqual([{__func:"constructor",__args:[],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}]);const n=Be(o._id);expect(yield me.get([`${n}/0`,`${n}/1`])).toEqual([{__index:{obj:0,res:1},__func:"getJson",__args:[3],_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT},{_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.getLatestRev(e._id)).toBe(e._rev),expect(yield be.getLatestRev(o._id)).toBe(o._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.sync(e._rev)).toEqual(e),expect(yield Ee.sync(o._rev)).toEqual(o)}))))})),describe("Should work for a function that returns a smart object",(()=>{class t{constructor(t){this.n=t}send(e){if(e>this.n)throw new Error;return this.n-=e,new t(e)}}let e;let o;let n=!1;beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=e||(yield be.new(t,[10])),n||(o=o||(yield e.send(3)),n=!0)})))),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:7,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(o).toEqual({n:3,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(je(e._id)).toBe(!0),expect(je(e._rev)).toBe(!0),expect(je(e._root)).toBe(!0),expect(je(o._id)).toBe(!0),expect(je(o._rev)).toBe(!0),expect(je(o._root)).toBe(!0);const t=Be(e._id);const n=Be(o._id);expect(t).not.toBe(n),expect(e._id).toBe(`${t}/0`),expect(o._id).toBe(`${n}/1`),expect(e._rev).toBe(`${n}/0`),expect(o._rev).toBe(`${n}/1`),expect(e._root).toBe(e._id),expect(o._root).toBe(e._id)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get(e._rev)).toEqual(e),expect(yield Ne.get(o._rev)).toEqual(o)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield me.get([e._id])).toEqual([{__func:"constructor",__args:[10],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}]);const n=Be(o._id);expect(yield me.get([`${n}/0`,`${n}/1`])).toEqual([{__index:{obj:0,res:1},__func:"send",__args:[3],_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT},{__cls:t.toString(),_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.getLatestRev(e._id)).toBe(e._rev),expect(yield be.getLatestRev(o._id)).toBe(o._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.sync(e._rev)).toEqual(e),expect(yield Ee.sync(o._rev)).toEqual(o)}))))})),describe("Should work for a function that updates a nested object",(()=>{class t{constructor(){this.a={aa:1},this.b={bb:2}}update(){this.b.bb=3}}let e;let o=!1;beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=e||(yield be.new(t,[])),o||(yield e.update(),o=!0)})))),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({a:{aa:1,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)},b:{bb:3,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)},_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(je(e._id)).toBe(!0),expect(je(e._rev)).toBe(!0),expect(je(e._root)).toBe(!0),expect(je(e.a._id)).toBe(!0),expect(je(e.a._rev)).toBe(!0),expect(je(e.a._root)).toBe(!0),expect(je(e.b._id)).toBe(!0),expect(je(e.b._rev)).toBe(!0),expect(je(e.b._root)).toBe(!0);const t=Be(e._id);expect(e._id).toBe(`${t}/0`),expect(e.a._id).toBe(`${t}/1`),expect(e.b._id).toBe(`${t}/2`),expect(e._root).toBe(e._id),expect(e.a._root).toBe(e._id),expect(e.b._root).toBe(e._id)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield me.get([e._id,e.a._id,e.b._id])).toEqual([{__func:"constructor",__args:[],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT,a:1,b:2},{_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT},{_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}]),expect(yield me.get([e._rev,e.a._rev,e.b._rev])).toEqual([{b:1,__index:{obj:0},__func:"update",__args:[],_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT},{_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT},{_owners:[expect.any(String)],_amount:ue.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.sync(e._rev)).toEqual(e)}))))})),describe("Should work for a function that returns an array",(()=>{class t{constructor(){this.aa=1}createArray(){return this.a=new t,[new t,new t]}}let e;let o;let n;let r=!1;beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=e||(yield be.new(t,[])),r||([o,n]=yield e.createArray(),r=!0)})))),it("Should return an array",(()=>w(void 0,void 0,void 0,(function*(){expect(o).toEqual({aa:1,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n).toEqual({aa:1,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})}))))})),describe("Should work for a function that returns an object created by a property wrapped as object",(()=>{class t{f(){return new t}}class e{constructor(t){this.a=t}g(){return this.a.f()}o(){return{o:this.a.f()}}}let o;let n;let r;let i;let c=!1;beforeEach((()=>w(void 0,void 0,void 0,(function*(){o=o||(yield be.new(t,[])),r=r||(yield be.new(e,[o])),c||(yield Bt(2e3),n=yield r.g(),yield Bt(2e3),({o:i}=yield r.o()),c=!0)})))),it("Should return the object",(()=>w(void 0,void 0,void 0,(function*(){expect(o).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(i).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(r).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),a:{_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}})}))))})),describe("Should work for a function that returns an object created by a property wrapped in an array",(()=>{class t{f(){return new t}}class e{constructor(t){this.a=t}g(){return this.a.f()}o(){return[this.a.f()]}}let o;let n;let r;let i;let c=!1;beforeEach((()=>w(void 0,void 0,void 0,(function*(){o=o||(yield be.new(t,[])),r=r||(yield be.new(e,[o])),c||(yield Bt(2e3),n=yield r.g(),yield Bt(2e3),[i]=yield r.o(),c=!0)})))),it("Should return the object",(()=>w(void 0,void 0,void 0,(function*(){expect(o).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(i).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(r).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),a:{_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}})}))))})),describe("Should work for a function that returns multiple objects created by a property wrapped in an array",(()=>{class t{f(){return new t}}class e{constructor(t){this.a=t}g(){return this.a.f()}o(){return[this.a.f(),this.a.f()]}}let o;let n;let r;let i;let c;let s=!1;beforeEach((()=>w(void 0,void 0,void 0,(function*(){o=o||(yield be.new(t,[])),r=r||(yield be.new(e,[o])),s||(yield Bt(2e3),n=yield r.g(),yield Bt(2e3),[i,c]=yield r.o(),s=!0)})))),it("Should return the object",(()=>w(void 0,void 0,void 0,(function*(){expect(o).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(i).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(c).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(r).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),a:{_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}})}))))})),describe("Should work for a function that returns multiple objects created by a property",(()=>{class t{f(){return new t}}class e{constructor(t){this.a=t}g(){return this.a.f()}o(){return this.a.f()}}let o;let n;let r;let i;let c=!1;beforeEach((()=>w(void 0,void 0,void 0,(function*(){o=o||(yield be.new(t,[])),r=r||(yield be.new(e,[o])),c||(n=yield r.g(),i=yield r.o(),c=!0)})))),it("Should return the object",(()=>w(void 0,void 0,void 0,(function*(){expect(o).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(i).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(r).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),a:{_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}})}))))})),describe("Should work for a function that returns an object created by a property",(()=>{class t{f(){return new t}}class e{constructor(t){this.a=t}g(){return this.a.f()}}let o;let n;let r;let i=!1;beforeEach((()=>w(void 0,void 0,void 0,(function*(){o=o||(yield be.new(t,[])),r=r||(yield be.new(e,[o])),i||(n=yield r.g(),i=!0)})))),it("Should return the object",(()=>w(void 0,void 0,void 0,(function*(){expect(o).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(r).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),a:{_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}})}))))})),describe("Should work when setting an owner",(()=>{class t{constructor(t){this._owners=[t]}updateOwner(t){this._owners=[t]}}let e;const o=new Gt({chain:ue.CHAIN,network:ue.NETWORK,path:""});const n=be.db.wallet.getPublicKey().toString();const r=o.db.wallet.getPublicKey().toString();let i=!1;beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=e||(yield be.new(t,[n])),i||(yield e.updateOwner(r),i=!0)}))),6e4),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),_owners:[r]})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){const t=Be(e._id);expect(e._id).toBe(`${t}/0`)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){const[o]=yield me.get([e._id]);expect(o).toEqual({__func:"constructor",__args:[n],__index:{obj:0},__cls:t.toString(),_amount:ue.MIN_NON_DUST_AMOUNT,_owners:[n]});const[i]=yield me.get([e._rev]);expect(i).toEqual({__func:"updateOwner",__args:[r],__index:{obj:0},_owners:[r],_amount:ue.MIN_NON_DUST_AMOUNT})})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield be.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with getRevs",(()=>w(void 0,void 0,void 0,(function*(){expect((yield o.getRevs()).length).toBe(1)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield o.sync(e._rev)).toEqual(e)}))))})),describe("Should work with multiple computers",(()=>{class t{constructor(){this.n=1}inc(){this.n+=1}}let e=null;let o=null;beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=yield be.new(t,[]),yield Bt(2e3),o=yield Ee.new(t,[]),yield Bt(2e3),yield e.inc(),yield Bt(2e3)})))),it("should work",(()=>{expect(e).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),n:2}),expect(o).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),n:1})}))}))})),describe("sync",(()=>{class t{constructor(t,e){this.n=t,this._owners=[e]}}let e;const o=Math.random();const n=be.db.wallet.getPublicKey().toString();beforeEach((()=>w(void 0,void 0,void 0,(function*(){e=e||(yield be.new(t,[o,n]))})))),it("Should create another instance of the same smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:o,_owners:[n],_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)});const t=xe();const r=yield t.sync(e._rev);expect(r).toEqual(e)})))),it("throw an error if no params are passed to sync function",(()=>w(void 0,void 0,void 0,(function*(){const t=xe();try{yield t.sync(),expect(!0).toBe(!1)}catch(t){if(!(t instanceof Error))throw new Error("Unknown error");expect(t.message).toBe("Invalid outId: undefined")}})))),it("throw an error if rev is not in the right format: tdId:num",(()=>w(void 0,void 0,void 0,(function*(){const t=xe();try{yield t.sync("123"),expect(!0).toBe(!1)}catch(t){if(!(t instanceof Error))throw new Error("Unknown error");expect(t.message).toBe("Invalid outId: 123")}})))),it("throw an error if trId in rev is not 64 hex characters",(()=>w(void 0,void 0,void 0,(function*(){const t=xe();try{yield t.sync("123:0"),expect(!0).toBe(!1)}catch(t){if(!(t instanceof Error))throw new Error("Unknown error");expect(t.message).toBe("Invalid outId: 123:0")}})))),it("throw an error if trId in rev is contains non hex characters",(()=>w(void 0,void 0,void 0,(function*(){const t=xe();try{yield t.sync("31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844g:0"),expect(!0).toBe(!1)}catch(t){if(!(t instanceof Error))throw new Error("Unknown error");expect(t.message).toBe("Invalid outId: 31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844g:0")}})))),it("throw an error if num in rev is not a number",(()=>w(void 0,void 0,void 0,(function*(){const t=xe();try{yield t.sync("31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844f:abc"),expect(!0).toBe(!1)}catch(t){if(!(t instanceof Error))throw new Error("Unknown error");expect(t.message).toBe("Invalid outId: 31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844f:abc")}}))))}))}));
