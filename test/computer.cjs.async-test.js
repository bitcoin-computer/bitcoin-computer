"use strict";var e=require("bitcoin-computer-bitcore");var t=require("chai");var o=require("axios");require("child_process");var n=require("crypto");var r=require("crypto-js");var i=require("eciesjs");var c=require("@endo/static-module-record");var s=require("util");var a=require("url");var d=require("fs/promises");require("ses");var u=require("exponential-backoff");var l=require("http");var p=require("https");function h(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function v(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(o){if("default"!==o){var n=Object.getOwnPropertyDescriptor(e,o);Object.defineProperty(t,o,n.get?n:{enumerable:!0,get:function(){return e[o]}})}})),t.default=e,Object.freeze(t)}var y=h(o);var g=h(n);var _=h(r);var f=v(i);var b=h(s);var w=h(a);var m=h(l);var k=h(p);function x(e,t){var o={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(o[n]=e[n]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(n=Object.getOwnPropertySymbols(e);r<n.length;r++)t.indexOf(n[r])<0&&Object.prototype.propertyIsEnumerable.call(e,n[r])&&(o[n[r]]=e[n[r]])}return o}function S(e,t,o,n){return new(o||(o=Promise))((function(r,i){function c(e){try{a(n.next(e))}catch(e){i(e)}}function s(e){try{a(n.throw(e))}catch(e){i(e)}}function a(e){var t;e.done?r(e.value):(t=e.value,t instanceof o?t:new o((function(e){e(t)}))).then(c,s)}a((n=n.apply(e,t||[])).next())}))}const{CHAIN:j,NETWORK:q,BCN_URL:O,RPC_USER:C,RPC_PASSWORD:B,TEST_MNEMONICS:T}=process.env;const R=j||"LTC";const $=q||"testnet";const A=O||"https://node.bitcoincomputer.io";const E=T||"travel upgrade inside soda birth essence junk merit never twenty system opinion;toddler hockey salute wheel harvest video narrow riot guitar lake sea call;cannon hour begin test replace fury motion squirrel envelope announce neck culture";const I=parseInt(process.env.BC_DUST_LIMIT||"",10)||("LTC"===R?15460:1546);const{crypto:P}=e.Bitcoin;const L=(e,t)=>{const o=Date.now();const n=P.Hash.sha256(Buffer.from(t+o));const r=[P.ECDSA.sign(n,e,"big").toString("hex"),e.publicKey.toString(),o];return`Bearer ${Buffer.from(r.join(":")).toString("base64")}`};class K{constructor(t=A,o=new e.Bitcoin.PrivateKey,n={}){this.baseUrl=t,this.headers=n,this.privateKey=o}get(e){return S(this,void 0,void 0,(function*(){const t=this.privateKey?{Authentication:L(this.privateKey,this.baseUrl)}:{};return(yield y.default.get(`${this.baseUrl}${e}`,{headers:Object.assign(Object.assign({},this.headers),t)})).data}))}post(e,t){return S(this,void 0,void 0,(function*(){const o=this.privateKey?{Authentication:L(this.privateKey,this.baseUrl)}:{};return(yield y.default.post(`${this.baseUrl}${e}`,t,{headers:Object.assign(Object.assign({},this.headers),o)})).data}))}delete(e){return S(this,void 0,void 0,(function*(){const t=this.privateKey?{Authentication:L(this.privateKey,this.baseUrl)}:{};return(yield y.default.delete(`${this.baseUrl}${e}`,{headers:Object.assign(Object.assign({},this.headers),t)})).data}))}}parseInt(process.env.BC_DEFAULT_FEE||"",10),parseInt(process.env.BC_SCRIPT_CHUNK_SIZE||"",10),parseInt(process.env.MWEB_HEIGHT||"",10);const{PublicKey:U,Mnemonic:N,crypto:M}=e.Bitcoin;const{Point:H}=M;function D(e){return Buffer.from(e,"hex").toString().replace(/\0/g,"")}function F(e,t){return e.slice(t)+e.slice(0,t)}function W(e,t,o){if(e.length*Math.log2(t)>53)throw new Error(`Input too large ${e.length} ${Math.log2(t)}`);if(![2,10,16].includes(t)||![2,10,16].includes(o))throw new Error("ToBase or FromBase invalid in covertNumber.");if(2===t&&e.length%8!=0)throw new Error("Binary strings must be byte aligned.");if(16===t&&e.length%2!=0)throw new Error("Hex strings must be of even length.");const n=parseInt(e,t).toString(o);return 2===o?n.padStart(8*Math.ceil(n.length/8),"0"):16===o?n.padStart(2*Math.ceil(n.length/2),"0"):n}function z(e,t){const o=new RegExp(`.{1,${t}}`,"g");return e.match(o)||[]}function J(e){return z(e,2).map((e=>W(e,16,2))).join("")}function G(e){return z(e,8).map((e=>W(e,2,16))).join("")}function Y(e){return e.toString(16).padStart(3,"0")}function Z(e){return parseInt(e,16)}function Q(e){if(62!==e.length)throw new Error("Input to hexToPublicKey must be of length 62");let t=!1;let o=0;let n;for(;!t;){if(o>=256)throw new Error("Something went wrong storing data");const r=o.toString(16).padStart(2,"0")+G(F(J(e).padStart(64,"0"),o));try{n=H.fromX(!1,r),t=!0}catch(e){o+=1}}if(!n)throw new Error("Something went wrong storing data");return new U(n)}function V(e){const t=e.point.getX().toString("hex").padStart(64,"0");const o=W(t.slice(0,2),16,10);return G((r=parseInt(o,10),(n=J(t.slice(2))).slice(-r)+n.slice(0,-r)));var n,r}function X(e){return new Promise((t=>{setTimeout(t,e)}))}function ee(e=R,t=$){if("testnet"===t||"regtest"===t)return 1;if("BTC"===e)return 0;if("LTC"===e)return 2;if("DOGE"===e)return 3;if("BCH"===e)return 145;if("BSV"===e)return 236;throw new Error(`Unsupported chain ${e}`)}function te({purpose:e=44,coinType:t=2,account:o=0}={}){return`m/${e.toString()}'/${t.toString()}'/${o.toString()}'`}function oe({chain:e=R,network:t=$}={}){return te({coinType:ee(e,t)})}function ne(){return Math.round(Math.random()*Math.pow(2,31))}function re({chain:e=R,network:t=$,account:o=ne()}={}){return te({account:o,coinType:ee(e,t)})}function ie(e,t){const o=function(e,t){return((e,t,o={})=>{const{path:n="m/44'/0'/0'/0",passphrase:r=""}=o;let i=e.toHDPrivateKey(r,t);return n&&(i=i.derive(n)),i.privateKey})(new N("replace this seed"),t,{path:oe({chain:e,network:t}),passphrase:""})}(e,t);return U.fromPrivateKey(o)}function ce({mnemonic:e=new N,path:t=oe(),passphrase:o="",network:n=$}){return e.toHDPrivateKey(o,n).deriveChild(t)}function se(e){return{smartArgs:e.filter((e=>e._rev)),dumbArgs:e.map((e=>e._rev?"__":e))}}function ae(e){return/^[0-9A-Fa-f]{64}\/\d+$/.test(e)}function de(e){if(!/^[0-9A-Fa-f]{64}$/.test(e))throw new Error(`Invalid txId: ${e}`)}function ue(e){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(e))throw new Error(`Invalid outId: ${e}`)}function le(e){ue(e);const[t,o]=e.split("/");return{txId:t,outputIndex:parseInt(o,10)}}const pe=e=>e.startsWith("./")||e.startsWith("../")||"."===e||".."===e;const{Transaction:he,Mnemonic:ve}=e.Bitcoin;const{UnspentOutput:ye}=he;class ge{constructor({chain:e,network:t,mnemonic:o,path:n,passphrase:r,url:i}={}){if(this.chain=e?e.toUpperCase():R,this.network=t?t.toLowerCase():$,this.mnemonic=new ve(o?o.toString():void 0),this.path=n||oe({chain:this.chain,network:this.network}),this.passphrase=r||"",this.bcn=new K(i,this.privateKey),!["LTC","BTC"].includes(this.chain))throw new Error("We currently only support LTC, support for other currencies will be added soon.");if(!["mainnet","testnet","regtest"].includes(this.network))throw new Error("Please set 'network' to 'regtest', 'testnet', or 'mainnet'")}get privateKey(){return ce(this).privateKey}getBalance(e){return S(this,void 0,void 0,(function*(){const{chain:t,network:o}=this;return yield this.bcn.get(`/v1/${t}/${o}/address/${e}/balance`)}))}getTransactions(e){return S(this,void 0,void 0,(function*(){return(yield this.getRawTxs(e)).map((e=>new he(e)))}))}getRawTxs(e){return S(this,void 0,void 0,(function*(){e.map(de);const{chain:t,network:o}=this;return this.bcn.post(`/v1/${t}/${o}/tx/bulk/`,{txIds:e})}))}sendTransaction(e){return S(this,void 0,void 0,(function*(){return this.bcn.post(`/v1/${this.chain}/${this.network}/tx/send`,{rawTx:e})}))}getUtxosByAddress(e){return S(this,void 0,void 0,(function*(){const{chain:t,network:o}=this;return(yield this.bcn.get(`/v1/${t}/${o}/wallet/${e.toString()}/utxos`)).map((({rev:e,scriptPubKey:t,satoshis:o})=>{const[n,r]=e.split("/");return new ye({txId:n,outputIndex:parseInt(r,10),satoshis:o,script:t})}))}))}query({publicKey:e,classHash:t}){return S(this,void 0,void 0,(function*(){if(void 0===e&&void 0===t)throw new Error("Query parameters cannot be empty.");let o="";e&&(o+=`?publicKey=${e}`),t&&(o+=0===o.length?"?":"&",o+=`classHash=${t}`);const{chain:n,network:r}=this;return this.bcn.get(`/v1/${n}/${r}/non-standard-utxos${o}`)}))}idsToRevs(e){return S(this,void 0,void 0,(function*(){e.map(ue);const{chain:t,network:o}=this;return this.bcn.post(`/v1/${t}/${o}/revs`,{ids:e})}))}rpc(e,t){return S(this,void 0,void 0,(function*(){return this.bcn.post(`/v1/${this.chain}/${this.network}/rpc`,{method:e,params:t})}))}static getSecretOutput({_url:e,privateKey:t}){return S(this,void 0,void 0,(function*(){const o=e.split("/");const n=o[o.length-1];const r=o.slice(0,-2).join("/");const i=new K(r,t);return{host:r,data:yield i.get(`/v1/store/${n}`)}}))}static setSecretOutput({secretOutput:e,host:t,privateKey:o}){return S(this,void 0,void 0,(function*(){return new K(t,o).post("/v1/store/",e)}))}static deleteSecretOutput({_url:e,privateKey:t}){return S(this,void 0,void 0,(function*(){const o=e.split("/");const n=o[o.length-1];const r=o.slice(0,-2).join("/");const i=new K(r,t);yield i.delete(`/v1/store/${n}`)}))}get url(){return this.bcn.baseUrl}}const{PublicKey:_e,Script:fe}=e.Bitcoin;function be(e,t,o,n){if(e.length>3)throw new Error("Too many owners");return function(e,t,o,n){const r=n?[...e,ie(t,o).toBuffer()]:e;const i=new fe;return i.add("OP_1"),r.forEach((e=>{i.add(e)})),i.add(`OP_${r.length}`),i.add("OP_CHECKMULTISIG"),i}(e.map((e=>e.toBuffer())),t,o,n)}function we(e,t){return function(e,t){const o=e.chunks.filter((e=>e.buf));return(t?o.slice(0,-1):o).map((e=>e.buf))}(e,t).map((e=>_e.fromBuffer(e)))}function me(e){return Buffer.from(_.default.SHA256(e).toString(),"hex").toString("hex").substr(0,4)}function ke(e){return`${me(e)};${e}`}function xe(e){const t=e.substr(0,4);const o=e.substr(5);if(!function(e,t){return me(e)===t}(o,t))throw new Error("Decryption failure");return o}function Se(e){if(void 0!==e._readers){const{_readers:t,_url:o,_owners:n,_amount:r}=e,i=x(e,["_readers","_url","_owners","_amount"]);const c=function(e,t){const o=g.default.randomBytes(32).toString("hex");const n=function(e,t){if(!/^[0-9a-f]{64}$/.test(t))throw new Error("Invalid secret");const o=Buffer.from(t,"hex").toString("binary");const n=ke(e);return _.default.AES.encrypt(n,o).toString()}(e,o);const r=t.map((e=>function(e,t){if(!/^0[2-3][0-9a-f]{64}|04[0-9a-f]{128}$/.test(t))throw new Error("Invalid publicKey");const o=ke(e);return f.encrypt(t,Buffer.from(o,"utf8")).toString("base64")}(o,e)));return{__cypher:n,__secrets:r}}(JSON.stringify(i),t);return void 0!==o&&(c._url=o),void 0!==n&&(c._owners=n),void 0!==r&&(c._amount=r),c}return e}const{Transaction:je}=e.Bitcoin;const{Output:qe,UnspentOutput:Oe}=je;class Ce{constructor({restClient:e=new ge}={}){this.tx=new je,this.tx.feePerKb(2e4),this.outData=[],this.restClient=e}get txId(){return this.tx.id}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get inputs(){return this.tx.inputs.map((e=>`${e.prevTxId.toString("hex")}/${e.outputIndex}`))}get inRevs(){const{enc:e}=this;let[t]=e;return t=Number.isFinite(t)?t:0,this.tx.inputs.slice(0,t).map((({prevTxId:e,outputIndex:t})=>`${e.toString("hex")}/${t}`))}get outRevs(){const{enc:e}=this;let[,t]=e;return t=Number.isFinite(t)?t:0,Array.from(Array(t).keys()).map((e=>`${this.tx.id}/${e}`))}get opReturns(){try{const{outputs:e}=this.tx;return e.filter((({script:e})=>e.isDataOut())).map((({script:e})=>e.getData())).map((e=>e.toString())).join()}catch(e){return""}}get enc(){return z(this.opReturns.slice(0,9),3).map(Z)}get dataPrefix(){return this.opReturns.slice(9)}isFullyFunded(){return this.tx._getInputAmount()-this.tx._getOutputAmount()>=this.tx.getFee()}getOwnerOutputs(){const{enc:e}=this;const[,t=0]=e;return this.tx.outputs.slice(0,t)}getDataOutputs(){const{enc:e}=this;const[,t,o]=e;return this.tx.outputs.slice(t,o)}getOutData(){return S(this,void 0,void 0,(function*(){try{const e=this.getDataOutputs().map((e=>e.script)).map((e=>we(e,!0))).flat().map(V).map(D).join("");const{dataPrefix:t}=this;const o=JSON.parse(t+e);const n=this.restClient.privateKey.toBuffer().toString("hex");const r=this.getOwnerOutputs();if(r.length!==o.length)throw new Error("Inconsistent state");const i=r.map(((e,t)=>Object.assign(Object.assign({},o[t]),{_owners:we(e.script,!1).map((e=>e.toString())),_amount:e.satoshis})));return Promise.all(i.map((e=>S(this,void 0,void 0,(function*(){try{const t=yield function(e){return t=>S(this,void 0,void 0,(function*(){if(function(e){return void 0!==e._url}(t)){const{_url:o}=t,n=x(t,["_url"]);const{host:r,data:i}=yield ge.getSecretOutput({_url:o,privateKey:e});return Object.assign(Object.assign(Object.assign({},n),JSON.parse(i)),{_url:r})}return t}))}(this.restClient.privateKey)(e);return function(e,t){if(function(e){return void 0!==e.__cypher&&void 0!==e.__secrets}(e)){const{__cypher:o,__secrets:n}=e,r=x(e,["__cypher","__secrets"]);return Object.assign(Object.assign(Object.assign({},r),JSON.parse(function({__cypher:e,__secrets:t},o){let n="";if(o.forEach((o=>{t.forEach((t=>{try{const r=function(e,t){if(!/^[0-9a-f]{64}$/.test(t))throw new Error("Invalid privateKey");return xe(f.decrypt(t,Buffer.from(e,"base64")).toString("utf8"))}(t,o);n=function(e,t){if(!/^[0-9a-f]{64}$/.test(t))throw new Error("Invalid secret");const o=Buffer.from(t,"hex").toString("binary");return xe(_.default.AES.decrypt(e,o).toString(_.default.enc.Utf8))}(e,r)}catch(e){const t=["Decryption failure","Unsupported state or unable to authenticate data"];if(e instanceof Error&&!t.includes(e.message))throw e}}))})),n)return n;throw new Error("Decryption failure")}({__cypher:o,__secrets:n},t))),{_readers:[]})}return e}(t,[n])}catch(e){return null}})))))}catch(e){return[]}}))}getOwners(){return this.getOwnerOutputs().map((e=>we(e.script,!1).map((e=>e.toString()))))}getAmounts(){return this.getOwnerOutputs().map((e=>e.satoshis))}spendFromData(t){return S(this,void 0,void 0,(function*(){if(!t.length)return;const o=t.map(le);const n=o.map((e=>e.txId));const r=yield this.restClient.getTransactions(n);for(let t=0;t<o.length;t+=1){const{txId:n,outputIndex:i}=o[t];const{outputs:c}=r[t];const s=c[i];const a=Math.round(s.satoshis);const d=new e.Bitcoin.Script(s.script);const u=new Oe({txId:n,outputIndex:i,satoshis:a,script:d});const l=we(d,!1).map((e=>e.toString()));this.tx.from([u],l,1)}}))}createDataOuts(t){t.forEach((({_amount:t,_owners:o=[]})=>{if(Array.isArray(o)&&o.length>3)throw new Error("Too many owners.");const n=o.map((t=>e.Bitcoin.PublicKey.fromString(t)));const r=t||I;const i=be(n,this.chain,this.network,!1);this.tx.addOutput(new qe({script:i,satoshis:r}))}));const o=t.map((e=>x(e,["_amount","_owners"])));const n=I;const r=JSON.stringify(o);const i=r.slice(0,71);const c=function(e,t,o,n){var r;return function(e,t){const o=[];for(let t=0;t<e.length;t+=2)o.push(e.slice(t,t+2));return o}(z((r=e,Buffer.from(r).toString("hex")),62).map((e=>e.padStart(62,"0"))).map(Q)).map((e=>be(e,t,o,!0)))}(r.slice(71),this.chain,this.network);const s=Y(this.tx.inputs.length)+Y(this.tx.outputs.length)+Y(this.tx.outputs.length+c.length);c.forEach((e=>{this.tx.addOutput(new qe({script:e,satoshis:n}))})),this.tx.addData(s+i)}static fromTxHex({hex:e="",restClient:t=new ge}){return S(this,void 0,void 0,(function*(){let o=[];let n=[];let r=[];const i=new this({restClient:t});i.tx.fromString(e);try{o=yield i.getOutData()}catch(e){}try{n=i.getOwners()}catch(e){}try{r=i.getAmounts()}catch(e){}return i.outData=o.map(((e,t)=>Object.assign(Object.assign({},e),{_owners:n[t],_amount:r[t]}))),i}))}static fromTxId({txId:e="",restClient:t=new ge}){return S(this,void 0,void 0,(function*(){const[o]=yield t.getRawTxs([e]);return this.fromTxHex({hex:o,restClient:t})}))}}class Be{constructor(e={}){this.restClient=new ge(e)}derive(e="0"){const t=`${this.path}${this.path.length>0?"/":""}${e}`;const{chain:o,network:n,url:r,mnemonic:i,passphrase:c}=this.restClient;return new Be({chain:o,network:n,url:r,mnemonic:i.toString(),path:t,passphrase:c})}getBalance(){return S(this,void 0,void 0,(function*(){return this.restClient.getBalance(this.address)}))}getUtxosByAmount(e){return S(this,void 0,void 0,(function*(){const t=yield this.restClient.getUtxosByAddress(this.address);let o=0;const n=[];!function(e){const t=e;for(let e=t.length-1;e>0;e-=1){const o=Math.floor(Math.random()*(e+1));[t[e],t[o]]=[t[o],t[e]]}}(t);for(const r of t)if(o+=r.satoshis,n.push(r),o>=e)return n;const{network:r,chain:i}=this.restClient;const c=this.address.toString();throw new Error(`Insufficient balance in address ${c} on ${r} ${i}. Found ${o}, required ${e}.`)}))}fundAndSendTx(t){return S(this,void 0,void 0,(function*(){t.tx.feePerKb(4e4);const o=t.tx.outputs.length;const{chain:n,network:r}=this.restClient;t.tx.to(function(e,t){const o={"any-testnet":"uTKUDCkpo12vstJBsMWmrTPz9wFE6DuzGH","BTC-mainnet":"igpnnoLziUyxtQuWYCP13gHYVhUru6iLaY","LTC-mainnet":"t77o829ngHnuUorwDkf129fL6ERLFNqKG8","DOGE-mainnet":"XfNRUdvrv6uCDbCF5xJ18UYwVkkefkXvEd","BCH-mainnet":"CSAkkS8Mro9mYRqhksS1FyYrsnSE5MVQ5m"};return F("testnet"===t||"regtest"===t?o["any-testnet"]:o[`${e}-${t}`],19)}(n,r),0);const i=yield this.restClient.getUtxosByAddress(this.address);if(t.tx.change(this.address),0===i.length)throw new Error(`Insufficient balance in address ${this.address}.`);let c=0;let s=0;let a=0;do{const[o]=i.splice(0,1);t.tx.from([new e.Bitcoin.Transaction.UnspentOutput(o)]),t.tx.sign(this.privateKey,1),s=t.tx.toString().length,t.tx.fee(2e4*s*2),t.tx._updateChangeOutput(),a=t.tx._getInputAmount()-t.tx._getOutputAmount(),c=a/s*1e3}while(0!==i.length&&c<4e4);if(c<4e4&&0===i.length)throw new Error(`Insufficient balance in address ${this.address}. Current fee_per_kb ${c}. Fee ${a}. Utxo set size ${i.length}. CTransaction size ${s} Inputs ${JSON.stringify(t.tx.inputs,null,2)} Outpus ${JSON.stringify(t.tx.outputs,null,2)}`);if(s=t.tx.toString().length,a=Math.max(Math.ceil(s/1e3*2e4),I),t.tx.fee(a),t.tx.outputs[o].satoshis=a,t.tx._outputAmount=void 0,t.tx.feePerKb(2e4),t.tx._outputAmount=void 0,t.tx._updateChangeOutput(),!1===t.isFullyFunded()||!1===t.tx.verify())throw new Error(`Something went wrong. Address ${this.address}. Transaction: ${JSON.stringify(t.tx,null,2)}`);return t.tx.sign(this.privateKey,1),this.restClient.sendTransaction(t.tx.toString())}))}send(e,t){return S(this,void 0,void 0,(function*(){const{restClient:o}=this;const n=new Ce({restClient:o});return n.tx.to(t,e),this.fundAndSendTx(n)}))}get hdPrivateKey(){return ce(this.restClient)}get privateKey(){return this.hdPrivateKey.privateKey}get publicKey(){return this.hdPrivateKey.publicKey}get passphrase(){return this.restClient.passphrase}get path(){return this.restClient.path}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get url(){return this.restClient.url}get mnemonic(){return this.restClient.mnemonic}get address(){return this.publicKey.toAddress(this.restClient.network)}}class Te{constructor(e={}){this.wallet=new Be(e)}fromTxHex(e){return S(this,void 0,void 0,(function*(){const{restClient:t}=this.wallet;return Ce.fromTxHex({hex:e,restClient:t})}))}fromTxId(e){return S(this,void 0,void 0,(function*(){const[t]=yield this.wallet.restClient.getRawTxs([e]);return this.fromTxHex(t)}))}get(e){return S(this,void 0,void 0,(function*(){const t=e.map(le);return Promise.all(t.map((({txId:e,outputIndex:t})=>S(this,void 0,void 0,(function*(){const{outData:o}=yield this.fromTxId(e);if(t>o.length)throw new Error("Index out of bounds");return o[t]})))))}))}put(e){return this.update([],e)}createTx(e,t){return S(this,void 0,void 0,(function*(){const{wallet:o}=this;const{restClient:n}=o;const r=new Ce({restClient:n});const{privateKey:i,publicKey:c}=o;const s=t.map((e=>{var{_owners:t}=e,o=x(e,["_owners"]);return Object.assign({_owners:t||[c.toString()]},o)})).map(Se);const a=yield Promise.all(s.map(function(e){return t=>S(this,void 0,void 0,(function*(){if(void 0!==t._url){const{_url:o,_owners:n,_amount:r}=t,i=x(t,["_url","_owners","_amount"]);const c=yield ge.setSecretOutput({host:o,secretOutput:{data:JSON.stringify(i)},privateKey:e});return void 0!==n&&(c._owners=n),void 0!==r&&(c._amount=r),c}return t}))}(i)));return yield r.spendFromData(e),yield r.createDataOuts(a),r}))}update(e,t){return S(this,void 0,void 0,(function*(){const o=yield this.createTx(e,t);return yield this.wallet.fundAndSendTx(o),o.outRevs}))}}const Re=["_id","_rev","_owners","_amount","_readers","_url","__vouts","__func","__index","__args"];const $e=e=>(Object.prototype.toString.call(e).match(/\s([a-zA-Z]+)/)||[])[1];const Ae=e=>"object"==typeof e?$e(e):$e(e).toLowerCase();const Ee=e=>["number","string","boolean","undefined","Null"].includes(Ae(e));const Ie=e=>"Array"===Ae(e);const Pe=e=>"Object"===Ae(e);const Le=e=>Ee(e)||["Array","Object"].includes(Ae(e));const Ke=(e,t)=>{if(!Le(e)||!Le(t))throw new Error(`Unsupported data types for deep equals: ${Ae(e)} & ${Ae(t)}`);if(Ae(e)!==Ae(t))return!1;if(Ee(e)&&Ee(t))return e===t;const o=(e,t)=>Object.entries(e).every((([e,o])=>Ke(t[e],o)));return e&&t&&o(e,t)&&o(t,e)};const Ue=e=>{if(Ee(e))return e;if(Ie(e))return e.map(Ue);if(Pe(e)){const t=Object.keys(e).reduce(((t,o)=>(t[o]=Ue(e[o]),t)),{});const o=Object.create(Object.getPrototypeOf(e));return Object.assign(o,t)}throw new Error(`Unsupported data type for clone: ${Ae(e)}`)};const Ne=(e,t)=>Object.fromEntries(Object.entries(e).map((e=>t(e))));const Me=(e,t)=>Ne(e,(([e,o])=>[e,t(o)]));const He=(e,t)=>Object.fromEntries(Object.entries(e).filter((e=>t(e))));const De=(e,t,o,n)=>{if(Ee(e))return e;if(Ie(e))return e.map((e=>De(e,t,o,n)));if(Pe(e)){e._rev=`${n}/${o}`;const r=t[o];return Object.entries(e).forEach((([o,i])=>{"object"==typeof r&&Object.keys(r).includes(o)&&(e[o]=De(i,t,r[o],n))})),e}throw new Error(`Unsupported type ${Ae(e)} in deep.updateRev`)};const Fe=(e,t)=>{if(Ee(e))return e;if(Ie(e))return e.map((e=>Fe(e,t)));if(Pe(e))return e._id=!e._id||e._id.startsWith("__temp__")?e._rev:e._id,e._root=e._root||t,Object.entries(e).forEach((([o,n])=>{e[o]=Fe(n,t)})),e;throw new Error(`Unsupported type ${Ae(e)} in deep.addId`)};const We=e=>{if(Ee(e))return e;if(Ie(e))return e.map((e=>We(e)));if(Pe(e)){const t=`__temp__/${Math.random()}`;return e._id=e._id||t,e._rev=e._rev||t,Object.values(e).map((e=>We(e))),e}throw new Error(`Unsupported type ${Ae(e)} in addRandomId`)};const ze=e=>{if(Ee(e))return e;if(Ie(e))return e.map((e=>ze(e)));if(Pe(e))return Ne(e,(([e,t])=>["_owners","_readers"].includes(e)?[e,JSON.stringify(t)]:Ee(t)?[e,t]:[e,ze(t)]));throw new Error(`Unexpected type ${Ae(e)} in stringifyOwners`)};const Je=e=>(e._owners&&(e._owners=JSON.parse(e._owners)),e._readers&&(e._readers=JSON.parse(e._readers)),e);const Ge=e=>{if(Ee(e))return e;if(Ie(e)||Pe(e))return Object.entries(e).reduce(((e,[t,o])=>{const n=Ge(o);return(e=>"Object"===Ae(e)&&Object.keys(e).every((e=>!Number.isNaN(parseInt(e,10)))))(n)?Object.entries(n).forEach((([o,n])=>{e[`${t}_${o}`]=n})):e[t]=n,e}),{});throw new Error(`Unsupported type ${Ae(e)} in encodeArraysAsObjects`)};const Ye=e=>{const t={[e._id]:Object.entries(e).reduce(((e,[t,o])=>Re.includes(t)?Object.assign(Object.assign({},e),{[t]:o}):Ee(o)?Object.assign(Object.assign({},e),{[`__basic__${t}`]:o}):Object.assign(Object.assign({},e),{[t]:o._id})),{})};return Object.values(e).filter((e=>!Ee(e))).reduce(((e,t)=>Object.assign(Object.assign({},e),Ye(t))),t)};const Ze=e=>He(e,(([e])=>!e.startsWith("__basic__")));const Qe=(e,t)=>{const o=e[t];return o.__contains=Object.entries(o).reduce(((t,[o,n])=>["__contains",...Re].includes(o)?t:"__change"===o?"new"===n||"diff"===n||t:Qe(e,n)[n].__contains||t),!1),e};const Ve=(e,t)=>e.map((e=>Object.entries(e).reduce(((e,[o,n])=>{const r="string"==typeof n&&"undefined"!==Ae(t[n])?t[n]:n;return Object.assign(Object.assign({},e),{[o]:r})}),{})));var Xe={exports:{}};var et="win32"===process.platform;var tt=b.default;function ot(e,t){var o=[];for(var n=0;n<e.length;n++){var r=e[n];r&&"."!==r&&(".."===r?o.length&&".."!==o[o.length-1]?o.pop():t&&o.push(".."):o.push(r))}return o}function nt(e){var t=e.length-1;var o=0;for(;o<=t&&!e[o];o++);var n=t;for(;n>=0&&!e[n];n--);return 0===o&&n===t?e:o>n?[]:e.slice(o,n+1)}var rt=/^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;var ct=/^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;var st={};function at(e){var t=rt.exec(e),o=(t[1]||"")+(t[2]||""),n=t[3]||"";var r=ct.exec(n);return[o,r[1],r[2],r[3]]}function dt(e){var t=rt.exec(e),o=t[1]||"",n=!!o&&":"!==o[1];return{device:o,isUnc:n,isAbsolute:n||!!t[2],tail:t[3]}}function ut(e){return"\\\\"+e.replace(/^[\\\/]+/,"").replace(/[\\\/]+/g,"\\")}st.resolve=function(){var e="",t="",o=!1;for(var n=arguments.length-1;n>=-1;n--){var r;if(n>=0?r=arguments[n]:e?(r=process.env["="+e])&&r.substr(0,3).toLowerCase()===e.toLowerCase()+"\\"||(r=e+"\\"):r=process.cwd(),!tt.isString(r))throw new TypeError("Arguments to path.resolve must be strings");if(r){var i=dt(r),c=i.device,s=i.isUnc,a=i.isAbsolute,d=i.tail;if((!c||!e||c.toLowerCase()===e.toLowerCase())&&(e||(e=c),o||(t=d+"\\"+t,o=a),e&&o))break}}return s&&(e=ut(e)),e+(o?"\\":"")+(t=ot(t.split(/[\\\/]+/),!o).join("\\"))||"."},st.normalize=function(e){var t=dt(e),o=t.device,n=t.isUnc,r=t.isAbsolute,i=t.tail,c=/[\\\/]$/.test(i);return(i=ot(i.split(/[\\\/]+/),!r).join("\\"))||r||(i="."),i&&c&&(i+="\\"),n&&(o=ut(o)),o+(r?"\\":"")+i},st.isAbsolute=function(e){return dt(e).isAbsolute},st.join=function(){var e=[];for(var t=0;t<arguments.length;t++){var o=arguments[t];if(!tt.isString(o))throw new TypeError("Arguments to path.join must be strings");o&&e.push(o)}var n=e.join("\\");return/^[\\\/]{2}[^\\\/]/.test(e[0])||(n=n.replace(/^[\\\/]{2,}/,"\\")),st.normalize(n)},st.relative=function(e,t){e=st.resolve(e),t=st.resolve(t);var o=e.toLowerCase();var n=t.toLowerCase();var r=nt(t.split("\\"));var i=nt(o.split("\\"));var c=nt(n.split("\\"));var s=Math.min(i.length,c.length);var a=s;for(var d=0;d<s;d++)if(i[d]!==c[d]){a=d;break}if(0==a)return t;var u=[];for(d=a;d<i.length;d++)u.push("..");return(u=u.concat(r.slice(a))).join("\\")},st._makeLong=function(e){if(!tt.isString(e))return e;if(!e)return"";var t=st.resolve(e);return/^[a-zA-Z]\:\\/.test(t)?"\\\\?\\"+t:/^\\\\[^?.]/.test(t)?"\\\\?\\UNC\\"+t.substring(2):e},st.dirname=function(e){var t=at(e),o=t[0],n=t[1];return o||n?(n&&(n=n.substr(0,n.length-1)),o+n):"."},st.basename=function(e,t){var o=at(e)[2];return t&&o.substr(-1*t.length)===t&&(o=o.substr(0,o.length-t.length)),o},st.extname=function(e){return at(e)[3]},st.format=function(e){if(!tt.isObject(e))throw new TypeError("Parameter 'pathObject' must be an object, not "+typeof e);var t=e.root||"";if(!tt.isString(t))throw new TypeError("'pathObject.root' must be a string or undefined, not "+typeof e.root);var o=e.dir;var n=e.base||"";return o?o[o.length-1]===st.sep?o+n:o+st.sep+n:n},st.parse=function(e){if(!tt.isString(e))throw new TypeError("Parameter 'pathString' must be a string, not "+typeof e);var t=at(e);if(!t||4!==t.length)throw new TypeError("Invalid path '"+e+"'");return{root:t[0],dir:t[0]+t[1].slice(0,-1),base:t[2],ext:t[3],name:t[2].slice(0,t[2].length-t[3].length)}},st.sep="\\",st.delimiter=";";var lt=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;var pt={};function ht(e){return lt.exec(e).slice(1)}pt.resolve=function(){var e="",t=!1;for(var o=arguments.length-1;o>=-1&&!t;o--){var n=o>=0?arguments[o]:process.cwd();if(!tt.isString(n))throw new TypeError("Arguments to path.resolve must be strings");n&&(e=n+"/"+e,t="/"===n[0])}return(t?"/":"")+(e=ot(e.split("/"),!t).join("/"))||"."},pt.normalize=function(e){var t=pt.isAbsolute(e),o=e&&"/"===e[e.length-1];return(e=ot(e.split("/"),!t).join("/"))||t||(e="."),e&&o&&(e+="/"),(t?"/":"")+e},pt.isAbsolute=function(e){return"/"===e.charAt(0)},pt.join=function(){var e="";for(var t=0;t<arguments.length;t++){var o=arguments[t];if(!tt.isString(o))throw new TypeError("Arguments to path.join must be strings");o&&(e+=e?"/"+o:o)}return pt.normalize(e)},pt.relative=function(e,t){e=pt.resolve(e).substr(1),t=pt.resolve(t).substr(1);var o=nt(e.split("/"));var n=nt(t.split("/"));var r=Math.min(o.length,n.length);var i=r;for(var c=0;c<r;c++)if(o[c]!==n[c]){i=c;break}var s=[];for(c=i;c<o.length;c++)s.push("..");return(s=s.concat(n.slice(i))).join("/")},pt._makeLong=function(e){return e},pt.dirname=function(e){var t=ht(e),o=t[0],n=t[1];return o||n?(n&&(n=n.substr(0,n.length-1)),o+n):"."},pt.basename=function(e,t){var o=ht(e)[2];return t&&o.substr(-1*t.length)===t&&(o=o.substr(0,o.length-t.length)),o},pt.extname=function(e){return ht(e)[3]},pt.format=function(e){if(!tt.isObject(e))throw new TypeError("Parameter 'pathObject' must be an object, not "+typeof e);var t=e.root||"";if(!tt.isString(t))throw new TypeError("'pathObject.root' must be a string or undefined, not "+typeof e.root);return(e.dir?e.dir+pt.sep:"")+(e.base||"")},pt.parse=function(e){if(!tt.isString(e))throw new TypeError("Parameter 'pathString' must be a string, not "+typeof e);var t=ht(e);if(!t||4!==t.length)throw new TypeError("Invalid path '"+e+"'");return t[1]=t[1]||"",t[2]=t[2]||"",t[3]=t[3]||"",{root:t[0],dir:t[0]+t[1].slice(0,-1),base:t[2],ext:t[3],name:t[2].slice(0,t[2].length-t[3].length)}},pt.sep="/",pt.delimiter=":",Xe.exports=et?st:pt,Xe.exports.posix=pt,Xe.exports.win32=st;class vt{constructor({db:e=new Te}={}){this.db=e}deploy(e){return S(this,void 0,void 0,(function*(){const[t]=yield this.db.put([{__mdl:e}]);return t}))}static bitcoinResolveHook(e){return e}static bitcoinImportHook(e){return S(this,void 0,void 0,(function*(){const[t]=yield(new Te).get([e]);return new c.StaticModuleRecord(t.__mdl,e)}))}static nodeResolveHook(e="",t=""){if(e.startsWith("/"))throw TypeError(`Module specifier ${e} must not begin with "/"`);if(!t.startsWith("./"))throw TypeError(`Module referrer ${t} must begin with "./"`);const o=[];const n=[];pe(e)&&(n.push(...t.split("/")),n.pop(),o.push(".")),n.push(...e.split("/"));for(const r of n)if("."===r||""===r);else if(".."===r){if(0===n.length)throw TypeError(`Module specifier ${e} via referrer ${t} must not traverse behind an empty path`);o.pop()}else o.push(r);return o.join("/")}static nodeImportHook(e,t){return S(this,void 0,void 0,(function*(){if(!pe(e))throw TypeError(`Cannot locate module ${e}.`);const o=Xe.exports.join(t,e);const n=yield d.readFile(o,{encoding:"utf8"});if(void 0===n)throw new ReferenceError(`Cannot retrieve module at location ${o}.`);return new c.StaticModuleRecord(n,o)}))}static resolveHook(e,t){if(ae(t)&&!ae(e))throw new Error("Requiring a local file from a module on the blockchain is not supported.");return ae(e)?vt.bitcoinResolveHook(e):vt.nodeResolveHook(e,t)}static makeImportHook(e){return t=>ae(t)?vt.bitcoinImportHook(t):vt.nodeImportHook(t,e)}static getBitcoinCompartment(e){const{resolveHook:t,makeImportHook:o}=vt;return new Compartment({},{},{resolveHook:t,importHook:o(e)})}static import(e,t=Xe.exports.dirname(a.fileURLToPath("undefined"==typeof document?new(require("url").URL)("file:"+__filename).href:document.currentScript&&document.currentScript.src||new URL("computer.cjs.async-test.js",document.baseURI).href))){return S(this,void 0,void 0,(function*(){const o=vt.getBitcoinCompartment(t);const{namespace:n}=yield o.import(e);return n}))}}class yt{constructor({db:e=new Te}={}){this.db=e}get(e){return S(this,void 0,void 0,(function*(){const{txId:t,outputIndex:o}=le(e);const{inRevs:n,outData:r}=yield this.db.fromTxId(t);if(!Array.isArray(n)||!Array.isArray(r)||0===r.length)return;const i=r[0].__index||{};const c=yield Promise.all(Object.values(i).map((e=>{const t=n[e];return t?this.get(t):Promise.resolve({})})));const s=Object.keys(i).map(((e,t)=>[e,c[t]]));const a=Object.fromEntries(s);let d=a.obj;delete a.obj;const u=Object.entries(a).reduce(((e,[t,o])=>{const n=parseInt(t,10);return Number.isNaN(n)||(e[n]=o),e}),[]);const{__cls:l,__func:p,__expt:h,__mdl:v,__args:y}=r[i.obj]||{};const g=function(e,t){let o=0;return t.map((t=>"__"===t?e[o++]:t))}(u,y||[]);let _;if(void 0!==h&&void 0!==v){const e=vt.getBitcoinCompartment("");const{namespace:t}=yield e.import(v);d=new Compartment(Object.assign(Object.assign({},t),{args:g})).evaluate(`Reflect.construct(${h}, args)`)}else if(void 0!==l){const e=(new Compartment).evaluate(`(${l})`);d=new Compartment({ClsFunc:e,args:g}).evaluate("Reflect.construct(ClsFunc, args)")}else{if(void 0===d||void 0===p)throw new Error("Unrecognized transaction.");{const e=d[p];_=new Compartment({func:e,target:d,args:g}).evaluate("Reflect.apply(func, target, args)")}}Object.entries(i).forEach((([e,o])=>{const n=parseInt(e,10);let i=u[n];"obj"===e?i=d:"res"===e&&(i=_),De(i,r,o,t)}));const f=(null==d?void 0:d._root)||`${t}/${i.obj}`;return Fe([_,d,...u],f),[...u,d,_][o]}))}}class gt{constructor({db:e=new Te}={}){this.db=e,this.modules=new vt({db:e}),gt.proxyDepth=gt.proxyDepth||0}write(e){return S(this,void 0,void 0,(function*(){let t;let o;let n;let r;const{moduleSpecifier:i,target:c,property:s,constructorFunction:a,exportName:d,args:u=[]}=e;const l=Ue(c);const p=Ue(u);if(void 0!==d&&void 0!==u&&void 0!==i){const e=vt.getBitcoinCompartment("");const{namespace:c}=yield e.import(i);t=new Compartment(Object.assign(Object.assign({},c),{args:u})).evaluate(`Reflect.construct(${d}, args)`),o=u,r={__expt:d,__mdl:i},n=void 0}else if(void 0!==a&&void 0!==u)t=new Compartment({constructorFunction:a,args:u}).evaluate("Reflect.construct(constructorFunction, args)"),o=u,r={__cls:a.toString()},n=void 0;else{if(void 0===c||void 0===s)throw new Error("Unrecognized constructor or function call parameters.");t=c,o=u,r={__func:String(s)},gt.proxyDepth+=1,n=new Compartment({func:c[s],target:c,args:u}).evaluate("Reflect.apply(func, target, args)"),gt.proxyDepth-=1}const{smartArgs:h,dumbArgs:v}=se(p);const{smartArgs:y}=se(o);const g=Object.assign(Object.assign(Object.assign({},h),{obj:l}),{_id:"index"});const _=Object.assign(Object.assign(Object.assign({},y),{obj:t}),{_id:"index"});["Object","Array"].includes(Ae(n))&&(_.res=n);const[f,b,w]=((e,t)=>{const o=We(t);const n=o._id;const r=Ue(e);const i=Ue(o);const c=ze(r);const s=ze(i);const a=Ge(c);const d=Ge(s);const u=((e,t)=>Ne(t,(([t,o])=>{const n=e[t];var r;return o.__change=(r=n)?Ke(r,o)?"same":"diff":"new",[t,o]})))(Ye(a),Ye(d));const l=Me(u,Ze);const p=Qe(l,n);const h=p[n];delete p[n];const v=Me(p,(e=>e._rev));const y=(g=e=>e.__contains||Object.values(h).includes(e._id),He(p,(([,e])=>g(e))));var g;const _=Object.values(y);const[f,b]=(w=e=>"new"===e.__change,_.reduce((([e,t],o,n)=>w(o)?[[...e,o],t]:[e,[...t,o]]),[[],[]]));var w;const m=[...b,...f];const k=(e=>e.reduce(((e,t,o)=>Object.assign(Object.assign({},e),{[t._id]:o})),{}))(m);const S=Ve(m,k);const[j]=Ve([h],k);const q=b.map((e=>e._rev));const[O,...C]=((e,t)=>[t,...e].map((e=>{const t=x(e,["_id","_rev","__change","__contains"]);return He(t,(([e,t])=>Re.includes(e)||"number"==typeof t))})))(S,j);return[q,C.map(Je).map((e=>Object.entries(e).reduce(((e,[t,o])=>Object.assign(Object.assign({},e),{[t]:v[o]||o})),{}))),O]})(g,_);void 0!==b[0]&&(b[0].__index=w);const m=w.obj;void 0!==b[m]&&(r.__args=v,b[m]=Object.assign(Object.assign({},b[m]),r));const k=w.res;void 0!==b[k]&&"function Object() { [native code] }"!==n.constructor.toString()&&(b[k].__cls=n.constructor.toString());const[S]=yield this.db.update(f,b);const{txId:j}=le(S);Object.entries(w).forEach((([e,o])=>{let r;r="obj"===e?t:e.startsWith("res")?n:y[parseInt(e,10)],De(r,b,o,j)}));const q=(null==c?void 0:c._root)||`${j}/${w.obj}`;return Fe([n,t,...y],q),void 0!==n?n:t}))}get(e,t){return gt.proxyDepth>0||"function"!=typeof e[t]?Reflect.get(e,t):(...o)=>this.write({target:e,property:t,args:o})}}const{crypto:_t}=e.Bitcoin;class ft{constructor(e={}){if(void 0!==e.seed)throw new Error('The constructor parameter "seed" has been renamed to "mnemonic".');this.db=new Te(e)}new(e,t,o){return S(this,void 0,void 0,(function*(){const n="function"==typeof e?e:void 0;const r="string"==typeof e?e:void 0;const i=new gt({db:this.db});const c=yield i.write({args:t,moduleSpecifier:o,constructorFunction:n,exportName:r});return new Proxy(c,i)}))}sync(e){return S(this,void 0,void 0,(function*(){ue(e);const{db:t}=this;const o=new yt({db:t});const n=new gt({db:t});const r=yield o.get(e);return new Proxy(r,n)}))}query({publicKey:t,contract:o}){return S(this,void 0,void 0,(function*(){let n={};if(t&&(n=Object.assign(Object.assign({},n),{publicKey:new e.Bitcoin.PublicKey(t).toString()})),o){const e="string"==typeof o?o:o.toString();n=Object.assign(Object.assign({},n),{classHash:_t.Hash.sha256(Buffer.from(e)).toString("hex")})}return this.db.wallet.restClient.query(n)}))}idsToRevs(e){return S(this,void 0,void 0,(function*(){return this.db.wallet.restClient.idsToRevs(e)}))}deploy(e){return S(this,void 0,void 0,(function*(){return new vt(this).deploy(e)}))}import(e,t){return S(this,void 0,void 0,(function*(){return(yield vt.import(t))[e]}))}getChain(){return this.db.wallet.restClient.chain}getNetwork(){return this.db.wallet.restClient.network}getMnemonic(){return this.db.wallet.restClient.mnemonic.toString()}getPrivateKey(){return this.db.wallet.privateKey.toString()}getPublicKey(){return this.db.wallet.publicKey.toString()}getAddress(){return this.db.wallet.address.toString()}getBalance(){return S(this,void 0,void 0,(function*(){return this.db.wallet.getBalance()}))}getUtxos(){return S(this,void 0,void 0,(function*(){const t=new e.Bitcoin.Address(this.getAddress());return this.db.wallet.restClient.getUtxosByAddress(t)}))}broadcast(e){return S(this,void 0,void 0,(function*(){return this.db.wallet.restClient.sendTransaction(e)}))}queryRevs(e){return S(this,void 0,void 0,(function*(){return this.query(e)}))}getOwnedRevs(e=this.db.wallet.publicKey){return this.query({publicKey:e.toString()})}getRevs(e=this.db.wallet.publicKey){return S(this,void 0,void 0,(function*(){return this.query({publicKey:e.toString()})}))}getLatestRevs(e){return S(this,void 0,void 0,(function*(){return this.idsToRevs(e)}))}getLatestRev(e){return S(this,void 0,void 0,(function*(){const[t]=yield this.idsToRevs([e]);return t}))}rpcCall(e,t){return S(this,void 0,void 0,(function*(){const o=yield this.db.wallet.restClient.rpc(e,t);return o.result?o.result:{}}))}}var bt=m.default;var wt=k.default;var mt=w.default;function kt(e){"string"==typeof e&&(e=function(e){var t=mt.parse(e);var o=t.hostname;var n=parseInt(t.port,10);var r=t.protocol;r=r.substring(0,r.length-1);var i=t.auth.split(":");return{host:o,port:n,protocol:r,user:i[0]?decodeURIComponent(i[0]):null,pass:i[1]?decodeURIComponent(i[1]):null}}(e)),e=e||{},this.host=e.host||"127.0.0.1",this.port=e.port||8332,this.user=e.user||"user",this.pass=e.pass||"pass",this.protocol="http"===e.protocol?bt:wt,this.batchedCalls=null,this.disableAgent=e.disableAgent||!1;var t=void 0!==e.rejectUnauthorized;this.rejectUnauthorized=!t||e.rejectUnauthorized,kt.config.log?this.log=kt.config.log:this.log=kt.loggers[kt.config.logger||"normal"]}var xt=console.log.bind(console);var St=function(){};function jt(e,t){var o=this;e=JSON.stringify(e);var n=this.user+":"+this.pass;var r=Buffer.from&&Buffer.from!==Uint8Array.from?Buffer.from(n):new Buffer(n);this.auth=r.toString("base64");var i={host:o.host,path:"/",method:"POST",port:o.port,rejectUnauthorized:o.rejectUnauthorized,agent:!o.disableAgent&&void 0};if(o.httpOptions)for(var c in o.httpOptions)i[c]=o.httpOptions[c];var s=!1;var a="Bitcoin JSON-RPC: ";var d=this.protocol.request(i,(function(e){var n="";e.on("data",(function(e){n+=e})),e.on("end",(function(){if(!s)if(s=!0,401!==e.statusCode)if(403!==e.statusCode){if(500===e.statusCode&&"Work queue depth exceeded"===n.toString("utf8")){var r=new Error("Bitcoin JSON-RPC: "+n.toString("utf8"));return r.code=429,void t(r)}var i;try{i=JSON.parse(n)}catch(r){o.log.err(r.stack),o.log.err(n),o.log.err("HTTP Status code:"+e.statusCode);var c=new Error(a+"Error Parsing JSON: "+r.message);return void t(c)}t(i.error,i)}else t(new Error(a+"Connection Rejected: 403 Forbidden"));else t(new Error(a+"Connection Rejected: 401 Unnauthorized"))}))}));d.on("error",(function(e){var o=new Error(a+"Request Error: "+e.message);s||(s=!0,t(o))})),d.setHeader("Content-Length",e.length),d.setHeader("Content-Type","application/json"),d.setHeader("Authorization","Basic "+o.auth),d.write(e),d.end()}kt.loggers={none:{info:St,warn:St,err:St,debug:St},normal:{info:xt,warn:xt,err:xt,debug:St},debug:{info:xt,warn:xt,err:xt,debug:xt}},kt.config={logger:"normal"},kt.prototype.batch=function(e,t){this.batchedCalls=[],e(),jt.call(this,this.batchedCalls,t),this.batchedCalls=null},kt.callspec={abandonTransaction:"str",abortRescan:"",addMultiSigAddress:"",addNode:"",analyzePSBT:"str",backupWallet:"",bumpFee:"str",clearBanned:"",combinePSBT:"obj",combineRawTransaction:"obj",convertToPSBT:"str",createMultiSig:"",createPSBT:"obj",createRawTransaction:"obj obj",createWallet:"str",decodePSBT:"str",decodeScript:"str",decodeRawTransaction:"",deriveAddresses:"str",disconnectNode:"",dumpPrivKey:"",dumpWallet:"str",encryptWallet:"",enumerateSigners:"",estimateFee:"",estimateSmartFee:"int str",estimatePriority:"int",generate:"int",generateBlock:"str obj",generateToAddress:"int str",generateToDescriptor:"int str",getAccount:"",getAccountAddress:"str",getAddedNodeInfo:"",getAddressMempool:"obj",getAddressUtxos:"obj",getAddressBalance:"obj",getAddressDeltas:"obj",getAddressesByLabel:"str",getAddressInfo:"str",getAddressTxids:"obj",getAddressesByAccount:"",getBalance:"str int",getBalances:"",getBestBlockHash:"",getBlockDeltas:"str",getBlock:"str int",getBlockchainInfo:"",getBlockCount:"",getBlockFilter:"str",getBlockHashes:"int int obj",getBlockHash:"int",getBlockHeader:"str",getBlockNumber:"",getBlockStats:"str",getBlockTemplate:"",getConnectionCount:"",getChainTips:"",getChainTxStats:"",getDescriptorInfo:"str",getDifficulty:"",getGenerate:"",getHashesPerSec:"",getIndexInfo:"",getInfo:"",getMemoryInfo:"",getMemoryPool:"",getMemPoolAncestors:"str",getMemPoolDescendants:"str",getMemPoolEntry:"str",getMemPoolInfo:"",getMiningInfo:"",getNetTotals:"",getNetworkHashPS:"",getNetworkInfo:"",getNewAddress:"str str",getNodeAddresses:"",getPeerInfo:"",getRawChangeAddress:"",getRawMemPool:"bool",getRawTransaction:"str int",getReceivedByAccount:"str int",getReceivedByAddress:"str int",getReceivedByLabel:"str",getRpcInfo:"",getSpentInfo:"obj",getTransaction:"",getTxOut:"str int bool",getTxOutProof:"",getTxOutSetInfo:"",getUnconfirmedBalance:"",getWalletInfo:"",getWork:"",getZmqNotifications:"",finalizePSBT:"str",fundRawTransaction:"str",help:"",importAddress:"str str bool",importDescriptors:"str",importMulti:"obj obj",importPrivKey:"str str bool",importPrunedFunds:"str, str",importPubKey:"str",importWallet:"str",invalidateBlock:"str",joinPSBTs:"obj",keyPoolRefill:"",listAccounts:"int",listAddressGroupings:"",listBanned:"",listDescriptors:"",listLabels:"",listLockUnspent:"bool",listReceivedByAccount:"int bool",listReceivedByAddress:"int bool",listReceivedByLabel:"",listSinceBlock:"str int",listTransactions:"str int int",listUnspent:"int int",listWalletDir:"",listWallets:"",loadWallet:"str",lockUnspent:"",logging:"",move:"str str float int str",ping:"",preciousBlock:"str",prioritiseTransaction:"str float int",pruneBlockChain:"int",psbtBumpFee:"str",removePrunedFunds:"str",reScanBlockChain:"",saveMemPool:"",send:"obj",setHDSeed:"",setLabel:"str str",setWalletFlag:"str",scanTxOutSet:"str",sendFrom:"str str float int str str",sendMany:"str obj int str",sendRawTransaction:"str",sendToAddress:"str float str str",setAccount:"",setBan:"str str",setNetworkActive:"bool",setGenerate:"bool int",setTxFee:"float",signMessage:"",signMessageWithPrivKey:"str str",signRawTransaction:"",signRawTransactionWithKey:"str obj",signRawTransactionWithWallet:"str",stop:"",submitBlock:"str",submitHeader:"str",testMemPoolAccept:"obj",unloadWallet:"",upgradeWallet:"",uptime:"",utxoUpdatePSBT:"str",validateAddress:"",verifyChain:"",verifyMessage:"",verifyTxOutProof:"str",walletCreateFundedPSBT:"",walletDisplayAddress:"str",walletLock:"",walletPassPhrase:"string int",walletPassphraseChange:"",walletProcessPSBT:"str"};var qt=function(e,t,o){return Array.prototype.slice.call(e,t,o)};function Ot(){return parseInt(1e5*Math.random())}!function(e,t,o){function n(e,t){return function(){var n=arguments.length-1;this.batchedCalls&&(n=arguments.length);for(var r=0;r<n;r++)t[r]&&(arguments[r]=t[r](arguments[r]));this.batchedCalls?this.batchedCalls.push({jsonrpc:"2.0",method:e,params:qt(arguments),id:Ot()}):o.call(this,{method:e,params:qt(arguments,0,arguments.length-1),id:Ot()},arguments[arguments.length-1])}}var r={str:function(e){return e.toString()},int:function(e){return parseFloat(e)},float:function(e){return parseFloat(e)},bool:function(e){return!0===e||"1"==e||"true"==e||"true"==e.toString().toLowerCase()},obj:function(e){return"string"==typeof e?JSON.parse(e):e}};for(var i in t){var c=[];if(t[i].length){c=t[i].split(" ");for(var s=0;s<c.length;s++)r[c[s]]?c[s]=r[c[s]]:c[s]=r.str}var a=i.toLowerCase();e.prototype[i]=n(a,c),e.prototype[a]=e.prototype[i]}}(kt,kt.callspec,jt);var Ct=kt;const Bt=new Ct({protocol:process.env.RPC_PROTOCOL,user:process.env.RPC_USER,pass:process.env.RPC_PASSWORD,host:process.env.RPC_HOST,port:process.env.RPC_PORT});const Tt={createwallet:b.default.promisify(Ct.prototype.createwallet.bind(Bt)),getaddressinfo:b.default.promisify(Ct.prototype.getaddressinfo.bind(Bt)),getBlock:b.default.promisify(Ct.prototype.getBlock.bind(Bt)),getBlockchainInfo:b.default.promisify(Ct.prototype.getBlockchainInfo.bind(Bt)),getBlockHash:b.default.promisify(Ct.prototype.getBlockHash.bind(Bt)),getNewAddress:b.default.promisify(Ct.prototype.getNewAddress.bind(Bt)),generateToAddress:b.default.promisify(Ct.prototype.generateToAddress.bind(Bt)),getRawTransaction:b.default.promisify(Ct.prototype.getRawTransaction.bind(Bt)),importaddress:b.default.promisify(Ct.prototype.importaddress.bind(Bt)),listunspent:b.default.promisify(Ct.prototype.listunspent.bind(Bt)),sendRawTransaction:b.default.promisify(Ct.prototype.sendRawTransaction.bind(Bt)),sendToAddress:b.default.promisify(Ct.prototype.sendToAddress.bind(Bt))};const{Opcode:Rt,Script:$t,Mnemonic:At,crypto:Et,Transaction:It,encoding:Pt}=e.Bitcoin;function Lt(e=0){return E.split(";")[e]}function Kt(e=0){return new ft(function(e=0){return{mnemonic:Lt(),chain:R,network:$,path:re({account:e})}}(e))}const Ut=({random:e=!1}={})=>S(void 0,void 0,void 0,(function*(){const t=e?re():oe();const o=function(e=0){return new At(Lt(e))}();const n=new Be({mnemonic:o,path:t});return yield u.backOff((()=>S(void 0,void 0,void 0,(function*(){return(e=>S(void 0,void 0,void 0,(function*(){const{result:t}=yield Tt.generateToAddress(1,e.address);const{result:o}=yield Tt.getBlock(t[0],2);if(o.confirmations<=0)throw new Error(`No confirmations on block mining: ${o.confirmations}`)})))(n)})))),t}));function Nt(e,o){const n=Object.keys(o);const r=Object.keys(e);if(n.length!==r.length)throw new Error("Actual keys do not match expected keys");n.forEach((n=>{const r=e[n];const i=o[n];if(void 0===i)throw new Error(`${n} is not defined in expected object`);if("value"===i.check)t.expect(e).to.have.property(n),t.expect(e[n]).to.deep.eq(i.value);else{if("type"!==i.check)throw new Error("Error configuring expectToEqual: set 'check' to 'type' or 'value'");if("string"===i.type)t.expect(e).to.have.property(n).that.is.a("string");else if("number"===i.type)t.expect(e).to.have.property(n).that.is.a("number");else if("array"===i.type){if(t.expect(e).to.have.property(n).that.is.a("array").that.have.lengthOf(i.length),void 0!==i.length&&i.length>0)for(let e=0;e<r.length;e+=1)t.expect(r[e]).to.be.an(i.subtype)}else{if("object"!==i.type)throw new Error("Error configuring expectToEqual: set 'type' to 'number', 'string', array', or 'object'.");t.expect(e).to.have.property(n).that.is.an("object")}}}))}const Mt=e=>e.split("/")[0];const Ht=Lt();const Dt=e=>{const[t,o]=e.split("/");const n=parseFloat(o);return[64,65].includes(t.length)&&!Number.isNaN(n)&&Number.isFinite(n)};let Ft=[];before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){Ft=yield function({n:e=1,random:t=!1}={}){return S(this,void 0,void 0,(function*(){const o=[];for(let n=0;n<e;n+=1)o.push(yield Ut({random:t}));return yield S(void 0,void 0,void 0,(function*(){let e=!1;do{try{const{result:t}=yield Tt.generateToAddress(100,(new At).toHDPrivateKey("",$).derive(oe()).privateKey.toPublicKey().toAddress());e=100===t.length}catch(e){X(500)}}while(!e)})),o}))}({n:58,random:!0})}))));let Wt=0;function zt(){if(Wt+=1,Ft.length)return Ft.pop();throw Error(`No more paths ${Wt}`)}describe("Computer",(()=>{describe("New",(()=>{describe("Should create a smart object without argument",(()=>{class e{constructor(){this.n=1}}let o;let n;let r;let i;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){n=new ft({mnemonic:Ht,path:zt()}),r=new ft({mnemonic:Ht,path:zt()}),({db:i}=n),o=yield n.new(e)})))),it("Should create a smart object when computer.new is called",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{n:{check:"value",type:"number",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(o._id).eq(o._rev),t.expect(o._id).eq(o._root),t.expect(Dt(o._id)),t.expect(Dt(o._rev)),t.expect(Dt(o._root))})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:i});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const n=yield i.get([o._rev]);t.expect(n).to.be.an("array").that.have.lengthOf(1),Nt(n[0],{__args:{check:"type",type:"array",length:0},__index:{check:"type",type:"object"},__cls:{check:"value",value:e.toString(),type:"string"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I,type:"number"}}),t.expect(n[0].__index).to.deep.eq({obj:0})})))),it("should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield n.getLatestRev(o._id)).eq(o._rev)})))),it("should work with idsToRevs",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield n.idsToRevs([o._id])).to.deep.eq([o._rev])})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(o._rev)).to.deep.eq(o)})))),it("Should be able to call the RPC methods",(()=>S(void 0,void 0,void 0,(function*(){yield n.rpcCall("getBlockchainInfo","")}))))})),describe("Should create a smart object with a dumb argument",(()=>{class e{constructor(e){this.n=e}}let o;const n=Math.random();let r;let i;let c;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){r=new ft({mnemonic:Ht,path:zt()}),i=new ft({mnemonic:Ht,path:zt()}),({db:c}=r),o=yield r.new(e,[n])})))),it("Should create a smart object when computer.new is called",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{n:{check:"value",type:"number",value:n},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(o._id).eq(o._rev),t.expect(o._id).eq(o._root),t.expect(Dt(o._id)),t.expect(Dt(o._rev)),t.expect(Dt(o._root))})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const r=yield c.get([o._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(1),Nt(r[0],{__args:{check:"type",type:"array",length:1,subtype:"number"},__index:{check:"type",type:"object"},__cls:{check:"value",value:e.toString(),type:"string"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I,type:"number"}}),t.expect(r[0].__args).to.deep.eq([n]),t.expect(r[0].__index).to.deep.eq({obj:0})})))),it("should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create a smart object with a smart argument",(()=>{class e{constructor(){this.n=1}}class o{constructor(e){this.a=e}}let n;let r;let i;let c;let s;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){i=new ft({mnemonic:Ht,path:zt()}),c=new ft({mnemonic:Ht,path:zt()}),({db:s}=i),n=yield i.new(e,[]),r=yield i.new(o,[n])})))),it("Should create a smart object when computer.new is called",(()=>S(void 0,void 0,void 0,(function*(){Nt(n,{n:{check:"value",type:"number",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(r.a,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),t.expect(r.a).to.deep.eq(n)})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(Dt(n._id)),t.expect(Dt(n._rev)),t.expect(Dt(n._root)),t.expect(Dt(r._id)),t.expect(Dt(r._rev)),t.expect(Dt(r._root));const e=Mt(n._id);const o=Mt(r._id);t.expect(e).not.eq(o),t.expect(n._id).eq(`${e}/0`),t.expect(n._rev).eq(`${o}/0`),t.expect(r._id).eq(`${o}/1`),t.expect(r._rev).eq(`${o}/1`),t.expect(r.a._id).eq(n._id),t.expect(r.a._rev).eq(n._rev),t.expect(n._root).eq(n._id),t.expect(r._root).eq(r._id)})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:s});t.expect(yield e.get(n._rev)).to.deep.eq(n),t.expect(yield e.get(r._rev)).to.deep.eq(r)})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const i=yield s.get([n._id]);t.expect(i).to.be.an("array").that.have.lengthOf(1),Nt(i[0],{__args:{check:"type",type:"array",length:0},__index:{check:"type",type:"object"},__cls:{check:"value",value:e.toString(),type:"string"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I,type:"number"}}),t.expect(i[0].__index).to.deep.eq({obj:0});const c=Mt(r._id);const a=yield s.get([`${c}/0`,`${c}/1`]);t.expect(a).to.be.an("array").that.have.lengthOf(2),Nt(a[0],{__index:{check:"type",type:"object"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I,type:"number"}}),t.expect(a[0].__index).to.deep.eq({0:0,obj:1}),Nt(a[1],{a:{check:"value",value:0},__args:{check:"value",value:["__"]},__cls:{check:"value",value:o.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield i.getLatestRev(r._id)).eq(r._rev),t.expect(yield i.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with idsToRevs",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield i.idsToRevs([n._id])).to.deep.eq([n._rev]),t.expect(yield i.idsToRevs([r._id])).to.deep.eq([r._rev])})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield c.sync(n._rev)).to.deep.eq(n),t.expect(yield c.sync(r._rev)).to.deep.eq(r)}))))})),describe("Should create a smart object with a sub-object",(()=>{class e{constructor(){this.n={m:1}}}let o;let n;let r;let i;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){n=new ft({mnemonic:Ht,path:zt()}),r=new ft({mnemonic:Ht,path:zt()}),({db:i}=n),o=yield n.new(e,[])})))),it("Should create a smart object when computer.new is called",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{n:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(o.n,{m:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(o._id).eq(o._rev),t.expect(o.n._id).eq(o.n._rev),t.expect(o._root).eq(o._id),t.expect(o.n._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:i});const n=yield e.get(o._rev);t.expect(n).to.deep.eq(o),t.expect(o.n._id.startsWith("__temp__")).eq(!1),t.expect(o.n._rev.startsWith("__temp__")).eq(!1);const r=yield e.get(o.n._rev);t.expect(r).to.be.undefined})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const n=yield i.get([o._rev]);t.expect(n).to.be.an("array").that.have.lengthOf(1),Nt(n[0],{n:{check:"value",value:1},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield n.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create a smart object with a smart sub-object",(()=>{class e{constructor(t){this.b=t?new e(!1):void 0}}let o;let n;let r;let i;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){n=new ft({mnemonic:Ht,path:zt()}),r=new ft({mnemonic:Ht,path:zt()}),({db:i}=n),o=yield n.new(e,[!0])})))),it("Should create a smart object when computer.new is called",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{b:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(o.b,{b:{check:"value",value:void 0},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(o._id).eq(o._rev),t.expect(o.b._id).eq(o.b._rev),t.expect(o._root).eq(o._id),t.expect(o.b._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:i});const n=yield e.get(o._rev);t.expect(n).to.deep.eq(o),t.expect(o.b._id.startsWith("__temp__")).eq(!1),t.expect(o.b._rev.startsWith("__temp__")).eq(!1);const r=yield e.get(o.b._rev);t.expect(r).to.be.undefined})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const n=yield i.get([o._rev]);t.expect(n).to.be.an("array").that.have.lengthOf(1),Nt(n[0],{b:{check:"value",value:1},__args:{check:"value",value:[!0]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield n.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create a smart object with an owner defined",(()=>{class e{constructor(e,t){this.n=e,this._owners=[t]}}let o;const n=Math.random();let r;let i;let c;let s;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){r=new ft({mnemonic:Ht,path:zt()}),i=new ft({mnemonic:Ht,path:zt()}),({db:c}=r),s=r.db.wallet.publicKey.toString(),o=yield r.new(e,[n,s])})))),it("Should create a smart object when computer.new is called",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{n:{check:"value",value:n},_owners:{check:"value",value:[s]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(o._id).eq(o._rev),t.expect(o._id).eq(o._root),t.expect(Dt(o._id)),t.expect(Dt(o._rev)),t.expect(Dt(o._root))})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const r=yield c.get([o._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(1),Nt(r[0],{__args:{check:"value",value:[n,s]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create an encrypted smart object",(()=>{class e{constructor(e,t){this.n=e,this._readers=[t]}}let o;const n=Math.random();let r;let i;let c;let s;let a;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){r=new ft({mnemonic:Ht,path:zt()}),i=new ft({mnemonic:"average metal token tube twice idle yellow mail imitate nuclear clerk cover",path:zt()}),({db:c}=r),({db:s}=i),a=r.db.wallet.publicKey.toString(),o=yield r.new(e,[n,a])})))),it("Should create a smart object when computer.new is called",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{n:{check:"value",value:n},_readers:{check:"value",value:[a]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(o._id).eq(o._rev),t.expect(o._id).eq(o._root),t.expect(Dt(o._id)),t.expect(Dt(o._rev)),t.expect(Dt(o._root))})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with encoded data",(()=>S(void 0,void 0,void 0,(function*(){const r=yield c.get([o._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),Nt(r[0],{__args:{check:"value",value:[n,a]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_readers:{check:"value",value:[]},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should be able to decode the output when db has access",(()=>S(void 0,void 0,void 0,(function*(){const r=yield c.get([o._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(1),Nt(r[0],{__args:{check:"value",value:[n,a]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_readers:{check:"value",value:[]},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should be not able to decode the output when db does not has access",(()=>S(void 0,void 0,void 0,(function*(){try{yield s.get([o._rev])}catch(e){t.expect(e).to.be.instanceof(Error),t.expect(e).to.have.property("message","Decryption failure")}})))),it("should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(o._rev)).to.deep.eq(o);try{yield i.sync(o._rev),t.expect(!0).eq(!1)}catch(e){t.expect(e.message).to.not.be.undefined}}))))})),describe("Should create an off-chain object",(()=>{class e{constructor(e){this.n=e,this._url="http://127.0.0.1:3000"}}let o;const n=Math.random();let r;let i;let c;let s;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){r=new ft({mnemonic:Ht,path:zt()}),i=new ft({mnemonic:Ht,path:zt()}),({db:c}=r),({db:s}=i),o=yield r.new(e,[n])})))),it("Should create a smart object when computer.new is called",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{n:{check:"value",value:n},_url:{check:"value",value:"http://127.0.0.1:3000"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with encoded data data",(()=>S(void 0,void 0,void 0,(function*(){const i=o._rev.split("/")[0];const{restClient:c}=r.db.wallet;const s=yield Ce.fromTxId({txId:i,restClient:c});const{outData:a}=s;t.expect(a).to.be.an("array").that.have.lengthOf(1),Nt(a[0],{__args:{check:"value",value:[n]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I},_url:{check:"type",type:"string"}})})))),it("Should be able to get the output from the server when db has access",(()=>S(void 0,void 0,void 0,(function*(){const r=yield c.get([o._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(1),Nt(r[0],{__args:{check:"value",value:[n]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("Should give all users access to the server",(()=>S(void 0,void 0,void 0,(function*(){const r=yield s.get([o._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(1),Nt(r[0],{__args:{check:"value",value:[n]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe.skip("Should work if the contract is a string",(()=>{let e=null;let o;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){o=new ft({mnemonic:Ht,path:zt()}),e=yield o.new("class A {\n        constructor(n) {\n          this.n = n\n        }\n      }",[1])})))),it("should work",(()=>{t.expect(e).to.not.be.undefined,t.expect(typeof e).eq("object"),Nt(e,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),t.expect(e._id).eq(e._rev)})),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){const o=Kt();t.expect(yield o.sync(e._rev)).to.deep.eq(e)}))))})),describe("Should not create a smart object if no args as passed to the constructor",(()=>{class e{constructor(e,t){this.n=e,this._owners=[t]}}let o;it("Should throw an error",(()=>S(void 0,void 0,void 0,(function*(){try{const n=new ft;o=o||(yield n.new(e,[])),t.expect(!0).eq(!1)}catch(e){t.expect(o).to.be.undefined,t.expect(e.message).to.not.be.undefined}}))))}))})),describe("Function calls",(()=>{describe("Should work for a function call with a dumb argument",(()=>{class e{constructor(e){this.n=e}inc(e){return this.n+=e,this.n}}let o;let n;let r;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){const t=new ft({mnemonic:Ht,path:zt()});r=new ft({mnemonic:Ht,path:zt()}),({db:n}=t),o=yield t.new(e,[1]),yield o.inc(1)})))),it("Should update the smart object",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{n:{check:"value",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(Dt(o._id)).eq(!0),t.expect(Dt(o._rev)).eq(!0),t.expect(Dt(o._root)).eq(!0),t.expect(o._id).not.eq(o._rev),t.expect(o._id).eq(o._root)})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:n});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const r=yield n.get([o._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),Nt(r[0],{__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}});const i=yield n.get([o._rev]);t.expect(i).to.be.an("array").that.have.lengthOf(1),Nt(i[0],{__func:{check:"value",value:"inc"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){const e=new ft;t.expect(yield e.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work for a function call on an encrypted object",(()=>{class e{constructor(e,t){this.n=e,this._readers=[t]}inc(e){return this.n+=e,this.n}}let o;const n=Math.random();let r;let i;let c;let s;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){r=new ft({mnemonic:Ht,path:zt()}),i=new ft({mnemonic:"average metal token tube twice idle yellow mail imitate nuclear clerk cover",path:zt()}),({db:c}=r),s=r.db.wallet.publicKey.toString(),o=yield r.new(e,[n,s]),yield o.inc(1)})))),it("Should update the smart object",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{n:{check:"type",type:"number"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"},_readers:{check:"value",value:[s]}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(Dt(o._id)).eq(!0),t.expect(Dt(o._rev)).eq(!0),t.expect(Dt(o._root)).eq(!0),t.expect(o._id).not.eq(o._rev),t.expect(o._id).eq(o._root)})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const r=yield c.get([o._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),Nt(r[0],{__args:{check:"value",value:[n,s]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I},_readers:{check:"value",value:[]}});const i=yield c.get([o._rev]);t.expect(i).to.be.an("array").that.have.lengthOf(1),Nt(i[0],{__func:{check:"value",value:"inc"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I},_readers:{check:"value",value:[]}})})))),it("Should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(o._rev)).to.deep.eq(o);try{yield i.sync(o._rev),t.expect(!0).eq(!1)}catch(e){t.expect(e.message).to.not.be.undefined}}))))})),describe("Should work for a function call on an off chain object",(()=>{class e{constructor(e){this.n=e,this._url="http://127.0.0.1:3000"}inc(e){return this.n+=e,this.n}}let o;const n=Math.random();let r;let i;let c;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){r=new ft({mnemonic:Ht,path:zt()}),i=new ft({mnemonic:Ht,path:zt()}),({db:c}=r),o=yield r.new(e,[n]),yield o.inc(1)})))),it("Should update the smart object",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{n:{check:"type",type:"number"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(Dt(o._id)).eq(!0),t.expect(Dt(o._rev)).eq(!0),t.expect(Dt(o._root)).eq(!0),t.expect(o._id).not.eq(o._rev),t.expect(o._id).eq(o._root)})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const r=yield c.get([o._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),Nt(r[0],{__args:{check:"value",value:[n]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I},_url:{check:"value",value:"http://127.0.0.1:3000"}});const i=yield c.get([o._rev]);t.expect(i).to.be.an("array").that.have.lengthOf(1),Nt(i[0],{__func:{check:"value",value:"inc"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("Should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work for a function with a smart argument",(()=>{class e{constructor(){this.n=1}}class o{constructor(){this.m=2}objInc(e){return e.n+=1,this.m+=e.n,this.m}}let n;let r;let i;let c;let s;let a;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){c=new ft({mnemonic:Ht,path:zt()}),s=new ft({mnemonic:Ht,path:zt()}),a=c.db,n=yield c.new(e,[]),r=yield c.new(o,[]),i=yield r.objInc(n)})))),it("Should update the smart object",(()=>S(void 0,void 0,void 0,(function*(){Nt(n,{n:{check:"value",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(r,{m:{check:"value",value:4},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should return the correct value",(()=>{t.expect(i).eq(4)})),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(Dt(n._id)).eq(!0),t.expect(Dt(n._rev)).eq(!0),t.expect(Dt(n._root)).eq(!0),t.expect(Dt(r._id)).eq(!0),t.expect(Dt(r._rev)).eq(!0),t.expect(Dt(r._root)).eq(!0);const e=Mt(n._id);const o=Mt(r._id);const i=Mt(r._rev);t.expect(e).not.eq(o),t.expect(o).not.eq(i),t.expect(i).not.eq(e),t.expect(n._id).eq(`${e}/0`),t.expect(r._id).eq(`${o}/0`),t.expect(n._rev).eq(`${i}/0`),t.expect(r._rev).eq(`${i}/1`),t.expect(n._root).eq(n._id),t.expect(r._root).eq(r._id)})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:a});t.expect(yield e.get(n._rev)).to.deep.eq(n),t.expect(yield e.get(r._rev)).to.deep.eq(r)})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const i=yield a.get([n._id]);t.expect(i).to.be.an("array").that.have.lengthOf(1),Nt(i[0],{__args:{check:"value",value:[]},__cls:{check:"value",value:e.toString()},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}});const c=Mt(r._id);const s=yield a.get([`${c}/0`]);t.expect(s).to.be.an("array").that.have.lengthOf(1),Nt(s[0],{__args:{check:"value",value:[]},__cls:{check:"value",value:o.toString()},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}});const d=Mt(r._rev);const u=yield a.get([`${d}/0`,`${d}/1`]);t.expect(u).to.be.an("array").that.have.lengthOf(2),Nt(u[0],{__index:{check:"value",value:{obj:1,0:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}}),Nt(u[1],{__func:{check:"value",value:"objInc"},__args:{check:"value",value:["__"]},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield c.getLatestRev(n._id)).eq(n._rev),t.expect(yield c.getLatestRev(r._id)).eq(r._rev)})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield s.sync(n._rev)).to.deep.eq(n),t.expect(yield s.sync(r._rev)).to.deep.eq(r)}))))})),describe("Should work for a function that returns a dumb object",(()=>{class e{getJson(){return{n:1}}}let o;let n;let r;let i;let c;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){r=new ft({mnemonic:Ht,path:zt()}),i=new ft({mnemonic:Ht,path:zt()}),({db:c}=r),o=yield r.new(e,[]),n=n||(yield o.getJson(3))})))),it("Should update the smart object",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(n,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(Dt(o._id)).eq(!0),t.expect(Dt(o._rev)).eq(!0),t.expect(Dt(o._root)).eq(!0),t.expect(Dt(n._id)).eq(!0),t.expect(Dt(n._rev)).eq(!0),t.expect(Dt(n._root)).eq(!0);const e=Mt(o._id);const r=Mt(n._id);t.expect(e).not.eq(r),t.expect(o._id).eq(`${e}/0`),t.expect(n._id).eq(`${r}/1`),t.expect(o._rev).eq(`${r}/0`),t.expect(n._rev).eq(`${r}/1`),t.expect(o._root).eq(o._id),t.expect(n._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o),t.expect(yield e.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const r=yield c.get([o._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),Nt(r[0],{__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}});const i=Mt(n._id);const s=yield c.get([`${i}/0`,`${i}/1`]);t.expect(s).to.be.an("array").that.have.lengthOf(2),Nt(s[0],{__func:{check:"value",value:"getJson"},__args:{check:"value",value:[3]},__index:{check:"value",value:{obj:0,res:1}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}}),Nt(s[1],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(o._id)).eq(o._rev),t.expect(yield r.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(o._rev)).to.deep.eq(o),t.expect(yield i.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should work for a function that returns a smart object",(()=>{class e{constructor(e){this.n=e}send(t){if(t>this.n)throw new Error;return this.n-=t,new e(t)}}let o;let n;let r;let i;let c;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){r=new ft({mnemonic:Ht,path:zt()}),i=new ft({mnemonic:Ht,path:zt()}),({db:c}=r),o=yield r.new(e,[10]),n=yield o.send(3)})))),it("Should update the smart object",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{n:{check:"value",value:7},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(n,{n:{check:"value",value:3},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(Dt(o._id)).eq(!0),t.expect(Dt(o._rev)).eq(!0),t.expect(Dt(o._root)).eq(!0),t.expect(Dt(n._id)).eq(!0),t.expect(Dt(n._rev)).eq(!0),t.expect(Dt(n._root)).eq(!0);const e=Mt(o._id);const r=Mt(n._id);t.expect(e).not.eq(r),t.expect(o._id).eq(`${e}/0`),t.expect(n._id).eq(`${r}/1`),t.expect(o._rev).eq(`${r}/0`),t.expect(n._rev).eq(`${r}/1`),t.expect(o._root).eq(o._id),t.expect(n._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o),t.expect(yield e.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const r=yield c.get([o._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),Nt(r[0],{__args:{check:"value",value:[10]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}});const i=Mt(n._id);const s=yield c.get([`${i}/0`,`${i}/1`]);t.expect(s).to.be.an("array").that.have.lengthOf(2),Nt(s[0],{__func:{check:"value",value:"send"},__args:{check:"value",value:[3]},__index:{check:"value",value:{obj:0,res:1}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}}),Nt(s[1],{__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(o._id)).eq(o._rev),t.expect(yield r.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(o._rev)).to.deep.eq(o),t.expect(yield i.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should work for a function that updates a nested object",(()=>{class e{constructor(){this.a={aa:1},this.b={bb:2}}update(){this.b.bb=3}}let o;let n;let r;let i;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){n=new ft({mnemonic:Ht,path:zt()}),r=new ft({mnemonic:Ht,path:zt()}),({db:i}=n),o=yield n.new(e,[]),yield o.update()})))),it("Should update the smart object",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{a:{check:"type",type:"object"},b:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(o.a,{aa:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(o.b,{bb:{check:"value",value:3},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(Dt(o._id)).eq(!0),t.expect(Dt(o._rev)).eq(!0),t.expect(Dt(o._root)).eq(!0),t.expect(Dt(o.a._id)).eq(!0),t.expect(Dt(o.a._rev)).eq(!0),t.expect(Dt(o.a._root)).eq(!0),t.expect(Dt(o.b._id)).eq(!0),t.expect(Dt(o.b._rev)).eq(!0),t.expect(Dt(o.b._root)).eq(!0);const e=Mt(o._id);t.expect(o._id).eq(`${e}/0`),t.expect(o.a._id).eq(`${e}/1`),t.expect(o.b._id).eq(`${e}/2`),t.expect(o._root).eq(o._id),t.expect(o.a._root).eq(o._id),t.expect(o.b._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:i});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const n=yield i.get([o._id,o.a._id,o.b._id]);t.expect(n).to.be.an("array").that.have.lengthOf(3),Nt(n[0],{a:{check:"value",value:1},b:{check:"value",value:2},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}}),Nt(n[1],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}}),Nt(n[2],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}});const r=yield i.get([o._rev,o.a._rev,o.b._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(3),Nt(r[0],{b:{check:"value",value:1},__func:{check:"value",value:"update"},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}}),Nt(r[1],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}}),Nt(r[2],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:I}})})))),it("Should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield n.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work for a function that returns an array",(()=>{class e{constructor(){this.aa=1}createArray(){return this.a=new e,[new e,new e]}}let t;let o;let n;let r;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){r=new ft({mnemonic:Ht,path:zt()}),t=yield r.new(e,[]),[o,n]=yield t.createArray()})))),it("Should return an array",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{aa:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(n,{aa:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns an object created by a property wrapped as object",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}o(){return{o:this.a.f()}}}let o;let n;let r;let i;let c;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){c=new ft({mnemonic:Ht,path:zt()}),o=yield c.new(e,[]),r=yield c.new(t,[o]),n=yield r.g(),({o:i}=yield r.o())})))),it("Should return the object",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(i,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns an object created by a property wrapped in an array",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}o(){return[this.a.f()]}}let o;let n;let r;let i;let c;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){c=new ft({mnemonic:Ht,path:zt()}),o=yield c.new(e,[]),r=yield c.new(t,[o]),n=yield r.g(),[i]=yield r.o()})))),it("Should return the object",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(i,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns multiple objects created by a property wrapped in an array",(()=>{class e{f(){return new e}}class o{constructor(e){this.a=e}g(){return this.a.f()}o(){return[this.a.f(),this.a.f()]}}let n;let r;let i;let c;let s;let a;let d;let u;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){a=new ft({mnemonic:Ht,path:zt()}),d=new ft({mnemonic:Ht,path:zt()}),({db:u}=a),n=yield a.new(e,[]),i=yield a.new(o,[n]),r=yield i.g(),[c,s]=yield i.o()})))),it("Should update the smart object",(()=>S(void 0,void 0,void 0,(function*(){Nt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(r,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(c,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(s,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(i,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(i.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){const e=[n,r,c,s,i];for(let o=0;o<e.length;o+=1){const n=e[o];t.expect(Dt(n._id)).eq(!0),t.expect(Dt(n._rev)).eq(!0),t.expect(Dt(n._root)).eq(!0)}t.expect(n._id).not.eq(n._rev),t.expect(i._id).not.eq(i._rev),t.expect(r._id).eq(r._rev)})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:u});t.expect(yield e.get(n._rev)).to.deep.eq(n),t.expect(yield e.get(r._rev)).to.deep.eq(r),t.expect(yield e.get(i._rev)).to.deep.eq(i)})))),it("Should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield a.getLatestRev(n._id)).eq(n._rev),t.expect(yield a.getLatestRev(r._id)).eq(r._rev),t.expect(yield a.getLatestRev(i._id)).eq(i._rev)})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield d.sync(n._rev)).to.deep.eq(n),t.expect(yield d.sync(r._rev)).to.deep.eq(r),t.expect(yield d.sync(i._rev)).to.deep.eq(i)}))))})),describe("Should work for a function that returns multiple objects created by a property",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}o(){return this.a.f()}}let o;let n;let r;let i;let c;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){c=new ft({mnemonic:Ht,path:zt()}),o=yield c.new(e,[]),r=yield c.new(t,[o]),n=yield r.g(),i=yield r.o()})))),it("Should return the object",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(i,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns an object created by a property",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}}let o;let n;let r;let i;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){i=new ft({mnemonic:Ht,path:zt()}),o=yield i.new(e,[]),r=yield i.new(t,[o]),n=yield r.g()})))),it("Should return the object",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work when setting an owner",(()=>{class e{constructor(e){this._owners=[e]}updateOwner(e){this._owners=[e]}}let o;const n=new ft({chain:R,network:$});const r=n.db.wallet.publicKey.toString();let i;let c;let s;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){i=new ft({mnemonic:Ht,path:zt()}),s=i.db.wallet.publicKey.toString(),({db:c}=i),o=yield i.new(e,[s]),yield o.updateOwner(r)})))),it("Should update the smart object",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{_owners:{check:"value",value:[r]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){const e=Mt(o._id);t.expect(o._id).eq(`${e}/0`)})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const e=new yt({db:c});t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const[n]=yield c.get([o._id]);t.expect(n).to.deep.eq({__args:[s],__index:{obj:0},__cls:e.toString(),_amount:I,_owners:[s]});const[i]=yield c.get([o._rev]);t.expect(i).to.deep.eq({__func:"updateOwner",__args:[r],__index:{obj:0},_owners:[r],_amount:I})})))),it("Should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield i.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield n.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work with multiple computers",(()=>{class e{constructor(){this.n=1}inc(){this.n+=1}}let t=null;let o=null;let n;let r;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){n=new ft({mnemonic:Ht,path:zt()}),r=new ft({mnemonic:Ht,path:zt()}),t=yield n.new(e,[]),o=yield r.new(e,[]),yield t.inc()})))),it("should work",(()=>{Nt(t,{n:{check:"value",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Nt(o,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))}))})),describe("sync",(()=>{class e{constructor(e,t){this.n=e,this._owners=[t]}}let o;const n=Math.random();let r;let i;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){r=new ft({path:zt(),mnemonic:Ht}),i=r.db.wallet.publicKey.toString(),o=yield r.new(e,[n,i])})))),it("Should create another instance of the same smart object",(()=>S(void 0,void 0,void 0,(function*(){Nt(o,{n:{check:"value",value:n},_owners:{check:"value",value:[i]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}});const e=Kt();const r=yield e.sync(o._rev);t.expect(r).to.deep.eq(o)})))),it("throw an error if no params are passed to sync function",(()=>S(void 0,void 0,void 0,(function*(){const e=Kt();try{yield e.sync(),t.expect(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t.expect(e.message).eq("Invalid outId: undefined")}})))),it("throw an error if rev is not in the right format: tdId:num",(()=>S(void 0,void 0,void 0,(function*(){const e=Kt();try{yield e.sync("123"),t.expect(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t.expect(e.message).eq("Invalid outId: 123")}})))),it("throw an error if trId in rev is not 64 hex characters",(()=>S(void 0,void 0,void 0,(function*(){const e=Kt();try{yield e.sync("123:0"),t.expect(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t.expect(e.message).eq("Invalid outId: 123:0")}})))),it("throw an error if trId in rev is contains non hex characters",(()=>S(void 0,void 0,void 0,(function*(){const e=Kt();try{yield e.sync("31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844g:0"),t.expect(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t.expect(e.message).eq("Invalid outId: 31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844g:0")}})))),it("throw an error if num in rev is not a number",(()=>S(void 0,void 0,void 0,(function*(){const e=Kt();try{yield e.sync("31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844f:abc"),t.expect(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t.expect(e.message).eq("Invalid outId: 31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844f:abc")}}))))})),describe("getBalance",(()=>{it("Should return the network",(()=>S(void 0,void 0,void 0,(function*(){const e=new ft;t.expect(typeof(yield e.getBalance())).to.eq("number")}))))})),describe.skip("Query",(()=>{class o{constructor(){this.n=1}}let n;let r;it("Should work with a string encoded public key",(()=>S(void 0,void 0,void 0,(function*(){r=new ft({mnemonic:Ht,path:zt()}),n=yield r.new(o);const e=r.getPublicKey();const i=yield r.query({publicKey:e});t.expect(i.length).to.eq(1);const[c]=i;t.expect(typeof c).to.eq("string"),t.expect(c).to.eq(n._rev)})))),it("Should work with a public key",(()=>S(void 0,void 0,void 0,(function*(){r=new ft({mnemonic:Ht,path:zt()}),n=yield r.new(o);const i=r.getPublicKey();const c=yield r.query({publicKey:new e.Bitcoin.PublicKey(i)});t.expect(c.length).to.eq(1);const[s]=c;t.expect(typeof s).to.eq("string"),t.expect(s).to.eq(n._rev)})))),it("Should work with a class",(()=>S(void 0,void 0,void 0,(function*(){r=new ft({mnemonic:Ht,path:zt()}),n=yield r.new(o);const e=yield r.query({contract:o});t.expect(e.length).to.be.above(1);const[i]=e;t.expect(typeof i).to.eq("string"),t.expect(e.includes(n._rev)).to.be.true})))),it("Should work with a class string",(()=>S(void 0,void 0,void 0,(function*(){r=new ft({mnemonic:Ht,path:zt()}),n=yield r.new(o);const e=yield r.query({contract:o.toString()});t.expect(e.length).to.be.above(1);const[i]=e;t.expect(typeof i).to.eq("string"),t.expect(e.includes(n._rev)).to.be.true})))),it("Should work with a class and a public key",(()=>S(void 0,void 0,void 0,(function*(){r=new ft({mnemonic:Ht,path:zt()}),n=yield r.new(o);const e=r.getPublicKey();const i=yield r.query({contract:o,publicKey:e});t.expect(i.length).to.eq(1);const[c]=i;t.expect(typeof c).to.eq("string"),t.expect(c).to.eq(n._rev)}))))})),describe("Deploy",(()=>{describe("Should create a smart object from a deployed module",(()=>S(void 0,void 0,void 0,(function*(){let e;let o;let n;let r;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){o=new ft({mnemonic:Ht,path:zt()}),n=new ft({mnemonic:Ht,path:zt()}),({db:r}=o);const t=yield o.deploy("export class A {\n        constructor() {\n          this.n = 1\n        }\n      }");e=yield o.new("A",[],t)})))),it("Should create a smart object when computer.new is called",(()=>S(void 0,void 0,void 0,(function*(){Nt(e,{n:{check:"value",type:"number",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(e._id).eq(e._rev),t.expect(e._id).eq(e._root),t.expect(Dt(e._id)),t.expect(Dt(e._rev)),t.expect(Dt(e._root))})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const o=new yt({db:r});t.expect(yield o.get(e._rev)).to.deep.eq(e)})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const o=yield r.get([e._rev]);t.expect(o).to.be.an("array").that.have.lengthOf(1),t.expect(o[0].__index).to.deep.eq({obj:0}),t.expect(o[0].__expt).to.eq("A"),ue(o[0].__mdl)})))),it("should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield o.getLatestRev(e._id)).eq(e._rev)})))),it("should work with idsToRevs",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield o.idsToRevs([e._id])).to.deep.eq([e._rev])})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield n.sync(e._rev)).to.deep.eq(e)}))))})))),describe("Should increment a smart counter from a deployed module",(()=>S(void 0,void 0,void 0,(function*(){let e;let o;let n;let r;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){o=new ft({mnemonic:Ht,path:zt()}),n=new ft({mnemonic:Ht,path:zt()}),({db:r}=o);const t=yield o.deploy("export class A {\n        constructor() {\n          this.n = 1\n        }\n\n        inc() {\n          this.n += 1\n        }\n      }");e=yield o.new("A",[],t),yield e.inc()})))),it("Should update the smart object when inc is called",(()=>S(void 0,void 0,void 0,(function*(){Nt(e,{n:{check:"value",type:"number",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(e._id).to.not.eq(e._rev),t.expect(e._id).eq(e._root),t.expect(Dt(e._id)),t.expect(Dt(e._rev)),t.expect(Dt(e._root))})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const o=new yt({db:r});t.expect(yield o.get(e._rev)).to.deep.eq(e)})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const o=yield r.get([e._id]);t.expect(o).to.be.an("array").that.have.lengthOf(1),t.expect(o[0].__index).to.deep.eq({obj:0}),t.expect(o[0].__expt).to.eq("A"),ue(o[0].__mdl);const n=yield r.get([e._rev]);t.expect(n).to.be.an("array").that.have.lengthOf(1),t.expect(n[0].__index).to.deep.eq({obj:0}),t.expect(n[0].__args).to.deep.eq([]),t.expect(n[0].__func).to.eq("inc")})))),it("should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield o.getLatestRev(e._id)).eq(e._rev)})))),it("should work with idsToRevs",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield o.idsToRevs([e._id])).to.deep.eq([e._rev])})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield n.sync(e._rev)).to.deep.eq(e)}))))})))),describe("Should return an object from a different class from a constructor or function call",(()=>S(void 0,void 0,void 0,(function*(){let e;let o;let n;let r;let i;before("Before Computer",(()=>S(void 0,void 0,void 0,(function*(){n=new ft({mnemonic:Ht,path:zt()}),r=new ft({mnemonic:Ht,path:zt()}),({db:i}=n);const t=yield n.deploy("\n        export class A {\n          constructor() {\n            this.n = 1\n          }\n        }\n\n        export class B {\n          constructor() {\n            this.m = new A()\n          }\n\n          getA() {\n            return new A()\n          }\n        }");o=yield n.new("B",[],t),e=yield o.getA()})))),it("Should update the smart object when inc is called",(()=>S(void 0,void 0,void 0,(function*(){t.expect(e.n).to.eq(1),t.expect(e._id).to.be.a("string"),t.expect(e._rev).to.be.a("string"),t.expect(e._root).to.be.a("string"),t.expect(o._id).to.be.a("string"),t.expect(o._rev).to.be.a("string"),t.expect(o._root).to.be.a("string"),Nt(o.m,{n:{check:"value",type:"number",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>S(void 0,void 0,void 0,(function*(){t.expect(e._id).to.eq(e._rev),t.expect(e._root).to.eq(o._root),t.expect(Dt(e._id)),t.expect(Dt(e._rev)),t.expect(Dt(e._root)),t.expect(o._id).not.to.eq(o._rev),t.expect(o._root).to.eq(e._root),t.expect(Dt(o._id)),t.expect(Dt(o._rev)),t.expect(Dt(o._root))})))),it("Should return the object if reader.get is called",(()=>S(void 0,void 0,void 0,(function*(){const o=new yt({db:i});t.expect(yield o.get(e._rev)).to.deep.eq(e)})))),it("Should broadcast a transaction with an output containing data",(()=>S(void 0,void 0,void 0,(function*(){const o=yield i.get([e._id]);t.expect(o).to.be.an("array").that.have.lengthOf(1),t.expect(o[0].__cls.substring(0,5)).to.eq("class")})))),it("should work with getLatestRev",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield n.getLatestRev(e._id)).eq(e._rev)})))),it("should work with idsToRevs",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield n.idsToRevs([e._id])).to.deep.eq([e._rev])})))),it("Should work with sync",(()=>S(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(e._rev)).to.deep.eq(e)}))))}))))}))}));
