"use strict";var t=require("bitcoin-computer-bitcore");require("ses");var e=require("axios");var o=require("crypto");var n=require("crypto-js");var r=require("eciesjs");var i=require("http");var c=require("https");var s=require("url");var a=require("util");function d(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}function u(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(o){if("default"!==o){var n=Object.getOwnPropertyDescriptor(t,o);Object.defineProperty(e,o,n.get?n:{enumerable:!0,get:function(){return t[o]}})}})),e.default=t,Object.freeze(e)}var l=d(e);var _=d(o);var p=d(n);var v=u(r);var h=d(i);var g=d(c);var y=d(s);var f=d(a);function x(t,e){var o={};for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&e.indexOf(n)<0&&(o[n]=t[n]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(n=Object.getOwnPropertySymbols(t);r<n.length;r++)e.indexOf(n[r])<0&&Object.prototype.propertyIsEnumerable.call(t,n[r])&&(o[n[r]]=t[n[r]])}return o}function S(t,e,o,n){var r,i=arguments.length,c=i<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,o):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)c=Reflect.decorate(t,e,o,n);else for(var s=t.length-1;s>=0;s--)(r=t[s])&&(c=(i<3?r(c):i>3?r(e,o,c):r(e,o))||c);return i>3&&c&&Object.defineProperty(e,o,c),c}function w(t,e,o,n){return new(o||(o=Promise))((function(r,i){function c(t){try{a(n.next(t))}catch(t){i(t)}}function s(t){try{a(n.throw(t))}catch(t){i(t)}}function a(t){var e;t.done?r(t.value):(e=t.value,e instanceof o?e:new o((function(t){t(e)}))).then(c,s)}a((n=n.apply(t,e||[])).next())}))}const b=t=>new Compartment({}).evaluate(t);const m=(t,e,o)=>new Compartment({target:t,thisArgument:e,argumentsList:o}).evaluate("Reflect.apply(target, thisArgument, argumentsList)");const O=(t,e)=>new Compartment({target:t,argumentsList:e}).evaluate(`Reflect.construct(${t}, argumentsList)`);const{crypto:E}=t.Bitcoin;const N=(t,e)=>{const o=Date.now();const n=E.Hash.sha256(Buffer.from(e+o));const r=[E.ECDSA.sign(n,t,"big").toString("hex"),t.publicKey.toString(),o];return`Bearer ${Buffer.from(r.join(":")).toString("base64")}`};const{Transaction:B}=t.Bitcoin;function j(t){return w(this,void 0,void 0,(function*(){if(!function(t){return void 0!==t.config}(t))throw new Error("Unknown error");const{message:e,config:o,response:n}=t;const r=function(t){try{const e=JSON.parse(t);if("object"!=typeof e)throw new Error("Invalid object");if("string"!=typeof e.txhex)throw new Error("Invalid object");return new B(e.txhex)}catch(t){return null}}(null==o?void 0:o.data);const i=`message\t${e}`;const c=`request\t${null==o?void 0:o.method} ${null==o?void 0:o.url}`;const s=r?`transaction\t ${JSON.stringify(r.toJSON(),null,2)}`:"";const a="post"===(null==o?void 0:o.method)?`data\t${null==o?void 0:o.data}`:"";const d=n?`response\t${JSON.stringify(n.data)}`:"";const u=r?s:a;throw t.message=`\n    Communication Error\n    ${i}\n    ${c}\n    ${u}\n    ${d}`,t}))}class T{constructor(t,e,o={}){this.baseUrl=t,this.headers=o,this.privateKey=e}get(t){return w(this,void 0,void 0,(function*(){const e=`${this.baseUrl}${t}`;try{let t={};return this.privateKey&&(t={Authentication:N(this.privateKey,this.baseUrl)}),(yield l.default.get(e,{headers:Object.assign(Object.assign({},this.headers),t)})).data}catch(t){return j(t)}}))}post(t,e){return w(this,void 0,void 0,(function*(){const o=`${this.baseUrl}${t}`;try{let t={};return this.privateKey&&(t={Authentication:N(this.privateKey,this.baseUrl)}),(yield l.default.post(o,e,{headers:Object.assign(Object.assign({},this.headers),t)})).data}catch(t){return j(t)}}))}delete(t){return w(this,void 0,void 0,(function*(){const e=`${this.baseUrl}${t}`;try{let t={};return this.privateKey&&(t={Authentication:N(this.privateKey,this.baseUrl)}),(yield l.default.delete(e,{headers:Object.assign(Object.assign({},this.headers),t)})).data}catch(t){return j(t)}}))}}const{PrivateKey:A,Transaction:R}=t.Bitcoin;const{UnspentOutput:I}=R;function U(t){if(!/^[0-9A-Fa-f]{64}$/.test(t))throw new Error(`Invalid txId: ${t}`)}function C(t){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(t))throw new Error(`Invalid outId: ${t}`)}function q(t){C(t);const[e,o]=t.split("/");return{txId:e,outputIndex:parseInt(o,10)}}let P=class{constructor(t,e=new A){this.nodeConfig=t,this.bcn=new T(t.url,e)}get chain(){return this.nodeConfig.chain}get network(){return this.nodeConfig.network}getBalance(t){return w(this,void 0,void 0,(function*(){const{chain:e,network:o}=this;return yield this.bcn.get(`/v1/${e}/${o}/address/${t}/balance`)}))}getTransaction(t){return w(this,void 0,void 0,(function*(){return new R(yield this.getRawTx(t))}))}getRawTx(t){return w(this,void 0,void 0,(function*(){U(t);const{chain:e,network:o}=this;return this.bcn.get(`/v1/${e}/${o}/tx/${t}`)}))}getTransactions(t){return w(this,void 0,void 0,(function*(){return(yield this.getRawTxs(t)).map((t=>new R(t)))}))}getRawTxs(t){return w(this,void 0,void 0,(function*(){t.map(U);const{chain:e,network:o}=this;return this.bcn.post(`/v1/${e}/${o}/tx/bulk/`,{txIds:t})}))}sendTransaction(t){return w(this,void 0,void 0,(function*(){return this.bcn.post(`/v1/${this.chain}/${this.network}/tx/send`,{rawTx:t})}))}getUtxosFromAddress(t){return w(this,void 0,void 0,(function*(){const{chain:e,network:o}=this;return(yield this.bcn.get(`/v1/${e}/${o}/wallet/${t.toString()}/utxos`)).map((({rev:t,scriptPubKey:e,satoshis:o})=>{const[n,r]=t.split("/");return new I({txId:n,outputIndex:parseInt(r,10),satoshis:o,script:e})}))}))}getOwnedRevs(t){return w(this,void 0,void 0,(function*(){const{chain:e,network:o}=this;return this.bcn.get(`/v1/${e}/${o}/wallet/${t.toString()}/non-standard-utxos`)}))}queryRevs(t){return w(this,void 0,void 0,(function*(){const{publicKey:e,contractName:o,contractHash:n}=t;if(void 0===e&&void 0===o&&void 0===n)throw new Error("Filter parameter for queryRevs endpoint cannot be empty.");let r="";e&&(r+=`?publicKey=${e}`),o&&(r+=0===r.length?"?":"&",r+=`contractName=${o}`),n&&(r+=0===r.length?"?":"&",r+=`contractHash=${n}`);const{chain:i,network:c}=this;return this.bcn.get(`/v1/${i}/${c}/non-standard-utxos${r}`)}))}getLatestRev(t){return w(this,void 0,void 0,(function*(){C(t);const{chain:e,network:o}=this;const[{rev:n}]=yield this.bcn.get(`/v1/${e}/${o}/rev/${t}`);return n}))}getLatestRevs(t){return w(this,void 0,void 0,(function*(){t.map(C),t.map(C);const{chain:e,network:o}=this;return yield this.bcn.post(`/v1/${e}/${o}/revs`,{ids:t})}))}static getSecretOutput({_url:t,privateKey:e}){return w(this,void 0,void 0,(function*(){const o=t.split("/");const n=o[o.length-1];const r=o.slice(0,-2).join("/");const i=new T(r,e);return{host:r,data:yield i.get(`/v1/store/${n}`)}}))}static setSecretOutput({secretOutput:t,host:e,privateKey:o}){return w(this,void 0,void 0,(function*(){return new T(e,o).post("/v1/store/",t)}))}static deleteSecretOutput({_url:t,privateKey:e}){return w(this,void 0,void 0,(function*(){const o=t.split("/");const n=o[o.length-1];const r=o.slice(0,-2).join("/");const i=new T(r,e);yield i.delete(`/v1/store/${n}`)}))}};P=S([t=>t],P);const k=["_id","_rev","_owners","_amount","_readers","_url","__vouts","__func","__index","__args"];const M=t=>(Object.prototype.toString.call(t).match(/\s([a-zA-Z]+)/)||[])[1];const $=t=>"object"==typeof t?M(t):M(t).toLowerCase();const D=t=>["number","string","boolean","undefined","Null"].includes($(t));const L=t=>"Array"===$(t);const K=t=>"Object"===$(t);const H=t=>D(t)||["Array","Object"].includes($(t));const W=(t,e)=>{if(!H(t)||!H(e))throw new Error(`Unsupported data types for deep equals: ${$(t)} & ${$(e)}`);if($(t)!==$(e))return!1;if(D(t)&&D(e))return t===e;const o=(t,e)=>Object.entries(t).every((([t,o])=>W(e[t],o)));return t&&e&&o(t,e)&&o(e,t)};const F=t=>{if(D(t))return t;if(L(t))return t.map(F);if(K(t)){const e=Object.keys(t).reduce(((e,o)=>(e[o]=F(t[o]),e)),{});const o=Object.create(Object.getPrototypeOf(t));return Object.assign(o,e)}throw new Error(`Unsupported data type for clone: ${$(t)}`)};const G=(t,e)=>Object.fromEntries(Object.entries(t).map((t=>e(t))));const J=(t,e)=>G(t,(([t,o])=>[t,e(o)]));const z=(t,e)=>Object.fromEntries(Object.entries(t).filter((t=>e(t))));const Y=(t,e,o,n)=>{if(D(t))return t;if(L(t))return t.map((t=>Y(t,e,o,n)));if(K(t)){t._rev=`${n}/${o}`;const r=e[o];return Object.entries(t).forEach((([o,i])=>{"object"==typeof r&&Object.keys(r).includes(o)&&(t[o]=Y(i,e,r[o],n))})),t}throw new Error(`Unsupported type ${$(t)} in deep.updateRev`)};const Z=(t,e)=>{if(D(t))return t;if(L(t))return t.map((t=>Z(t,e)));if(K(t))return t._id=!t._id||t._id.startsWith("__temp__")?t._rev:t._id,t._root=t._root||e,Object.entries(t).forEach((([o,n])=>{t[o]=Z(n,e)})),t;throw new Error(`Unsupported type ${$(t)} in deep.addId`)};const X=t=>{if(D(t))return t;if(L(t))return t.map((t=>X(t)));if(K(t)){const e=`__temp__/${Math.random()}`;return t._id=t._id||e,t._rev=t._rev||e,Object.values(t).map((t=>X(t))),t}throw new Error(`Unsupported type ${$(t)} in addRandomId`)};const V=t=>{if(D(t))return t;if(L(t))return t.map((t=>V(t)));if(K(t))return G(t,(([t,e])=>["_owners","_readers"].includes(t)?[t,JSON.stringify(e)]:D(e)?[t,e]:[t,V(e)]));throw new Error(`Unexpected type ${$(t)} in stringifyOwners`)};const Q=t=>(t._owners&&(t._owners=JSON.parse(t._owners)),t._readers&&(t._readers=JSON.parse(t._readers)),t);const tt=t=>{if(D(t))return t;if(L(t)||K(t))return Object.entries(t).reduce(((t,[e,o])=>{const n=tt(o);return(t=>"Object"===$(t)&&Object.keys(t).every((t=>!Number.isNaN(parseInt(t,10)))))(n)?Object.entries(n).forEach((([o,n])=>{t[`${e}_${o}`]=n})):t[e]=n,t}),{});throw new Error(`Unsupported type ${$(t)} in encodeArraysAsObjects`)};const et=t=>{const e={[t._id]:Object.entries(t).reduce(((t,[e,o])=>k.includes(e)?Object.assign(Object.assign({},t),{[e]:o}):D(o)?Object.assign(Object.assign({},t),{[`__basic__${e}`]:o}):Object.assign(Object.assign({},t),{[e]:o._id})),{})};return Object.values(t).filter((t=>!D(t))).reduce(((t,e)=>Object.assign(Object.assign({},t),et(e))),e)};const ot=t=>z(t,(([t])=>!t.startsWith("__basic__")));const nt=(t,e)=>{const o=t[e];return o.__contains=Object.entries(o).reduce(((e,[o,n])=>["__contains",...k].includes(o)?e:"__change"===o?"new"===n||"diff"===n||e:nt(t,n)[n].__contains||e),!1),t};const rt=(t,e)=>t.map((t=>Object.entries(t).reduce(((t,[o,n])=>{const r="string"==typeof n&&"undefined"!==$(e[n])?e[n]:n;return Object.assign(Object.assign({},t),{[o]:r})}),{})));class ct{constructor(t){this.db=t}get(t){return w(this,void 0,void 0,(function*(){const{txId:e,outputIndex:o}=q(t);const{inRevs:n,outData:r}=yield this.db.fromTxId(e);if(!Array.isArray(n)||!Array.isArray(r)||0===r.length)return;const i=r[0].__index||{};const c=r[i.obj].__cls||"";const s=r[i.obj].__func||"";const a=r[i.obj].__args||[];const d=yield Promise.all(Object.values(i).map((t=>{const e=n[t];return e?this.get(e):Promise.resolve({})})));const u=Object.keys(i).map(((t,e)=>[t,d[e]]));const l=Object.fromEntries(u);let _=l.obj;delete l.obj;const p=Object.entries(l).reduce(((t,[e,o])=>{const n=parseInt(e,10);return Number.isNaN(n)||(t[n]=o),t}),[]);const v=function(t,e){let o=0;return e.map((e=>"__"===e?t[o++]:e))}(p,a);let h;if("constructor"===s){const t=b(`(${c})`);_=O(t,v)}else h=m(_[s].bind(_),_,v);Object.entries(i).forEach((([t,o])=>{const n=parseInt(t,10);let i=p[n];"obj"===t?i=_:"res"===t&&(i=h),Y(i,r,o,e)}));const g=_._root||`${e}/${i.obj}`;return Z([h,_,...p],g),[...p,_,h][o]}))}}function st(t){return{smartArgs:t.filter((t=>t._rev)),dumbArgs:t.map((t=>t._rev?"__":t))}}class at{constructor(t){this.db=t,at.proxyDepth=at.proxyDepth||0}static getUpdate(t){return w(this,void 0,void 0,(function*(){let e;let o;let n;let r;let i;let c;let s;if("Cls"in t){const{Cls:a}=t;const d=t.args||[];e=a.toString(),o=null,n=O(a,d),r=F(d),i=d,c=null,s=void 0}else{const{target:a,property:d,args:u}=t;e=null,o=F(a),n=a,r=F(u),i=u,c=d,this.proxyDepth+=1,s=m(a[d],a,i),this.proxyDepth-=1}const{smartArgs:a,dumbArgs:d}=st(r);const{smartArgs:u}=st(i);const l=Object.assign(Object.assign(Object.assign({},a),{obj:o}),{_id:"index"});const _=Object.assign(Object.assign(Object.assign({},u),{obj:n}),{_id:"index"});["Object","Array"].includes($(s))&&(_.res=s);const[p,v,h]=((t,e)=>{const o=X(e);const n=o._id;const r=F(t);const i=F(o);const c=V(r);const s=V(i);const a=tt(c);const d=tt(s);const u=((t,e)=>G(e,(([e,o])=>{const n=t[e];var r;return o.__change=(r=n)?W(r,o)?"same":"diff":"new",[e,o]})))(et(a),et(d));const l=J(u,ot);const _=nt(l,n);const p=_[n];delete _[n];const v=J(_,(t=>t._rev));const h=(g=t=>t.__contains||Object.values(p).includes(t._id),z(_,(([,t])=>g(t))));var g;const y=Object.values(h);const[f,S]=(w=t=>"new"===t.__change,y.reduce((([t,e],o,n)=>w(o)?[[...t,o],e]:[t,[...e,o]]),[[],[]]));var w;const b=[...S,...f];const m=(t=>t.reduce(((t,e,o)=>Object.assign(Object.assign({},t),{[e._id]:o})),{}))(b);const O=rt(b,m);const[E]=rt([p],m);const N=S.map((t=>t._rev));const[B,...j]=((t,e)=>[e,...t].map((t=>{const e=x(t,["_id","_rev","__change","__contains"]);return z(e,(([t,e])=>k.includes(t)||"number"==typeof e))})))(O,E);return[N,j.map(Q).map((t=>Object.entries(t).reduce(((t,[e,o])=>Object.assign(Object.assign({},t),{[e]:v[o]||o})),{}))),B]})(l,_);void 0!==v[0]&&(v[0].__index=h);const g=h.obj;void 0!==v[g]&&(null!==e&&(v[g].__cls=e),v[g].__func=null===c?"constructor":String(c),v[g].__args=d);const y=h.res;return void 0!==v[y]&&"function Object() { [native code] }"!==s.constructor.toString()&&(v[y].__cls=s.constructor.toString()),[p,v,n,u,s,h]}))}allocate(t,e){return w(this,void 0,void 0,(function*(){const[o,n,r,i,,c]=yield at.getUpdate({Cls:t,args:e});const[s]=yield this.db.update(o,n);const{txId:a}=q(s);Object.entries(c).forEach((([t,e])=>{const o=parseInt(t,10);let c=i[o];"obj"===t&&(c=r),Y(c,n,e,a)}));const d=`${a}/${c.obj}`;return Z([r,...i],d),r}))}update(t,e,o){return w(this,void 0,void 0,(function*(){const[n,r,,i,c,s]=yield at.getUpdate({target:t,property:e,args:o});const[a]=yield this.db.update(n,r);const{txId:d}=q(a);Object.entries(s).forEach((([e,o])=>{const n=parseInt(e,10);let s=i[n];"obj"===e?s=t:e.startsWith("res")&&(s=c),Y(s,r,o,d)}));const u="string"==typeof t._root?t._root:`${d}/${s.obj}`;return Z([c,t,...i],u),c}))}get(t,e){return at.proxyDepth>0||"function"!=typeof t[e]?Reflect.get(t,e):(...o)=>this.update(t,e,o)}}const dt=parseInt(process.env.BC_DUST_LIMIT||"",10)||1546;const ut=parseInt(process.env.BC_DEFAULT_FEE||"",10)||2500;var lt={MIN_NON_DUST_AMOUNT:dt,SCRIPT_CHUNK_SIZE:parseInt(process.env.BC_SCRIPT_CHUNK_SIZE||"",10)||479,DEFAULT_FEE:ut,SIGHASH_ALL:1,FEE_PER_KB:2e4,PUBLIC_KEY_SIZE:65,ANYONE_CAN_SPEND_SEED:"replace this seed",PASSPHRASE:"",ENCODING_LENGTH:3,ENCODING_NUMBER_LENGTH:3,MAX_PUBKEYS_PER_SCRIPT:3,OP_RETURN_SIZE:80};const{PublicKey:_t,crypto:pt}=t.Bitcoin;const{Point:vt}=pt;function ht(t){return Buffer.from(t,"hex").toString().replace(/\0/g,"")}function gt(t,e){return t.slice(e)+t.slice(0,e)}function yt(t,e,o){if(t.length*Math.log2(e)>53)throw new Error(`Input too large ${t.length} ${Math.log2(e)}`);if(![2,10,16].includes(e)||![2,10,16].includes(o))throw new Error("ToBase or FromBase invalid in covertNumber.");if(2===e&&t.length%8!=0)throw new Error("Binary strings must be byte aligned.");if(16===e&&t.length%2!=0)throw new Error("Hex strings must be of even length.");const n=parseInt(t,e).toString(o);return 2===o?n.padStart(8*Math.ceil(n.length/8),"0"):16===o?n.padStart(2*Math.ceil(n.length/2),"0"):n}function ft(t,e){const o=new RegExp(`.{1,${e}}`,"g");return t.match(o)||[]}function xt(t){return ft(t,2).map((t=>yt(t,16,2))).join("")}function St(t){return ft(t,8).map((t=>yt(t,2,16))).join("")}function wt(t){return t.toString(16).padStart(lt.ENCODING_NUMBER_LENGTH,"0")}function bt(t){return parseInt(t,16)}function mt(t){if(62!==t.length)throw new Error("Input to hexToPublicKey must be of length 62");let e=!1;let o=0;let n;for(;!e;){if(o>=256)throw new Error("Something went wrong storing data");const r=o.toString(16).padStart(2,"0")+St(gt(xt(t).padStart(64,"0"),o));try{n=vt.fromX(!1,r),e=!0}catch(t){o+=1}}if(!n)throw new Error("Something went wrong storing data");return new _t(n)}function Ot(t){const e=t.point.getX().toString("hex").padStart(64,"0");const o=yt(e.slice(0,2),16,10);return St((r=parseInt(o,10),(n=xt(e.slice(2))).slice(-r)+n.slice(0,-r)));var n,r}function Et(t){return new Promise((e=>{setTimeout(e,t)}))}function Nt(t,e){return`m/44'/${function(t,e){if("testnet"===e||"regtest"===e)return"1";if("BTC"===t)return"0";if("LTC"===t)return"2";if("DOGE"===t)return"3";if("BCH"===t)return"145";if("BSV"===t)return"236";throw new Error(`Unsupported chain ${t}`)}(t,e)}'/0'/0/0`}const{PublicKey:Bt,Script:jt}=t.Bitcoin;function Tt(t){if(t.length>lt.MAX_PUBKEYS_PER_SCRIPT)throw new Error("Too many owners");return function(t){const e=new jt;return e.add("OP_1"),t.forEach((t=>{e.add(t)})),e.add(`OP_${t.length}`),e.add("OP_CHECKMULTISIG"),e}(t.map((t=>t.toBuffer())))}function At(t){return function(t){return t.chunks.filter((t=>t.buf)).map((t=>t.buf))}(t).map((t=>Bt.fromBuffer(t)))}function Rt(t){return Buffer.from(p.default.SHA256(t).toString(),"hex").toString("hex").substr(0,4)}function It(t){return`${Rt(t)};${t}`}function Ut(t){const e=t.substr(0,4);const o=t.substr(5);if(!function(t,e){return Rt(t)===e}(o,e))throw new Error("Decryption failure");return o}function Ct(t){if(void 0!==t._readers){const{_readers:e,_url:o,_owners:n,_amount:r}=t,i=x(t,["_readers","_url","_owners","_amount"]);const c=function(t,e){const o=_.default.randomBytes(32).toString("hex");const n=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const o=Buffer.from(e,"hex").toString("binary");const n=It(t);return p.default.AES.encrypt(n,o).toString()}(t,o);const r=e.map((t=>function(t,e){if(!/^0[2-3][0-9a-f]{64}|04[0-9a-f]{128}$/.test(e))throw new Error("Invalid publicKey");const o=It(t);return v.encrypt(e,Buffer.from(o,"utf8")).toString("base64")}(o,t)));return{__cypher:n,__secrets:r}}(JSON.stringify(i),e);return void 0!==o&&(c._url=o),void 0!==n&&(c._owners=n),void 0!==r&&(c._amount=r),c}return t}const{Transaction:qt}=t.Bitcoin;const{Output:Pt}=qt;const{UnspentOutput:kt}=qt;let Mt=class{constructor(t,e,o){const n=new qt(o);n.feePerKb(lt.FEE_PER_KB),this.nodeConfig=t,this.tx=n,this.outData=[],this.privateKey=e}get txId(){return this.tx.id}get chain(){return this.nodeConfig.chain}get network(){return this.nodeConfig.network}get restClient(){return new P(this.nodeConfig,this.privateKey)}get inputs(){return this.tx.inputs.map((t=>`${t.prevTxId.toString("hex")}/${t.outputIndex}`))}get inRevs(){const{enc:t}=this;let[e]=t;return e=Number.isFinite(e)?e:0,this.tx.inputs.slice(0,e).map((({prevTxId:t,outputIndex:e})=>`${t.toString("hex")}/${e}`))}get outRevs(){const{enc:t}=this;let[,e]=t;return e=Number.isFinite(e)?e:0,Array.from(Array(e).keys()).map((t=>`${this.tx.id}/${t}`))}get opReturns(){try{const{outputs:t}=this.tx;return t.filter((({script:t})=>t.isDataOut())).map((({script:t})=>t.getData())).map((t=>t.toString())).join()}catch(t){return""}}get enc(){return ft(this.opReturns.slice(0,lt.ENCODING_LENGTH*lt.ENCODING_NUMBER_LENGTH),lt.ENCODING_NUMBER_LENGTH).map(bt)}get dataPrefix(){return this.opReturns.slice(9)}getOwnerOutputs(){const{enc:t}=this;const[,e=0]=t;return this.tx.outputs.slice(0,e)}getDataOutputs(){const{enc:t}=this;const[,e,o]=t;return this.tx.outputs.slice(e,o)}getOutData(t){return w(this,void 0,void 0,(function*(){try{const e=this.getDataOutputs().map((t=>t.script)).map((t=>At(t))).flat().map(Ot).map(ht).join("");const{dataPrefix:o}=this;const n=JSON.parse(o+e);const r=t.toBuffer().toString("hex");const i=this.getOwnerOutputs();if(i.length!==n.length)throw new Error("Inconsistent state");const c=i.map(((t,e)=>Object.assign(Object.assign({},n[e]),{_owners:At(t.script).map((t=>t.toString())),_amount:t.satoshis})));return Promise.all(c.map((e=>w(this,void 0,void 0,(function*(){try{const o=yield function(t){return e=>w(this,void 0,void 0,(function*(){if(function(t){return void 0!==t._url}(e)){const{_url:o}=e,n=x(e,["_url"]);const{host:r,data:i}=yield P.getSecretOutput({_url:o,privateKey:t});return Object.assign(Object.assign(Object.assign({},n),JSON.parse(i)),{_url:r})}return e}))}(t)(e);return function(t,e){if(function(t){return void 0!==t.__cypher&&void 0!==t.__secrets}(t)){const{__cypher:o,__secrets:n}=t,r=x(t,["__cypher","__secrets"]);return Object.assign(Object.assign(Object.assign({},r),JSON.parse(function({__cypher:t,__secrets:e},o){let n="";if(o.forEach((o=>{e.forEach((e=>{try{const r=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid privateKey");return Ut(v.decrypt(e,Buffer.from(t,"base64")).toString("utf8"))}(e,o);n=function(t,e){if(!/^[0-9a-f]{64}$/.test(e))throw new Error("Invalid secret");const o=Buffer.from(e,"hex").toString("binary");return Ut(p.default.AES.decrypt(t,o).toString(p.default.enc.Utf8))}(t,r)}catch(t){const e=["Decryption failure","Unsupported state or unable to authenticate data"];if(t instanceof Error&&!e.includes(t.message))throw t}}))})),n)return n;throw new Error("Decryption failure")}({__cypher:o,__secrets:n},e))),{_readers:[]})}return t}(o,[r])}catch(t){return null}})))))}catch(t){return[]}}))}getOwners(){return this.getOwnerOutputs().map((t=>At(t.script).map((t=>t.toString()))))}getAmounts(){return this.getOwnerOutputs().map((t=>t.satoshis))}spendFromData(e){return w(this,void 0,void 0,(function*(){if(!e.length)return;const o=e.map(q);const n=o.map((t=>t.txId));const r=yield this.restClient.getTransactions(n);for(let e=0;e<o.length;e+=1){const{txId:n,outputIndex:i}=o[e];const{outputs:c}=r[e];const s=c[i];const a=Math.round(s.satoshis);const d=new t.Bitcoin.Script(s.script);const u=new kt({txId:n,outputIndex:i,satoshis:a,script:d});const l=At(d).map((t=>t.toString()));this.tx.from([u],l,1)}}))}createOpReturnOut(t){this.tx.addData(JSON.stringify(t))}createDataOuts(e){e.forEach((({_amount:e,_owners:o=[]})=>{if(Array.isArray(o)&&o.length>lt.MAX_PUBKEYS_PER_SCRIPT)throw new Error("Too many owners.");const n=o.map((e=>t.Bitcoin.PublicKey.fromString(e)));const r=e||lt.MIN_NON_DUST_AMOUNT;const i=Tt(n);this.tx.addOutput(new Pt({script:i,satoshis:r}))}));const o=e.map((t=>x(t,["_amount","_owners"])));const n=lt.MIN_NON_DUST_AMOUNT;const r=JSON.stringify(o);const i=lt.OP_RETURN_SIZE-lt.ENCODING_LENGTH*lt.ENCODING_NUMBER_LENGTH;const c=r.slice(0,i);const s=function(t){var e;return function(t,e){const o=[];for(let n=0;n<t.length;n+=e)o.push(t.slice(n,n+e));return o}(ft((e=t,Buffer.from(e).toString("hex")),62).map((t=>t.padStart(62,"0"))).map(mt),lt.MAX_PUBKEYS_PER_SCRIPT).map((t=>Tt(t)))}(r.slice(i));const a=wt(this.tx.inputs.length)+wt(this.tx.outputs.length)+wt(this.tx.outputs.length+s.length);s.forEach((t=>{this.tx.addOutput(new Pt({script:t,satoshis:n}))})),this.tx.addData(a+c)}static fromTxHex(t,e,o){return w(this,void 0,void 0,(function*(){const n=new this(e,o);n.tx.fromString(t);let r=[];let i=[];let c=[];try{r=yield n.getOutData(o)}catch(t){}try{i=n.getOwners()}catch(t){}try{c=n.getAmounts()}catch(t){}return n.outData=r.map(((t,e)=>Object.assign(Object.assign({},t),{_owners:i[e],_amount:c[e]}))),n}))}static fromTxId(t,e,o){return w(this,void 0,void 0,(function*(){const n=new P(e,o);const r=yield n.getRawTx(t);return this.fromTxHex(r,e,o)}))}};Mt=S([t=>t],Mt);class $t{constructor(t){this.wallet=t}get chain(){return this.wallet.chain}get network(){return this.wallet.network}get nodeConfig(){return this.wallet.nodeConfig}fromTxHex(t){return w(this,void 0,void 0,(function*(){const{wallet:e,nodeConfig:o}=this;const n=e.getPrivateKey();return Mt.fromTxHex(t,o,n)}))}fromTxId(t){return w(this,void 0,void 0,(function*(){const{wallet:e,nodeConfig:o}=this;const n=new P(o,e.getPrivateKey());const r=yield n.getRawTx(t);return this.fromTxHex(r)}))}get(t){return w(this,void 0,void 0,(function*(){const e=t.map(q);return Promise.all(e.map((({txId:t,outputIndex:e})=>w(this,void 0,void 0,(function*(){const{outData:o}=yield this.fromTxId(t);if(e>o.length)throw new Error("Index out of bounds");return o[e]})))))}))}put(t){return this.update([],t)}createTx(t,e){return w(this,void 0,void 0,(function*(){const{wallet:o,nodeConfig:n}=this;const r=o.getPrivateKey();const i=new Mt(n,r);const c=e.map((t=>{var{_owners:e}=t,o=x(t,["_owners"]);return Object.assign({_owners:e||[this.wallet.getPublicKey().toString()]},o)})).map(Ct);const s=yield Promise.all(c.map(function(t){return e=>w(this,void 0,void 0,(function*(){if(void 0!==e._url){const{_url:o,_owners:n,_amount:r}=e,i=x(e,["_url","_owners","_amount"]);const c=yield P.setSecretOutput({host:o,secretOutput:{data:JSON.stringify(i)},privateKey:t});return void 0!==n&&(c._owners=n),void 0!==r&&(c._amount=r),c}return e}))}(r)));return yield i.spendFromData(t),yield i.createDataOuts(s),i}))}update(t,e){return w(this,void 0,void 0,(function*(){const o=yield this.createTx(t,e);return yield this.wallet.fundAndSendTransaction(o),o.outRevs}))}}class Dt{constructor(t,e,o={}){const{chain:n,network:r}=e;const{path:i=Nt(n,r),passphrase:c=""}=o;let s=t.toHDPrivateKey(c,r);i&&(s=s.derive(i));const a=s.publicKey.toAddress(r);this.mnemonic=t,this.restClient=e,this.path=i,this.passphrase=c,this.hdPrivateKey=s,this.address=a}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get nodeConfig(){return this.restClient.nodeConfig}getMnemonic(){return this.mnemonic}derive(t="0"){const e=`${this.path}${this.path.length>0?"/":""}${t}`;return new Dt(this.mnemonic,this.restClient,{path:e})}getPrivateKey(){return this.hdPrivateKey.privateKey}getPublicKey(){return this.hdPrivateKey.publicKey}getAddress(){return this.address}getBalance(){return w(this,void 0,void 0,(function*(){return this.restClient.getBalance(this.getAddress())}))}getUtxos(t=this.getAddress()){return w(this,void 0,void 0,(function*(){return this.restClient.getUtxosFromAddress(t)}))}selectUtxos(t,e){let o=0;const n=[];!function(t){const e=t;for(let t=e.length-1;t>0;t-=1){const o=Math.floor(Math.random()*(t+1));[e[t],e[o]]=[e[o],e[t]]}}(t);for(let r=0;r<t.length;r+=1){const i=t[r];if(o+=i.satoshis,n.push(i),o>=e)return n}const{network:r,chain:i}=this.restClient.nodeConfig;throw new Error(`Insufficient balance in address ${this.getAddress().toString()} on ${r} ${i}. Found ${o}, required ${e}.`)}fundAndSendTransaction(e){return w(this,void 0,void 0,(function*(){e.tx.feePerKb(lt.FEE_PER_KB);const{chain:o,network:n}=this.nodeConfig;const{enc:r}=e;const[,i=0]=r;const c=i*function(t){if("LTC"===t)return 8e3;if("BTC"===t)return 22;if("DOGE"===t)return 7e6;if("BCH"===t)return 2700;throw new Error(`Unsupported chain ${t}`)}(o);const s=.001*e.tx._getOutputAmount();const a=Math.max(lt.MIN_NON_DUST_AMOUNT,c+s);e.tx.to(function(t,e){const o={"any-testnet":"gLjNGbKQzxqKA9bv2nhn1Ewf7rxYVXgrtR","BTC-mainnet":"84ZHRqRPTcUv6AFGMVC1KmSUeC9Y8SNfMm","LTC-mainnet":"mov5ivrsqWut5ffZhiz18uAkwy2D4y98iz","DOGE-mainnet":"1MVukPYmWdbEoxy3Sqq1ES4nYqDfpB5e68","BCH-mainnet":"P9CmJszhvARfQc8YjUW1K2oBnus1ZQWEqk","BSV-mainnet":"G2wxQ74zX48WMo7sfiX1faGGNQB8ebVth"};return gt("testnet"===e||"regtest"===e?o["any-testnet"]:o[`${t}-${e}`],19)}(o,n),Math.round(a));let d=e.tx._getInputAmount();const u=e.tx._getOutputAmount();const l=e.tx._estimateFee();let _=u-d+Math.round(l);if(_>0){const o=yield this.getUtxos();this.selectUtxos(o,_).forEach((o=>{e.tx.from([new t.Bitcoin.Transaction.UnspentOutput(o)])})),d=e.tx._getInputAmount(),_=u-d+Math.round(e.tx._estimateFee())}return e.tx.change(this.getAddress()),e.tx.sign(this.getPrivateKey(),lt.SIGHASH_ALL),yield this.restClient.sendTransaction(e.tx.toString())}))}send(t,e){return w(this,void 0,void 0,(function*(){const o=new Mt(this.restClient.nodeConfig,this.getPrivateKey());return o.tx.to(e,t),this.fundAndSendTransaction(o)}))}}class Lt extends class{constructor(t,e){this.chain=t,this.network=e}}{constructor(t,e,o){super(t,e),this.url=o}}var Kt={CHAIN:process.env.CHAIN||"LTC",NETWORK:process.env.NETWORK||"testnet",BCN_URL:process.env.BCN_URL||"https://node.bitcoincomputer.io"};const{Mnemonic:Ht,PublicKey:Wt}=t.Bitcoin;class Ft{constructor(t={}){var e,o;const{seed:n}=t;const r=(null===(e=t.chain)||void 0===e?void 0:e.toUpperCase())||Kt.CHAIN;const i=(null===(o=t.network)||void 0===o?void 0:o.toLowerCase())||Kt.NETWORK;const c=t.url||Kt.BCN_URL;const s=t.passphrase||lt.PASSPHRASE;const a=t.path||Nt(r,i);const d=t.mnemonic||new Ht(n);if(!r||!["BTC","LTC","DOGE","BCH","BSV"].includes(r.toUpperCase()))throw new Error("We currently only support LTC.");if("LTC"!==r.toUpperCase()&&console.log("We currently only support LTC. If you would like to add support for your favorite\nvariant of Bitcoin have a look at\n\nhttps://github.com/bitcoin-computer/bitcoin-computer-node/tree/master/chain-setup\n\nSend us a pr and your cv if you can figure it out."),!i||!["mainnet","testnet","regtest"].includes(i.toLowerCase()))throw new Error("Please set 'network' to 'regtest', 'testnet', or 'mainnet'");const u=((t,e,o={})=>{const{path:n,passphrase:r}=o;let i=t.toHDPrivateKey(r,e);return n&&(i=i.derive(n)),i.privateKey})(d,i,{path:a,passphrase:s});const l=new Lt(r,i,c);const _=new P(l,u);this.db=t.db||new $t(new Dt(d,_,{path:a,passphrase:s}))}get chain(){return this.db.chain}get network(){return this.db.network}parseContract(t){const e=t.startsWith("export ")?t.slice(7):t;const o=e.startsWith("default ")?e.slice(8):e;return b(`(${o})`)}new(t,e){return w(this,void 0,void 0,(function*(){const o=t.toString();const n=yield this.parseContract(o);const r=new at(this.db);const i=yield r.allocate(n,e);return new Proxy(i,r)}))}sync(t){return w(this,void 0,void 0,(function*(){C(t);const e=new ct(this.db);const o=new at(this.db);const n=yield e.get(t);return new Proxy(n,o)}))}getOwnedRevs(t=this.db.wallet.getPublicKey()){return this.db.wallet.restClient.getOwnedRevs(t)}queryRevs(t){return w(this,void 0,void 0,(function*(){const{publicKey:e,contractName:o,contractHash:n}=t;const r=e?new Wt(e):void 0;return this.db.wallet.restClient.queryRevs({publicKey:r,contractName:o,contractHash:n})}))}getRevs(t=this.db.wallet.getPublicKey()){return w(this,void 0,void 0,(function*(){return(yield this.getOwnedRevs(t)).map((({rev:t})=>t))}))}getLatestRev(t){return w(this,void 0,void 0,(function*(){return this.db.wallet.restClient.getLatestRev(t)}))}getLatestRevs(t){return w(this,void 0,void 0,(function*(){return this.db.wallet.restClient.getLatestRevs(t)}))}}var Gt=h.default;var Jt=g.default;var zt=y.default;function Yt(t){"string"==typeof t&&(t=function(t){var e=zt.parse(t);var o=e.hostname;var n=parseInt(e.port,10);var r=e.protocol;r=r.substring(0,r.length-1);var i=e.auth.split(":");return{host:o,port:n,protocol:r,user:i[0]?decodeURIComponent(i[0]):null,pass:i[1]?decodeURIComponent(i[1]):null}}(t)),t=t||{},this.host=t.host||"127.0.0.1",this.port=t.port||8332,this.user=t.user||"user",this.pass=t.pass||"pass",this.protocol="http"===t.protocol?Gt:Jt,this.batchedCalls=null,this.disableAgent=t.disableAgent||!1;var e=void 0!==t.rejectUnauthorized;this.rejectUnauthorized=!e||t.rejectUnauthorized,Yt.config.log?this.log=Yt.config.log:this.log=Yt.loggers[Yt.config.logger||"normal"]}var Zt=console.log.bind(console);var Xt=function(){};function Vt(t,e){var o=this;t=JSON.stringify(t);var n=this.user+":"+this.pass;var r=Buffer.from&&Buffer.from!==Uint8Array.from?Buffer.from(n):new Buffer(n);this.auth=r.toString("base64");var i={host:o.host,path:"/",method:"POST",port:o.port,rejectUnauthorized:o.rejectUnauthorized,agent:!o.disableAgent&&void 0};if(o.httpOptions)for(var c in o.httpOptions)i[c]=o.httpOptions[c];var s=!1;var a="Bitcoin JSON-RPC: ";var d=this.protocol.request(i,(function(t){var n="";t.on("data",(function(t){n+=t})),t.on("end",(function(){if(!s)if(s=!0,401!==t.statusCode)if(403!==t.statusCode){if(500===t.statusCode&&"Work queue depth exceeded"===n.toString("utf8")){var r=new Error("Bitcoin JSON-RPC: "+n.toString("utf8"));return r.code=429,void e(r)}var i;try{i=JSON.parse(n)}catch(r){o.log.err(r.stack),o.log.err(n),o.log.err("HTTP Status code:"+t.statusCode);var c=new Error(a+"Error Parsing JSON: "+r.message);return void e(c)}e(i.error,i)}else e(new Error(a+"Connection Rejected: 403 Forbidden"));else e(new Error(a+"Connection Rejected: 401 Unnauthorized"))}))}));d.on("error",(function(t){var o=new Error(a+"Request Error: "+t.message);s||(s=!0,e(o))})),d.setHeader("Content-Length",t.length),d.setHeader("Content-Type","application/json"),d.setHeader("Authorization","Basic "+o.auth),d.write(t),d.end()}Yt.loggers={none:{info:Xt,warn:Xt,err:Xt,debug:Xt},normal:{info:Zt,warn:Zt,err:Zt,debug:Xt},debug:{info:Zt,warn:Zt,err:Zt,debug:Zt}},Yt.config={logger:"normal"},Yt.prototype.batch=function(t,e){this.batchedCalls=[],t(),Vt.call(this,this.batchedCalls,e),this.batchedCalls=null},Yt.callspec={abandonTransaction:"str",abortRescan:"",addMultiSigAddress:"",addNode:"",analyzePSBT:"str",backupWallet:"",bumpFee:"str",clearBanned:"",combinePSBT:"obj",combineRawTransaction:"obj",convertToPSBT:"str",createMultiSig:"",createPSBT:"obj",createRawTransaction:"obj obj",createWallet:"str",decodePSBT:"str",decodeScript:"str",decodeRawTransaction:"",deriveAddresses:"str",disconnectNode:"",dumpPrivKey:"",dumpWallet:"str",encryptWallet:"",enumerateSigners:"",estimateFee:"",estimateSmartFee:"int str",estimatePriority:"int",generate:"int",generateBlock:"str obj",generateToAddress:"int str",generateToDescriptor:"int str",getAccount:"",getAccountAddress:"str",getAddedNodeInfo:"",getAddressMempool:"obj",getAddressUtxos:"obj",getAddressBalance:"obj",getAddressDeltas:"obj",getAddressesByLabel:"str",getAddressInfo:"str",getAddressTxids:"obj",getAddressesByAccount:"",getBalance:"str int",getBalances:"",getBestBlockHash:"",getBlockDeltas:"str",getBlock:"str int",getBlockchainInfo:"",getBlockCount:"",getBlockFilter:"str",getBlockHashes:"int int obj",getBlockHash:"int",getBlockHeader:"str",getBlockNumber:"",getBlockStats:"str",getBlockTemplate:"",getConnectionCount:"",getChainTips:"",getChainTxStats:"",getDescriptorInfo:"str",getDifficulty:"",getGenerate:"",getHashesPerSec:"",getIndexInfo:"",getInfo:"",getMemoryInfo:"",getMemoryPool:"",getMemPoolAncestors:"str",getMemPoolDescendants:"str",getMemPoolEntry:"str",getMemPoolInfo:"",getMiningInfo:"",getNetTotals:"",getNetworkHashPS:"",getNetworkInfo:"",getNewAddress:"str str",getNodeAddresses:"",getPeerInfo:"",getRawChangeAddress:"",getRawMemPool:"bool",getRawTransaction:"str int",getReceivedByAccount:"str int",getReceivedByAddress:"str int",getReceivedByLabel:"str",getRpcInfo:"",getSpentInfo:"obj",getTransaction:"",getTxOut:"str int bool",getTxOutProof:"",getTxOutSetInfo:"",getUnconfirmedBalance:"",getWalletInfo:"",getWork:"",getZmqNotifications:"",finalizePSBT:"str",fundRawTransaction:"str",help:"",importAddress:"str str bool",importDescriptors:"str",importMulti:"obj obj",importPrivKey:"str str bool",importPrunedFunds:"str, str",importPubKey:"str",importWallet:"str",invalidateBlock:"str",joinPSBTs:"obj",keyPoolRefill:"",listAccounts:"int",listAddressGroupings:"",listBanned:"",listDescriptors:"",listLabels:"",listLockUnspent:"bool",listReceivedByAccount:"int bool",listReceivedByAddress:"int bool",listReceivedByLabel:"",listSinceBlock:"str int",listTransactions:"str int int",listUnspent:"int int",listWalletDir:"",listWallets:"",loadWallet:"str",lockUnspent:"",logging:"",move:"str str float int str",ping:"",preciousBlock:"str",prioritiseTransaction:"str float int",pruneBlockChain:"int",psbtBumpFee:"str",removePrunedFunds:"str",reScanBlockChain:"",saveMemPool:"",send:"obj",setHDSeed:"",setLabel:"str str",setWalletFlag:"str",scanTxOutSet:"str",sendFrom:"str str float int str str",sendMany:"str obj int str",sendRawTransaction:"str",sendToAddress:"str float str str",setAccount:"",setBan:"str str",setNetworkActive:"bool",setGenerate:"bool int",setTxFee:"float",signMessage:"",signMessageWithPrivKey:"str str",signRawTransaction:"",signRawTransactionWithKey:"str obj",signRawTransactionWithWallet:"str",stop:"",submitBlock:"str",submitHeader:"str",testMemPoolAccept:"obj",unloadWallet:"",upgradeWallet:"",uptime:"",utxoUpdatePSBT:"str",validateAddress:"",verifyChain:"",verifyMessage:"",verifyTxOutProof:"str",walletCreateFundedPSBT:"",walletDisplayAddress:"str",walletLock:"",walletPassPhrase:"string int",walletPassphraseChange:"",walletProcessPSBT:"str"};var Qt=function(t,e,o){return Array.prototype.slice.call(t,e,o)};function te(){return parseInt(1e5*Math.random())}!function(t,e,o){function n(t,e){return function(){var n=arguments.length-1;this.batchedCalls&&(n=arguments.length);for(var r=0;r<n;r++)e[r]&&(arguments[r]=e[r](arguments[r]));this.batchedCalls?this.batchedCalls.push({jsonrpc:"2.0",method:t,params:Qt(arguments),id:te()}):o.call(this,{method:t,params:Qt(arguments,0,arguments.length-1),id:te()},arguments[arguments.length-1])}}var r={str:function(t){return t.toString()},int:function(t){return parseFloat(t)},float:function(t){return parseFloat(t)},bool:function(t){return!0===t||"1"==t||"true"==t||"true"==t.toString().toLowerCase()},obj:function(t){return"string"==typeof t?JSON.parse(t):t}};for(var i in e){var c=[];if(e[i].length){c=e[i].split(" ");for(var s=0;s<c.length;s++)r[c[s]]?c[s]=r[c[s]]:c[s]=r.str}var a=i.toLowerCase();t.prototype[i]=n(a,c),t.prototype[a]=t.prototype[i]}}(Yt,Yt.callspec,Vt);var ee=Yt;const oe=["travel upgrade inside soda birth essence junk merit never twenty system opinion","hover harsh text dice wealth pill across trade soccer olive view acquire","damp comfort scan couple absurd enter slogan cheap ketchup print syrup hurdle one document diamond","notable rose silver indicate wreck mean raise together jar fish seat air","lens release coil rain forward lemon cube satisfy inject visa ring segment"];const{CHAIN:ne="LTC",NETWORK:re="regtest",RPC_USER:ie,RPC_PASSWORD:ce,RPC_HOST:se}=process.env;const ae="LTC"===process.env.CHAIN?19332:8332;var de=Object.assign(Object.assign({},Kt),{CHAIN:ne,NETWORK:re,BCN_URL:"http://127.0.0.1:3000",RPC_PROTOCOL:"http",RPC_USER:ie,RPC_PASSWORD:ce,RPC_HOST:se,RPC_PORT:ae,TEST_ADDRESSES:"mwADSUHvPCGrrX4ozP8Kcd5JCWK93rnc8h;moMoH1vTgCc2dkDfGSKYPnafxy22wSqgrr;mmQEk8VwtSehRryLF8jhVapYg553hJGhNa;miKQVhZbFKSsJcQZ8eXwBQ89xNyetpN34q;mzoGRNh55y9j57TPdwRGi3nt9X4CFwpqUS;n1X6JFDyxibtdhYrc7mrkuft6o168ELFNW;mjLcig6eTZVJkgRgJFMkwrYHpfMnZ1t4kk;mfYkMQAe7afeRSkgLxAtwnMVryjLTfr95Q"});const{PrivateKey:ue,Opcode:le,Script:_e,Mnemonic:pe,crypto:ve,Transaction:he,encoding:ge}=t.Bitcoin;const{CHAIN:ye,NETWORK:fe,BCN_URL:xe}=de;function Se(t=0){return new pe(oe[t])}function we(t=0){return function(t=0){return function(t=0){return function(t=0){return Se(t).toHDPrivateKey("",fe).derive(Nt(ye,fe))}(t).privateKey}(t).toPublicKey()}(t).toAddress()}function be(t=0){return new Ft(function(t=0){return{mnemonic:Se(t),chain:ye,network:fe}}(t))}new Lt(ye,fe,xe);const me=()=>w(void 0,void 0,void 0,(function*(){const t=(()=>{const t=de.RPC_PROTOCOL;const e=de.RPC_USER;const o=de.RPC_PASSWORD;const n=de.RPC_HOST;const r=de.RPC_PORT;return new ee({protocol:t,user:e,pass:o,host:n,port:r})})();const e=f.default.promisify(ee.prototype.generateToAddress.bind(t));yield e(1,we(0)),yield e(1,we(1)),yield e(1,we(2)),yield e(1,we(3)),yield e(1,we(4)),yield e(100,(new pe).toHDPrivateKey("",fe).derive(Nt(ye,fe)).privateKey.toPublicKey().toAddress())}));const Oe=new Lt(de.CHAIN,de.NETWORK,de.BCN_URL);const Ee=be(1);const{db:Ne}=Ee;const Be=be(2);const{db:je}=Be;const Te=new ct(Ne);const Ae=t=>t.split("/")[0];const Re=t=>{const[e,o]=t.split("/");const n=parseFloat(o);return[64,65].includes(e.length)&&!Number.isNaN(n)&&Number.isFinite(n)};jest.setTimeout(3e4),describe("Computer",(()=>{describe("new",(()=>{describe("Should create a smart object without argument",(()=>{class t{constructor(){this.n=1}}let e;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t)})))),it("Should create a smart object when computer.new is called",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:1,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(e._id).toBe(e._rev),expect(e._id).toBe(e._root),expect(Re(e._id)),expect(Re(e._rev)),expect(Re(e._root))})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3),expect(yield Te.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get([e._rev])).toEqual([{__func:"constructor",__args:[],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}])})))),it("should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(e._id)).toBe(e._rev)})))),it("should work with getLatestRevs",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRevs([e._id])).toEqual([e._rev])})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Be.sync(e._rev)).toEqual(e)}))))})),describe("Should create a smart object with a dumb argument",(()=>{class t{constructor(t){this.n=t}}let e;const o=Math.random();beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t,[o])})))),it("Should create a smart object when computer.new is called",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:o,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(e._id).toBe(e._rev),expect(e._id).toBe(e._root),expect(Re(e._id)),expect(Re(e._rev)),expect(Re(e._root))})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3),expect(yield Te.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get([e._rev])).toEqual([{__func:"constructor",__args:[o],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}])})))),it("should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Be.sync(e._rev)).toEqual(e)}))))})),describe("Should create a smart object with a smart argument",(()=>{class t{constructor(){this.n=1}}class e{constructor(t){this.a=t}}let o;let n;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),o=yield Ee.new(t,[]),yield Et(2e3),n=yield Ee.new(e,[o])}))),6e4),it("Should create a smart object when computer.new is called",(()=>w(void 0,void 0,void 0,(function*(){expect(o).toEqual({n:1,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n).toEqual({a:{n:1,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)},_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n.a).toEqual(o)}))),6e4),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(Re(o._id)),expect(Re(o._rev)),expect(Re(o._root)),expect(Re(n._id)),expect(Re(n._rev)),expect(Re(n._root));const t=Ae(o._id);const e=Ae(n._id);expect(t).not.toBe(e),expect(o._id).toBe(`${t}/0`),expect(o._rev).toBe(`${e}/0`),expect(n._id).toBe(`${e}/1`),expect(n._rev).toBe(`${e}/1`),expect(n.a._id).toBe(o._id),expect(n.a._rev).toBe(o._rev),expect(o._root).toBe(o._id),expect(n._root).toBe(n._id)}))),6e4),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3),expect(yield Te.get(o._rev)).toEqual(o),expect(yield Te.get(n._rev)).toEqual(n)}))),6e4),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get([o._id])).toEqual([{__func:"constructor",__args:[],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}]);const r=Ae(n._id);expect(yield Ne.get([`${r}/0`,`${r}/1`])).toEqual([{__index:{0:0,obj:1},_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT},{a:0,__func:"constructor",__args:["__"],__cls:e.toString(),_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}])}))),6e4),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(n._id)).toBe(n._rev),expect(yield Ee.getLatestRev(o._id)).toBe(o._rev)}))),6e4),it("Should work with getLatestRevs",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRevs([o._id,n._id])).toEqual([o._rev,n._rev])}))),6e4),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Be.sync(o._rev)).toEqual(o),expect(yield Be.sync(n._rev)).toEqual(n)}))))})),describe("Should create a smart object with a sub-object",(()=>{class t{constructor(){this.n={m:1}}}let e;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t,[])})))),it("Should create a smart object when computer.new is called",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:{_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),m:1},_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(e._id).toBe(e._rev),expect(e.n._id).toBe(e.n._rev),expect(e._root).toBe(e._id),expect(e.n._root).toBe(e._id)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3);const t=yield Te.get(e._rev);expect(t).toEqual(e),expect(e.n._id.startsWith("__temp__")).toBe(!1),expect(e.n._rev.startsWith("__temp__")).toBe(!1);const o=yield Te.get(e.n._rev);expect(o).toBeUndefined()})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get([e._rev])).toEqual([{n:1,__func:"constructor",__args:[],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Be.sync(e._rev)).toEqual(e)}))))})),describe("Should create a smart object with a smart sub-object",(()=>{class t{constructor(e){this.b=e?new t(!1):void 0}}let e;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t,[!0])})))),it("Should create a smart object when computer.new is called",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({b:{_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),b:void 0},_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(e._id).toBe(e._rev),expect(e.b._id).toBe(e.b._rev),expect(e._root).toBe(e._id),expect(e.b._root).toBe(e._id)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3);const t=yield Te.get(e._rev);expect(t).toEqual(e),expect(e.b._id.startsWith("__temp__")).toBe(!1),expect(e.b._rev.startsWith("__temp__")).toBe(!1);const o=yield Te.get(e.b._rev);expect(o).toBeUndefined()})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get([e._rev])).toEqual([{b:1,__func:"constructor",__args:[!0],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Be.sync(e._rev)).toEqual(e)}))))})),describe("Should create a smart object with an owner defined",(()=>{class t{constructor(t,e){this.n=t,this._owners=[e]}}let e;const o=Math.random();const n=Ee.db.wallet.getPublicKey().toString();beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t,[o,n])})))),it("Should create a smart object when computer.new is called",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:o,_owners:[n],_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(e._id).toBe(e._rev),expect(e._id).toBe(e._root),expect(Re(e._id)),expect(Re(e._rev)),expect(Re(e._root))})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3),expect(yield Te.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get([e._rev])).toEqual([{__func:"constructor",__args:[o,n],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}])})))),it("should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Be.sync(e._rev)).toEqual(e)}))))})),describe("Should create an encrypted smart object",(()=>{class t{constructor(t,e){this.n=t,this._readers=[e]}}let e;const o=Math.random();const n=Ee.db.wallet.getPublicKey().toString();beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t,[o,n])})))),it("Should create a smart object when computer.new is called",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:o,_readers:[n],_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(e._id).toBe(e._rev),expect(e._id).toBe(e._root),expect(Re(e._id)),expect(Re(e._rev)),expect(Re(e._root))})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3),expect(yield Te.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with encoded data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get([e._id])).toEqual([{__func:"constructor",__args:[o,n],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_readers:[],_amount:lt.MIN_NON_DUST_AMOUNT}])})))),it("Should be able to decode the output when db has access",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get([e._rev])).toEqual([{_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT,__cls:t.toString(),__index:{obj:0},__func:"constructor",__args:[o,n],_readers:[]}])})))),it("Should be not able to decode the output when db does not has access",(()=>w(void 0,void 0,void 0,(function*(){try{yield je.get([e._rev])}catch(t){expect(t).toBeInstanceOf(Error),expect(t).toHaveProperty("message","Decryption failure")}})))),it("should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.sync(e._rev)).toEqual(e);try{yield Be.sync(e._rev),expect(!0).toBe(!1)}catch(t){expect(t.message).toBe("Cannot read properties of undefined (reading '__cls')")}}))))})),describe("Should create an off-chain object",(()=>{class t{constructor(t){this.n=t,this._url="http://127.0.0.1:3000"}}let e;const o=Math.random();beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t,[o])})))),it("Should create a smart object when computer.new is called",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:o,_url:"http://127.0.0.1:3000",_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3),expect(yield Te.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with encoded data data",(()=>w(void 0,void 0,void 0,(function*(){const n=e._rev.split("/")[0];const r=yield Mt.fromTxId(n,Oe,Ee.db.wallet.getPrivateKey());const{outData:i}=r;expect(i).toEqual([{__args:[o],__cls:t.toString(),__func:"constructor",__index:{obj:0},_url:expect.any(String),_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}])})))),it("Should be able to get the output from the server when db has access",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get([e._rev])).toEqual([{__func:"constructor",__args:[o],__index:{obj:0},__cls:t.toString(),_url:"http://127.0.0.1:3000",_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}])})))),it("Should give all users access to the server",(()=>w(void 0,void 0,void 0,(function*(){expect(yield je.get([e._rev])).toEqual([{__func:"constructor",__args:[o],__index:{obj:0},__cls:t.toString(),_url:"http://127.0.0.1:3000",_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}])})))),it("should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Be.sync(e._rev)).toEqual(e)}))))})),describe("Should work if the contract is a string",(()=>{let t=null;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),t=yield Ee.new("class A {\n        constructor(n) {\n          this.n = n\n        }\n      }",[1])})))),it("should work",(()=>{expect(t).toBeDefined(),expect(typeof t).toBe("object"),expect(t).toEqual({n:1,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(t._id).toBe(t._rev)})),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){const e=be();expect(yield e.sync(t._rev)).toEqual(t)}))))})),describe("Should not create a smart object if no args as passed to the constructor",(()=>{class t{constructor(t,e){this.n=t,this._owners=[e]}}let e;it("Should throw an error",(()=>w(void 0,void 0,void 0,(function*(){try{e=e||(yield Ee.new(t,[])),expect(!0).toBe(!1)}catch(t){expect(e).toBeUndefined(),expect(t.message).toBeDefined()}}))))}))})),describe("function calls",(()=>{describe("Should work for a function call with a dumb argument",(()=>{class t{constructor(t){this.n=t}inc(t){return this.n+=t,this.n}}let e;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t,[1]),yield Et(2e3),yield e.inc(1)})))),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:2,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(Re(e._id)).toBe(!0),expect(Re(e._rev)).toBe(!0),expect(Re(e._root)).toBe(!0),expect(e._id).not.toBe(e._rev),expect(e._id).toBe(e._root)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3),expect(yield Te.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get([e._id])).toEqual([{__func:"constructor",__args:[1],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}]),expect(yield Ne.get([e._rev])).toEqual([{__func:"inc",__args:[1],__index:{obj:0},_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Be.sync(e._rev)).toEqual(e)}))))})),describe("Should work for a function call on an encrypted object",(()=>{class t{constructor(t,e){this.n=t,this._readers=[e]}inc(t){return this.n+=t,this.n}}let e;const o=Math.random();const n=Ee.db.wallet.getPublicKey().toString();beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t,[o,n]),yield Et(2e3),yield e.inc(1)})))),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:expect.any(Number),_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),_readers:[n]})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(Re(e._id)).toBe(!0),expect(Re(e._rev)).toBe(!0),expect(Re(e._root)).toBe(!0),expect(e._id).not.toBe(e._rev),expect(e._id).toBe(e._root)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3),expect(yield Te.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get([e._id])).toEqual([{__func:"constructor",__args:[o,n],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_readers:[],_amount:lt.MIN_NON_DUST_AMOUNT}]),expect(yield Ne.get([e._rev])).toEqual([{__func:"inc",__args:[1],__index:{obj:0},_owners:[expect.any(String)],_readers:[],_amount:lt.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.sync(e._rev)).toEqual(e);try{yield Be.sync(e._rev),expect(!0).toBe(!1)}catch(t){expect(t.message).toBe("Cannot read properties of undefined (reading '__cls')")}}))))})),describe("Should work for a function call on an off chain object",(()=>{class t{constructor(t){this.n=t,this._url="http://127.0.0.1:3000"}inc(t){return this.n+=t,this.n}}let e;const o=Math.random();beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t,[o]),yield Et(2e3),yield e.inc(1)})))),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:expect.any(Number),_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),_url:"http://127.0.0.1:3000"})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(Re(e._id)).toBe(!0),expect(Re(e._rev)).toBe(!0),expect(Re(e._root)).toBe(!0),expect(e._id).not.toBe(e._rev),expect(e._id).toBe(e._root)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3),expect(yield Te.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get([e._id])).toEqual([{__func:"constructor",__args:[o],__index:{obj:0},__cls:t.toString(),_url:"http://127.0.0.1:3000",_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}]),expect(yield Ne.get([e._rev])).toEqual([{__func:"inc",__args:[1],__index:{obj:0},_url:"http://127.0.0.1:3000",_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Be.sync(e._rev)).toEqual(e)}))))})),describe("Should work for a function with a smart argument",(()=>{class t{constructor(){this.n=1}}class e{constructor(){this.m=2}objInc(t){return t.n+=1,this.m+=t.n,this.m}}let o;let n;let r;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),o=yield Ee.new(t,[]),n=yield Ee.new(e,[]),yield Et(2e3),r=yield n.objInc(o)})))),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(o).toEqual({n:2,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n).toEqual({m:4,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should return the correct value",(()=>{expect(r).toBe(4)})),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(Re(o._id)).toBe(!0),expect(Re(o._rev)).toBe(!0),expect(Re(o._root)).toBe(!0),expect(Re(n._id)).toBe(!0),expect(Re(n._rev)).toBe(!0),expect(Re(n._root)).toBe(!0);const t=Ae(o._id);const e=Ae(n._id);const r=Ae(n._rev);expect(t).not.toBe(e),expect(e).not.toBe(r),expect(r).not.toBe(t),expect(o._id).toBe(`${t}/0`),expect(n._id).toBe(`${e}/0`),expect(o._rev).toBe(`${r}/0`),expect(n._rev).toBe(`${r}/1`),expect(o._root).toBe(o._id),expect(n._root).toBe(n._id)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3),expect(yield Te.get(o._rev)).toEqual(o),expect(yield Te.get(n._rev)).toEqual(n)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get([o._id])).toEqual([{__func:"constructor",__args:[],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}]);const r=Ae(n._id);expect(yield Ne.get([`${r}/0`])).toEqual([{__index:{obj:0},__func:"constructor",__args:[],__cls:e.toString(),_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}]);const i=Ae(n._rev);expect(yield Ne.get([`${i}/0`,`${i}/1`])).toEqual([{__index:{0:0,obj:1},_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT},{__func:"objInc",__args:["__"],_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(o._id)).toBe(o._rev),expect(yield Ee.getLatestRev(n._id)).toBe(n._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Be.sync(o._rev)).toEqual(o),expect(yield Be.sync(n._rev)).toEqual(n)}))))})),describe("Should work for a function that returns a dumb object",(()=>{class t{getJson(){return{n:1}}}let e;let o;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t,[]),yield Et(2e3),o=o||(yield e.getJson(3))})))),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(o).toEqual({n:1,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(Re(e._id)).toBe(!0),expect(Re(e._rev)).toBe(!0),expect(Re(e._root)).toBe(!0),expect(Re(o._id)).toBe(!0),expect(Re(o._rev)).toBe(!0),expect(Re(o._root)).toBe(!0);const t=Ae(e._id);const n=Ae(o._id);expect(t).not.toBe(n),expect(e._id).toBe(`${t}/0`),expect(o._id).toBe(`${n}/1`),expect(e._rev).toBe(`${n}/0`),expect(o._rev).toBe(`${n}/1`),expect(e._root).toBe(e._id),expect(o._root).toBe(e._id)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3),expect(yield Te.get(e._rev)).toEqual(e),expect(yield Te.get(o._rev)).toEqual(o)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get([e._id])).toEqual([{__func:"constructor",__args:[],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}]);const n=Ae(o._id);expect(yield Ne.get([`${n}/0`,`${n}/1`])).toEqual([{__index:{obj:0,res:1},__func:"getJson",__args:[3],_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT},{_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(e._id)).toBe(e._rev),expect(yield Ee.getLatestRev(o._id)).toBe(o._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Be.sync(e._rev)).toEqual(e),expect(yield Be.sync(o._rev)).toEqual(o)}))))})),describe("Should work for a function that returns a smart object",(()=>{class t{constructor(t){this.n=t}send(e){if(e>this.n)throw new Error;return this.n-=e,new t(e)}}let e;let o;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t,[10]),yield Et(2e3),o=yield e.send(3)})))),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:7,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(o).toEqual({n:3,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(Re(e._id)).toBe(!0),expect(Re(e._rev)).toBe(!0),expect(Re(e._root)).toBe(!0),expect(Re(o._id)).toBe(!0),expect(Re(o._rev)).toBe(!0),expect(Re(o._root)).toBe(!0);const t=Ae(e._id);const n=Ae(o._id);expect(t).not.toBe(n),expect(e._id).toBe(`${t}/0`),expect(o._id).toBe(`${n}/1`),expect(e._rev).toBe(`${n}/0`),expect(o._rev).toBe(`${n}/1`),expect(e._root).toBe(e._id),expect(o._root).toBe(e._id)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3),expect(yield Te.get(e._rev)).toEqual(e),expect(yield Te.get(o._rev)).toEqual(o)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get([e._id])).toEqual([{__func:"constructor",__args:[10],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}]);const n=Ae(o._id);expect(yield Ne.get([`${n}/0`,`${n}/1`])).toEqual([{__index:{obj:0,res:1},__func:"send",__args:[3],_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT},{__cls:t.toString(),_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(e._id)).toBe(e._rev),expect(yield Ee.getLatestRev(o._id)).toBe(o._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Be.sync(e._rev)).toEqual(e),expect(yield Be.sync(o._rev)).toEqual(o)}))))})),describe("Should work for a function that updates a nested object",(()=>{class t{constructor(){this.a={aa:1},this.b={bb:2}}update(){this.b.bb=3}}let e;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t,[]),yield Et(2e3),yield e.update()})))),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({a:{aa:1,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)},b:{bb:3,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)},_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){expect(Re(e._id)).toBe(!0),expect(Re(e._rev)).toBe(!0),expect(Re(e._root)).toBe(!0),expect(Re(e.a._id)).toBe(!0),expect(Re(e.a._rev)).toBe(!0),expect(Re(e.a._root)).toBe(!0),expect(Re(e.b._id)).toBe(!0),expect(Re(e.b._rev)).toBe(!0),expect(Re(e.b._root)).toBe(!0);const t=Ae(e._id);expect(e._id).toBe(`${t}/0`),expect(e.a._id).toBe(`${t}/1`),expect(e.b._id).toBe(`${t}/2`),expect(e._root).toBe(e._id),expect(e.a._root).toBe(e._id),expect(e.b._root).toBe(e._id)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3),expect(yield Te.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ne.get([e._id,e.a._id,e.b._id])).toEqual([{__func:"constructor",__args:[],__index:{obj:0},__cls:t.toString(),_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT,a:1,b:2},{_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT},{_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}]),expect(yield Ne.get([e._rev,e.a._rev,e.b._rev])).toEqual([{b:1,__index:{obj:0},__func:"update",__args:[],_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT},{_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT},{_owners:[expect.any(String)],_amount:lt.MIN_NON_DUST_AMOUNT}])})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Be.sync(e._rev)).toEqual(e)}))))})),describe("Should work for a function that returns an array",(()=>{class t{constructor(){this.aa=1}createArray(){return this.a=new t,[new t,new t]}}let e;let o;let n;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t,[]),yield Et(2e3),[o,n]=yield e.createArray()})))),it("Should return an array",(()=>w(void 0,void 0,void 0,(function*(){expect(o).toEqual({aa:1,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n).toEqual({aa:1,_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)})}))))})),describe("Should work for a function that returns an object created by a property wrapped as object",(()=>{class t{f(){return new t}}class e{constructor(t){this.a=t}g(){return this.a.f()}o(){return{o:this.a.f()}}}let o;let n;let r;let i;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),o=yield Ee.new(t,[]),yield Et(2e3),r=yield Ee.new(e,[o]),yield Et(2e3),n=yield r.g(),yield Et(2e3),({o:i}=yield r.o())})))),it("Should return the object",(()=>w(void 0,void 0,void 0,(function*(){expect(o).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(i).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(r).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),a:{_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}})}))))})),describe("Should work for a function that returns an object created by a property wrapped in an array",(()=>{class t{f(){return new t}}class e{constructor(t){this.a=t}g(){return this.a.f()}o(){return[this.a.f()]}}let o;let n;let r;let i;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),o=yield Ee.new(t,[]),yield Et(2e3),r=yield Ee.new(e,[o]),yield Et(2e3),n=yield r.g(),yield Et(2e3),[i]=yield r.o()})))),it("Should return the object",(()=>w(void 0,void 0,void 0,(function*(){expect(o).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(i).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(r).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),a:{_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}})}))))})),describe("Should work for a function that returns multiple objects created by a property wrapped in an array",(()=>{class t{f(){return new t}}class e{constructor(t){this.a=t}g(){return this.a.f()}o(){return[this.a.f(),this.a.f()]}}let o;let n;let r;let i;let c;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),o=yield Ee.new(t,[]),yield Et(2e3),r=yield Ee.new(e,[o]),yield Et(2e3),n=yield r.g(),yield Et(2e3),[i,c]=yield r.o()})))),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(o).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(i).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(c).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(r).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),a:{_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){const t=[o,n,i,c,r];for(let e=0;e<t.length;e+=1){const o=t[e];expect(Re(o._id)).toBe(!0),expect(Re(o._rev)).toBe(!0),expect(Re(o._root)).toBe(!0)}expect(o._id).not.toBe(o._rev),expect(r._id).not.toBe(r._rev),expect(n._id).toBe(n._rev)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3),expect(yield Te.get(o._rev)).toEqual(o),expect(yield Te.get(n._rev)).toEqual(n),expect(yield Te.get(r._rev)).toEqual(r)})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(o._id)).toBe(o._rev),expect(yield Ee.getLatestRev(n._id)).toBe(n._rev),expect(yield Ee.getLatestRev(r._id)).toBe(r._rev)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Be.sync(o._rev)).toEqual(o),expect(yield Be.sync(n._rev)).toEqual(n),expect(yield Be.sync(r._rev)).toEqual(r)}))))})),describe("Should work for a function that returns multiple objects created by a property",(()=>{class t{f(){return new t}}class e{constructor(t){this.a=t}g(){return this.a.f()}o(){return this.a.f()}}let o;let n;let r;let i;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),o=yield Ee.new(t,[]),yield Et(2e3),r=yield Ee.new(e,[o]),yield Et(2e3),n=yield r.g(),yield Et(2e3),i=yield r.o()})))),it("Should return the object",(()=>w(void 0,void 0,void 0,(function*(){expect(o).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(i).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(r).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),a:{_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}})}))))})),describe("Should work for a function that returns an object created by a property",(()=>{class t{f(){return new t}}class e{constructor(t){this.a=t}g(){return this.a.f()}}let o;let n;let r;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),o=yield Ee.new(t,[]),yield Et(2e3),r=yield Ee.new(e,[o]),yield Et(2e3),n=yield r.g()})))),it("Should return the object",(()=>w(void 0,void 0,void 0,(function*(){expect(o).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(n).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}),expect(r).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),a:{_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)}})}))))})),describe("Should work when setting an owner",(()=>{class t{constructor(t){this._owners=[t]}updateOwner(t){this._owners=[t]}}let e;const o=new Ft({chain:de.CHAIN,network:de.NETWORK,path:""});const n=Ee.db.wallet.getPublicKey().toString();const r=o.db.wallet.getPublicKey().toString();beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t,[n]),yield Et(2e3),yield e.updateOwner(r)}))),6e4),it("Should update the smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),_owners:[r]})})))),it("Should set the location correctly",(()=>w(void 0,void 0,void 0,(function*(){const t=Ae(e._id);expect(e._id).toBe(`${t}/0`)})))),it("Should return the object if reader.get is called",(()=>w(void 0,void 0,void 0,(function*(){yield Et(2e3),expect(yield Te.get(e._rev)).toEqual(e)})))),it("Should broadcast a transaction with an output containing data",(()=>w(void 0,void 0,void 0,(function*(){const[o]=yield Ne.get([e._id]);expect(o).toEqual({__func:"constructor",__args:[n],__index:{obj:0},__cls:t.toString(),_amount:lt.MIN_NON_DUST_AMOUNT,_owners:[n]});const[i]=yield Ne.get([e._rev]);expect(i).toEqual({__func:"updateOwner",__args:[r],__index:{obj:0},_owners:[r],_amount:lt.MIN_NON_DUST_AMOUNT})})))),it("Should work with getLatestRev",(()=>w(void 0,void 0,void 0,(function*(){expect(yield Ee.getLatestRev(e._id)).toBe(e._rev)})))),it("Should work with getRevs",(()=>w(void 0,void 0,void 0,(function*(){expect((yield o.getRevs()).length).toBe(1)})))),it("Should work with sync",(()=>w(void 0,void 0,void 0,(function*(){expect(yield o.sync(e._rev)).toEqual(e)}))))})),describe("Should work with multiple computers",(()=>{class t{constructor(){this.n=1}inc(){this.n+=1}}let e=null;let o=null;beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t,[]),yield Et(2e3),o=yield Be.new(t,[]),yield Et(2e3),yield e.inc(),yield Et(2e3)})))),it("should work",(()=>{expect(e).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),n:2}),expect(o).toEqual({_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String),n:1})}))}))})),describe("sync",(()=>{class t{constructor(t,e){this.n=t,this._owners=[e]}}let e;const o=Math.random();const n=Ee.db.wallet.getPublicKey().toString();beforeAll((()=>w(void 0,void 0,void 0,(function*(){yield me(),e=yield Ee.new(t,[o,n])})))),it("Should create another instance of the same smart object",(()=>w(void 0,void 0,void 0,(function*(){expect(e).toEqual({n:o,_owners:[n],_id:expect.any(String),_rev:expect.any(String),_root:expect.any(String)});const t=be();const r=yield t.sync(e._rev);expect(r).toEqual(e)})))),it("throw an error if no params are passed to sync function",(()=>w(void 0,void 0,void 0,(function*(){const t=be();try{yield t.sync(),expect(!0).toBe(!1)}catch(t){if(!(t instanceof Error))throw new Error("Unknown error");expect(t.message).toBe("Invalid outId: undefined")}})))),it("throw an error if rev is not in the right format: tdId:num",(()=>w(void 0,void 0,void 0,(function*(){const t=be();try{yield t.sync("123"),expect(!0).toBe(!1)}catch(t){if(!(t instanceof Error))throw new Error("Unknown error");expect(t.message).toBe("Invalid outId: 123")}})))),it("throw an error if trId in rev is not 64 hex characters",(()=>w(void 0,void 0,void 0,(function*(){const t=be();try{yield t.sync("123:0"),expect(!0).toBe(!1)}catch(t){if(!(t instanceof Error))throw new Error("Unknown error");expect(t.message).toBe("Invalid outId: 123:0")}})))),it("throw an error if trId in rev is contains non hex characters",(()=>w(void 0,void 0,void 0,(function*(){const t=be();try{yield t.sync("31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844g:0"),expect(!0).toBe(!1)}catch(t){if(!(t instanceof Error))throw new Error("Unknown error");expect(t.message).toBe("Invalid outId: 31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844g:0")}})))),it("throw an error if num in rev is not a number",(()=>w(void 0,void 0,void 0,(function*(){const t=be();try{yield t.sync("31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844f:abc"),expect(!0).toBe(!1)}catch(t){if(!(t instanceof Error))throw new Error("Unknown error");expect(t.message).toBe("Invalid outId: 31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844f:abc")}}))))}))}));
