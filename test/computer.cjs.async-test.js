"use strict";var e=require("chai");var t=require("bitcoin-computer-bitcore");require("ses");var o=require("axios");var n=require("exponential-backoff");require("child_process");var r=require("crypto");var i=require("crypto-js");var c=require("eciesjs");var s=require("http");var a=require("https");var d=require("url");var u=require("util");function l(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function h(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(o){if("default"!==o){var n=Object.getOwnPropertyDescriptor(e,o);Object.defineProperty(t,o,n.get?n:{enumerable:!0,get:function(){return e[o]}})}})),t.default=e,Object.freeze(t)}var p=l(o);var v=l(r);var _=l(i);var y=h(c);var g=l(s);var f=l(a);var b=l(d);var w=l(u);function k(e,t){var o={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(o[n]=e[n]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(n=Object.getOwnPropertySymbols(e);r<n.length;r++)t.indexOf(n[r])<0&&Object.prototype.propertyIsEnumerable.call(e,n[r])&&(o[n[r]]=e[n[r]])}return o}function x(e,t,o,n){var r,i=arguments.length,c=i<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,o):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)c=Reflect.decorate(e,t,o,n);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(c=(i<3?r(c):i>3?r(t,o,c):r(t,o))||c);return i>3&&c&&Object.defineProperty(t,o,c),c}function m(e,t,o,n){return new(o||(o=Promise))((function(r,i){function c(e){try{a(n.next(e))}catch(e){i(e)}}function s(e){try{a(n.throw(e))}catch(e){i(e)}}function a(e){var t;e.done?r(e.value):(t=e.value,t instanceof o?t:new o((function(e){e(t)}))).then(c,s)}a((n=n.apply(e,t||[])).next())}))}const S=e=>new Compartment({}).evaluate(e);const O=(e,t,o)=>new Compartment({target:e,thisArgument:t,argumentsList:o}).evaluate("Reflect.apply(target, thisArgument, argumentsList)");const N=(e,t)=>new Compartment({target:e,argumentsList:t}).evaluate(`Reflect.construct(${e}, argumentsList)`);const{crypto:j}=t.Bitcoin;const q=(e,t)=>{const o=Date.now();const n=j.Hash.sha256(Buffer.from(t+o));const r=[j.ECDSA.sign(n,e,"big").toString("hex"),e.publicKey.toString(),o];return`Bearer ${Buffer.from(r.join(":")).toString("base64")}`};class T{constructor(e,t,o={}){this.baseUrl=e,this.headers=o,this.privateKey=t}get(e){return m(this,void 0,void 0,(function*(){const t=this.privateKey?{Authentication:q(this.privateKey,this.baseUrl)}:{};return(yield p.default.get(`${this.baseUrl}${e}`,{headers:Object.assign(Object.assign({},this.headers),t)})).data}))}post(e,t){return m(this,void 0,void 0,(function*(){const o=this.privateKey?{Authentication:q(this.privateKey,this.baseUrl)}:{};return(yield p.default.post(`${this.baseUrl}${e}`,t,{headers:Object.assign(Object.assign({},this.headers),o)})).data}))}delete(e){return m(this,void 0,void 0,(function*(){const t=this.privateKey?{Authentication:q(this.privateKey,this.baseUrl)}:{};return(yield p.default.delete(`${this.baseUrl}${e}`,{headers:Object.assign(Object.assign({},this.headers),t)})).data}))}}var C={CHAIN:process.env.CHAIN||"LTC",NETWORK:process.env.NETWORK||"testnet",BCN_URL:process.env.BCN_URL||"https://node.bitcoincomputer.io",TEST_SEEDS:"travel upgrade inside soda birth essence junk merit never twenty system opinion;toddler hockey salute wheel harvest video narrow riot guitar lake sea call;cannon hour begin test replace fury motion squirrel envelope announce neck culture"};class R extends class{constructor({chain:e=C.CHAIN,network:t=C.NETWORK}={}){this.chain=e,this.network=t}}{constructor({chain:e=C.CHAIN,network:t=C.NETWORK,url:o=C.BCN_URL}={}){super({chain:e,network:t}),this.url=o}}const{PrivateKey:A,Transaction:E}=t.Bitcoin;const{UnspentOutput:I}=E;function U(e){if(!/^[0-9A-Fa-f]{64}$/.test(e))throw new Error(`Invalid txId: ${e}`)}function B(e){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(e))throw new Error(`Invalid outId: ${e}`)}function P(e){B(e);const[t,o]=e.split("/");return{txId:t,outputIndex:parseInt(o,10)}}let M=class{constructor({nodeConfig:e=new R,privateKey:t=new A}={}){this.nodeConfig=e,this.bcn=new T(e.url,t)}get chain(){return this.nodeConfig.chain}get network(){return this.nodeConfig.network}get url(){return this.nodeConfig.url}getBalance(e){return m(this,void 0,void 0,(function*(){const{chain:t,network:o}=this;return yield this.bcn.get(`/v1/${t}/${o}/address/${e}/balance`)}))}getTransaction(e){return m(this,void 0,void 0,(function*(){return new E(yield this.getRawTx(e))}))}getRawTx(e){return m(this,void 0,void 0,(function*(){U(e);const{chain:t,network:o}=this;return this.bcn.get(`/v1/${t}/${o}/tx/${e}`)}))}getTransactions(e){return m(this,void 0,void 0,(function*(){return(yield this.getRawTxs(e)).map((e=>new E(e)))}))}getRawTxs(e){return m(this,void 0,void 0,(function*(){e.map(U);const{chain:t,network:o}=this;return this.bcn.post(`/v1/${t}/${o}/tx/bulk/`,{txIds:e})}))}sendTransaction(e){return m(this,void 0,void 0,(function*(){return this.bcn.post(`/v1/${this.chain}/${this.network}/tx/send`,{rawTx:e})}))}getUtxosByAddress(e){return m(this,void 0,void 0,(function*(){const{chain:t,network:o}=this;return(yield this.bcn.get(`/v1/${t}/${o}/wallet/${e.toString()}/utxos`)).map((({rev:e,scriptPubKey:t,satoshis:o})=>{const[n,r]=e.split("/");return new I({txId:n,outputIndex:parseInt(r,10),satoshis:o,script:t})}))}))}getOwnedRevs(e){return m(this,void 0,void 0,(function*(){const{chain:t,network:o}=this;return this.bcn.get(`/v1/${t}/${o}/wallet/${e.toString()}/non-standard-utxos`)}))}queryRevs(e){return m(this,void 0,void 0,(function*(){const{publicKey:t,contractName:o,contractHash:n}=e;if(void 0===t&&void 0===o&&void 0===n)throw new Error("Filter parameter for queryRevs endpoint cannot be empty.");let r="";t&&(r+=`?publicKey=${t}`),o&&(r+=0===r.length?"?":"&",r+=`contractName=${o}`),n&&(r+=0===r.length?"?":"&",r+=`contractHash=${n}`);const{chain:i,network:c}=this;return this.bcn.get(`/v1/${i}/${c}/non-standard-utxos${r}`)}))}getLatestRev(e){return m(this,void 0,void 0,(function*(){B(e);const{chain:t,network:o}=this;const[{rev:n}]=yield this.bcn.get(`/v1/${t}/${o}/rev/${e}`);return n}))}getLatestRevs(e){return m(this,void 0,void 0,(function*(){e.map(B),e.map(B);const{chain:t,network:o}=this;return yield this.bcn.post(`/v1/${t}/${o}/revs`,{ids:e})}))}static getSecretOutput({_url:e,privateKey:t}){return m(this,void 0,void 0,(function*(){const o=e.split("/");const n=o[o.length-1];const r=o.slice(0,-2).join("/");const i=new T(r,t);return{host:r,data:yield i.get(`/v1/store/${n}`)}}))}static setSecretOutput({secretOutput:e,host:t,privateKey:o}){return m(this,void 0,void 0,(function*(){return new T(t,o).post("/v1/store/",e)}))}static deleteSecretOutput({_url:e,privateKey:t}){return m(this,void 0,void 0,(function*(){const o=e.split("/");const n=o[o.length-1];const r=o.slice(0,-2).join("/");const i=new T(r,t);yield i.delete(`/v1/store/${n}`)}))}};M=x([e=>e],M);const $=parseInt(process.env.BC_DUST_LIMIT||"",10)||1546;const D=parseInt(process.env.BC_DEFAULT_FEE||"",10)||2500;var L={MIN_NON_DUST_AMOUNT:$,SCRIPT_CHUNK_SIZE:parseInt(process.env.BC_SCRIPT_CHUNK_SIZE||"",10)||479,DEFAULT_FEE:D,SIGHASH_ALL:1,FEE_PER_KB:2e4,PUBLIC_KEY_SIZE:65,ANYONE_CAN_SPEND_SEED:"replace this seed",PASSPHRASE:"",ENCODING_LENGTH:3,ENCODING_NUMBER_LENGTH:3,MAX_PUBKEYS_PER_SCRIPT:3,OP_RETURN_SIZE:80};const{PublicKey:K,crypto:H}=t.Bitcoin;const{Point:W}=H;function F(e){return Buffer.from(e,"hex").toString().replace(/\0/g,"")}function G(e,t){return e.slice(t)+e.slice(0,t)}function J(e,t,o){if(e.length*Math.log2(t)>53)throw new Error(`Input too large ${e.length} ${Math.log2(t)}`);if(![2,10,16].includes(t)||![2,10,16].includes(o))throw new Error("ToBase or FromBase invalid in covertNumber.");if(2===t&&e.length%8!=0)throw new Error("Binary strings must be byte aligned.");if(16===t&&e.length%2!=0)throw new Error("Hex strings must be of even length.");const n=parseInt(e,t).toString(o);return 2===o?n.padStart(8*Math.ceil(n.length/8),"0"):16===o?n.padStart(2*Math.ceil(n.length/2),"0"):n}function z(e,t){const o=new RegExp(`.{1,${t}}`,"g");return e.match(o)||[]}function Y(e){return z(e,2).map((e=>J(e,16,2))).join("")}function Z(e){return z(e,8).map((e=>J(e,2,16))).join("")}function X(e){return e.toString(16).padStart(L.ENCODING_NUMBER_LENGTH,"0")}function Q(e){return parseInt(e,16)}function V(e){if(62!==e.length)throw new Error("Input to hexToPublicKey must be of length 62");let t=!1;let o=0;let n;for(;!t;){if(o>=256)throw new Error("Something went wrong storing data");const r=o.toString(16).padStart(2,"0")+Z(G(Y(e).padStart(64,"0"),o));try{n=W.fromX(!1,r),t=!0}catch(e){o+=1}}if(!n)throw new Error("Something went wrong storing data");return new K(n)}function ee(e){const t=e.point.getX().toString("hex").padStart(64,"0");const o=J(t.slice(0,2),16,10);return Z((r=parseInt(o,10),(n=Y(t.slice(2))).slice(-r)+n.slice(0,-r)));var n,r}function te(e){return new Promise((t=>{setTimeout(t,e)}))}function oe(e=C.CHAIN,t=C.NETWORK){if("testnet"===t||"regtest"===t)return 1;if("BTC"===e)return 0;if("LTC"===e)return 2;if("DOGE"===e)return 3;if("BCH"===e)return 145;if("BSV"===e)return 236;throw new Error(`Unsupported chain ${e}`)}function ne({purpose:e=44,coinType:t=2,account:o=0}={}){return`m/${e.toString()}'/${t.toString()}'/${o.toString()}'`}function re(e=C.CHAIN,t=C.NETWORK){return ne({coinType:oe(e,t)})}function ie(){return Math.round(Math.random()*Math.pow(2,31))}function ce({chain:e=C.CHAIN,network:t=C.NETWORK,account:o=ie()}={}){return ne({account:o,coinType:oe(e,t)})}const{PublicKey:se,Script:ae}=t.Bitcoin;function de(e){if(e.length>L.MAX_PUBKEYS_PER_SCRIPT)throw new Error("Too many owners");return function(e){const t=new ae;return t.add("OP_1"),e.forEach((e=>{t.add(e)})),t.add(`OP_${e.length}`),t.add("OP_CHECKMULTISIG"),t}(e.map((e=>e.toBuffer())))}function ue(e){return function(e){return e.chunks.filter((e=>e.buf)).map((e=>e.buf))}(e).map((e=>se.fromBuffer(e)))}function le(e){return Buffer.from(_.default.SHA256(e).toString(),"hex").toString("hex").substr(0,4)}function he(e){return`${le(e)};${e}`}function pe(e){const t=e.substr(0,4);const o=e.substr(5);if(!function(e,t){return le(e)===t}(o,t))throw new Error("Decryption failure");return o}function ve(e){if(void 0!==e._readers){const{_readers:t,_url:o,_owners:n,_amount:r}=e,i=k(e,["_readers","_url","_owners","_amount"]);const c=function(e,t){const o=v.default.randomBytes(32).toString("hex");const n=function(e,t){if(!/^[0-9a-f]{64}$/.test(t))throw new Error("Invalid secret");const o=Buffer.from(t,"hex").toString("binary");const n=he(e);return _.default.AES.encrypt(n,o).toString()}(e,o);const r=t.map((e=>function(e,t){if(!/^0[2-3][0-9a-f]{64}|04[0-9a-f]{128}$/.test(t))throw new Error("Invalid publicKey");const o=he(e);return y.encrypt(t,Buffer.from(o,"utf8")).toString("base64")}(o,e)));return{__cypher:n,__secrets:r}}(JSON.stringify(i),t);return void 0!==o&&(c._url=o),void 0!==n&&(c._owners=n),void 0!==r&&(c._amount=r),c}return e}const{Transaction:_e}=t.Bitcoin;const{Output:ye}=_e;const{UnspentOutput:ge}=_e;let fe=class{constructor(e,t,o){const n=new _e(o);n.feePerKb(L.FEE_PER_KB),this.nodeConfig=e,this.tx=n,this.outData=[],this.privateKey=t}get txId(){return this.tx.id}get chain(){return this.nodeConfig.chain}get network(){return this.nodeConfig.network}get restClient(){const{nodeConfig:e,privateKey:t}=this;return new M({nodeConfig:e,privateKey:t})}get inputs(){return this.tx.inputs.map((e=>`${e.prevTxId.toString("hex")}/${e.outputIndex}`))}get inRevs(){const{enc:e}=this;let[t]=e;return t=Number.isFinite(t)?t:0,this.tx.inputs.slice(0,t).map((({prevTxId:e,outputIndex:t})=>`${e.toString("hex")}/${t}`))}get outRevs(){const{enc:e}=this;let[,t]=e;return t=Number.isFinite(t)?t:0,Array.from(Array(t).keys()).map((e=>`${this.tx.id}/${e}`))}get opReturns(){try{const{outputs:e}=this.tx;return e.filter((({script:e})=>e.isDataOut())).map((({script:e})=>e.getData())).map((e=>e.toString())).join()}catch(e){return""}}get enc(){return z(this.opReturns.slice(0,L.ENCODING_LENGTH*L.ENCODING_NUMBER_LENGTH),L.ENCODING_NUMBER_LENGTH).map(Q)}get dataPrefix(){return this.opReturns.slice(9)}getOwnerOutputs(){const{enc:e}=this;const[,t=0]=e;return this.tx.outputs.slice(0,t)}getDataOutputs(){const{enc:e}=this;const[,t,o]=e;return this.tx.outputs.slice(t,o)}getOutData(e){return m(this,void 0,void 0,(function*(){try{const t=this.getDataOutputs().map((e=>e.script)).map((e=>ue(e))).flat().map(ee).map(F).join("");const{dataPrefix:o}=this;const n=JSON.parse(o+t);const r=e.toBuffer().toString("hex");const i=this.getOwnerOutputs();if(i.length!==n.length)throw new Error("Inconsistent state");const c=i.map(((e,t)=>Object.assign(Object.assign({},n[t]),{_owners:ue(e.script).map((e=>e.toString())),_amount:e.satoshis})));return Promise.all(c.map((t=>m(this,void 0,void 0,(function*(){try{const o=yield function(e){return t=>m(this,void 0,void 0,(function*(){if(function(e){return void 0!==e._url}(t)){const{_url:o}=t,n=k(t,["_url"]);const{host:r,data:i}=yield M.getSecretOutput({_url:o,privateKey:e});return Object.assign(Object.assign(Object.assign({},n),JSON.parse(i)),{_url:r})}return t}))}(e)(t);return function(e,t){if(function(e){return void 0!==e.__cypher&&void 0!==e.__secrets}(e)){const{__cypher:o,__secrets:n}=e,r=k(e,["__cypher","__secrets"]);return Object.assign(Object.assign(Object.assign({},r),JSON.parse(function({__cypher:e,__secrets:t},o){let n="";if(o.forEach((o=>{t.forEach((t=>{try{const r=function(e,t){if(!/^[0-9a-f]{64}$/.test(t))throw new Error("Invalid privateKey");return pe(y.decrypt(t,Buffer.from(e,"base64")).toString("utf8"))}(t,o);n=function(e,t){if(!/^[0-9a-f]{64}$/.test(t))throw new Error("Invalid secret");const o=Buffer.from(t,"hex").toString("binary");return pe(_.default.AES.decrypt(e,o).toString(_.default.enc.Utf8))}(e,r)}catch(e){const t=["Decryption failure","Unsupported state or unable to authenticate data"];if(e instanceof Error&&!t.includes(e.message))throw e}}))})),n)return n;throw new Error("Decryption failure")}({__cypher:o,__secrets:n},t))),{_readers:[]})}return e}(o,[r])}catch(e){return null}})))))}catch(e){return[]}}))}getOwners(){return this.getOwnerOutputs().map((e=>ue(e.script).map((e=>e.toString()))))}getAmounts(){return this.getOwnerOutputs().map((e=>e.satoshis))}spendFromData(e){return m(this,void 0,void 0,(function*(){if(!e.length)return;const o=e.map(P);const n=o.map((e=>e.txId));const r=yield this.restClient.getTransactions(n);for(let e=0;e<o.length;e+=1){const{txId:n,outputIndex:i}=o[e];const{outputs:c}=r[e];const s=c[i];const a=Math.round(s.satoshis);const d=new t.Bitcoin.Script(s.script);const u=new ge({txId:n,outputIndex:i,satoshis:a,script:d});const l=ue(d).map((e=>e.toString()));this.tx.from([u],l,1)}}))}createDataOuts(e){e.forEach((({_amount:e,_owners:o=[]})=>{if(Array.isArray(o)&&o.length>L.MAX_PUBKEYS_PER_SCRIPT)throw new Error("Too many owners.");const n=o.map((e=>t.Bitcoin.PublicKey.fromString(e)));const r=e||L.MIN_NON_DUST_AMOUNT;const i=de(n);this.tx.addOutput(new ye({script:i,satoshis:r}))}));const o=e.map((e=>k(e,["_amount","_owners"])));const n=L.MIN_NON_DUST_AMOUNT;const r=JSON.stringify(o);const i=L.OP_RETURN_SIZE-L.ENCODING_LENGTH*L.ENCODING_NUMBER_LENGTH;const c=r.slice(0,i);const s=function(e){var t;return function(e,t){const o=[];for(let n=0;n<e.length;n+=t)o.push(e.slice(n,n+t));return o}(z((t=e,Buffer.from(t).toString("hex")),62).map((e=>e.padStart(62,"0"))).map(V),L.MAX_PUBKEYS_PER_SCRIPT).map((e=>de(e)))}(r.slice(i));const a=X(this.tx.inputs.length)+X(this.tx.outputs.length)+X(this.tx.outputs.length+s.length);s.forEach((e=>{this.tx.addOutput(new ye({script:e,satoshis:n}))})),this.tx.addData(a+c)}static fromTxHex(e,t,o){return m(this,void 0,void 0,(function*(){let n=[];let r=[];let i=[];const c=new this(t,o);c.tx.fromString(e);try{n=yield c.getOutData(o)}catch(e){}try{r=c.getOwners()}catch(e){}try{i=c.getAmounts()}catch(e){}return c.outData=n.map(((e,t)=>Object.assign(Object.assign({},e),{_owners:r[t],_amount:i[t]}))),c}))}static fromTxId(e,t,o){return m(this,void 0,void 0,(function*(){const n=new M({nodeConfig:t,privateKey:o});const r=yield n.getRawTx(e);return this.fromTxHex(r,t,o)}))}};fe=x([e=>e],fe);class be{constructor({seed:e="",chain:o=C.CHAIN,network:n=C.NETWORK,url:r=C.BCN_URL,path:i=re(),passphrase:c=""}={}){this.passphrase=c,this.seed=e,this.path=i;const s=new t.Bitcoin.Mnemonic(e);this.hdPrivateKey=s.toHDPrivateKey(c,n).deriveChild(i);const a=new R({chain:o,network:n,url:r});this.restClient=new M({nodeConfig:a,privateKey:this.hdPrivateKey.privateKey}),this.address=this.hdPrivateKey.publicKey.toAddress(n)}get nodeConfig(){return this.restClient.nodeConfig}get chain(){return this.nodeConfig.chain}get network(){return this.nodeConfig.network}get url(){return this.nodeConfig.url}getMnemonic(){return new t.Bitcoin.Mnemonic(this.seed)}derive(e="0"){const t=`${this.path}${this.path.length>0?"/":""}${e}`;const{seed:o,chain:n,network:r,url:i}=this;return new be({seed:o,chain:n,network:r,url:i,path:t})}getPrivateKey(){return this.hdPrivateKey.privateKey}getPublicKey(){return this.hdPrivateKey.publicKey}getAddress(){return this.address}getBalance(){return m(this,void 0,void 0,(function*(){return this.restClient.getBalance(this.getAddress())}))}getUtxosByAmount(e){return m(this,void 0,void 0,(function*(){const t=yield this.restClient.getUtxosByAddress(this.getAddress());let o=0;const n=[];!function(e){const t=e;for(let e=t.length-1;e>0;e-=1){const o=Math.floor(Math.random()*(e+1));[t[e],t[o]]=[t[o],t[e]]}}(t);for(const r of t)if(o+=r.satoshis,n.push(r),o>=e)return n;const{network:r,chain:i}=this.restClient.nodeConfig;const c=this.getAddress().toString();throw new Error(`Insufficient balance in address ${c} on ${r} ${i}. Found ${o}, required ${e}.`)}))}fundAndSendTx(e){return m(this,void 0,void 0,(function*(){e.tx.feePerKb(L.FEE_PER_KB);const{chain:o,network:r}=this.nodeConfig;const{enc:i}=e;const[,c=0]=i;const s=c*function(e){if("LTC"===e)return 8e3;if("BTC"===e)return 22;if("DOGE"===e)return 7e6;if("BCH"===e)return 2700;throw new Error(`Unsupported chain ${e}`)}(o);const a=.001*e.tx._getOutputAmount();const d=Math.max(L.MIN_NON_DUST_AMOUNT,s+a);e.tx.to(function(e,t){const o={"any-testnet":"gLjNGbKQzxqKA9bv2nhn1Ewf7rxYVXgrtR","BTC-mainnet":"84ZHRqRPTcUv6AFGMVC1KmSUeC9Y8SNfMm","LTC-mainnet":"mov5ivrsqWut5ffZhiz18uAkwy2D4y98iz","DOGE-mainnet":"1MVukPYmWdbEoxy3Sqq1ES4nYqDfpB5e68","BCH-mainnet":"P9CmJszhvARfQc8YjUW1K2oBnus1ZQWEqk","BSV-mainnet":"G2wxQ74zX48WMo7sfiX1faGGNQB8ebVth"};return G("testnet"===t||"regtest"===t?o["any-testnet"]:o[`${e}-${t}`],19)}(o,r),Math.round(d));let u=e.tx._getInputAmount();const l=e.tx._getOutputAmount();const h=e.tx._estimateFee();let p=l-u+Math.round(h);return p>0&&((yield n.backOff((()=>this.getUtxosByAmount(p)))).forEach((o=>{e.tx.from([new t.Bitcoin.Transaction.UnspentOutput(o)])})),u=e.tx._getInputAmount(),p=l-u+Math.round(e.tx._estimateFee())),e.tx.change(this.getAddress()),e.tx.sign(this.getPrivateKey(),L.SIGHASH_ALL),this.restClient.sendTransaction(e.tx.toString())}))}send(e,t){return m(this,void 0,void 0,(function*(){const{nodeConfig:o}=this.restClient;const n=this.getPrivateKey();const r=new fe(o,n);return r.tx.to(t,e),this.fundAndSendTx(r)}))}}class we{constructor({wallet:e=new be}={}){this.wallet=e}get chain(){return this.wallet.chain}get network(){return this.wallet.network}get nodeConfig(){return this.wallet.nodeConfig}fromTxHex(e){return m(this,void 0,void 0,(function*(){const{wallet:t,nodeConfig:o}=this;const n=t.getPrivateKey();return fe.fromTxHex(e,o,n)}))}fromTxId(e){return m(this,void 0,void 0,(function*(){const{wallet:t,nodeConfig:o}=this;const n=t.getPrivateKey();const r=new M({nodeConfig:o,privateKey:n});const i=yield r.getRawTx(e);return this.fromTxHex(i)}))}get(e){return m(this,void 0,void 0,(function*(){const t=e.map(P);return Promise.all(t.map((({txId:e,outputIndex:t})=>m(this,void 0,void 0,(function*(){const{outData:o}=yield this.fromTxId(e);if(t>o.length)throw new Error("Index out of bounds");return o[t]})))))}))}put(e){return this.update([],e)}createTx(e,t){return m(this,void 0,void 0,(function*(){const{wallet:o,nodeConfig:n}=this;const r=o.getPrivateKey();const i=new fe(n,r);const c=t.map((e=>{var{_owners:t}=e,o=k(e,["_owners"]);return Object.assign({_owners:t||[this.wallet.getPublicKey().toString()]},o)})).map(ve);const s=yield Promise.all(c.map(function(e){return t=>m(this,void 0,void 0,(function*(){if(void 0!==t._url){const{_url:o,_owners:n,_amount:r}=t,i=k(t,["_url","_owners","_amount"]);const c=yield M.setSecretOutput({host:o,secretOutput:{data:JSON.stringify(i)},privateKey:e});return void 0!==n&&(c._owners=n),void 0!==r&&(c._amount=r),c}return t}))}(r)));return yield i.spendFromData(e),yield i.createDataOuts(s),i}))}update(e,t){return m(this,void 0,void 0,(function*(){const o=yield this.createTx(e,t);return yield this.wallet.fundAndSendTx(o),o.outRevs}))}}const ke=["_id","_rev","_owners","_amount","_readers","_url","__vouts","__func","__index","__args"];const xe=e=>(Object.prototype.toString.call(e).match(/\s([a-zA-Z]+)/)||[])[1];const me=e=>"object"==typeof e?xe(e):xe(e).toLowerCase();const Se=e=>["number","string","boolean","undefined","Null"].includes(me(e));const Oe=e=>"Array"===me(e);const Ne=e=>"Object"===me(e);const je=e=>Se(e)||["Array","Object"].includes(me(e));const qe=(e,t)=>{if(!je(e)||!je(t))throw new Error(`Unsupported data types for deep equals: ${me(e)} & ${me(t)}`);if(me(e)!==me(t))return!1;if(Se(e)&&Se(t))return e===t;const o=(e,t)=>Object.entries(e).every((([e,o])=>qe(t[e],o)));return e&&t&&o(e,t)&&o(t,e)};const Te=e=>{if(Se(e))return e;if(Oe(e))return e.map(Te);if(Ne(e)){const t=Object.keys(e).reduce(((t,o)=>(t[o]=Te(e[o]),t)),{});const o=Object.create(Object.getPrototypeOf(e));return Object.assign(o,t)}throw new Error(`Unsupported data type for clone: ${me(e)}`)};const Ce=(e,t)=>Object.fromEntries(Object.entries(e).map((e=>t(e))));const Re=(e,t)=>Ce(e,(([e,o])=>[e,t(o)]));const Ae=(e,t)=>Object.fromEntries(Object.entries(e).filter((e=>t(e))));const Ee=(e,t,o,n)=>{if(Se(e))return e;if(Oe(e))return e.map((e=>Ee(e,t,o,n)));if(Ne(e)){e._rev=`${n}/${o}`;const r=t[o];return Object.entries(e).forEach((([o,i])=>{"object"==typeof r&&Object.keys(r).includes(o)&&(e[o]=Ee(i,t,r[o],n))})),e}throw new Error(`Unsupported type ${me(e)} in deep.updateRev`)};const Ie=(e,t)=>{if(Se(e))return e;if(Oe(e))return e.map((e=>Ie(e,t)));if(Ne(e))return e._id=!e._id||e._id.startsWith("__temp__")?e._rev:e._id,e._root=e._root||t,Object.entries(e).forEach((([o,n])=>{e[o]=Ie(n,t)})),e;throw new Error(`Unsupported type ${me(e)} in deep.addId`)};const Ue=e=>{if(Se(e))return e;if(Oe(e))return e.map((e=>Ue(e)));if(Ne(e)){const t=`__temp__/${Math.random()}`;return e._id=e._id||t,e._rev=e._rev||t,Object.values(e).map((e=>Ue(e))),e}throw new Error(`Unsupported type ${me(e)} in addRandomId`)};const Be=e=>{if(Se(e))return e;if(Oe(e))return e.map((e=>Be(e)));if(Ne(e))return Ce(e,(([e,t])=>["_owners","_readers"].includes(e)?[e,JSON.stringify(t)]:Se(t)?[e,t]:[e,Be(t)]));throw new Error(`Unexpected type ${me(e)} in stringifyOwners`)};const Pe=e=>(e._owners&&(e._owners=JSON.parse(e._owners)),e._readers&&(e._readers=JSON.parse(e._readers)),e);const Me=e=>{if(Se(e))return e;if(Oe(e)||Ne(e))return Object.entries(e).reduce(((e,[t,o])=>{const n=Me(o);return(e=>"Object"===me(e)&&Object.keys(e).every((e=>!Number.isNaN(parseInt(e,10)))))(n)?Object.entries(n).forEach((([o,n])=>{e[`${t}_${o}`]=n})):e[t]=n,e}),{});throw new Error(`Unsupported type ${me(e)} in encodeArraysAsObjects`)};const $e=e=>{const t={[e._id]:Object.entries(e).reduce(((e,[t,o])=>ke.includes(t)?Object.assign(Object.assign({},e),{[t]:o}):Se(o)?Object.assign(Object.assign({},e),{[`__basic__${t}`]:o}):Object.assign(Object.assign({},e),{[t]:o._id})),{})};return Object.values(e).filter((e=>!Se(e))).reduce(((e,t)=>Object.assign(Object.assign({},e),$e(t))),t)};const De=e=>Ae(e,(([e])=>!e.startsWith("__basic__")));const Le=(e,t)=>{const o=e[t];return o.__contains=Object.entries(o).reduce(((t,[o,n])=>["__contains",...ke].includes(o)?t:"__change"===o?"new"===n||"diff"===n||t:Le(e,n)[n].__contains||t),!1),e};const Ke=(e,t)=>e.map((e=>Object.entries(e).reduce(((e,[o,n])=>{const r="string"==typeof n&&"undefined"!==me(t[n])?t[n]:n;return Object.assign(Object.assign({},e),{[o]:r})}),{})));class He{constructor({db:e=new we}={}){this.db=e}get(e){return m(this,void 0,void 0,(function*(){const{txId:t,outputIndex:o}=P(e);const{inRevs:n,outData:r}=yield this.db.fromTxId(t);if(!Array.isArray(n)||!Array.isArray(r)||0===r.length)return;const i=r[0].__index||{};const c=r[i.obj].__cls||"";const s=r[i.obj].__func||"";const a=r[i.obj].__args||[];const d=yield Promise.all(Object.values(i).map((e=>{const t=n[e];return t?this.get(t):Promise.resolve({})})));const u=Object.keys(i).map(((e,t)=>[e,d[t]]));const l=Object.fromEntries(u);let h=l.obj;delete l.obj;const p=Object.entries(l).reduce(((e,[t,o])=>{const n=parseInt(t,10);return Number.isNaN(n)||(e[n]=o),e}),[]);const v=function(e,t){let o=0;return t.map((t=>"__"===t?e[o++]:t))}(p,a);let _;if("constructor"===s){const e=S(`(${c})`);h=N(e,v)}else _=O(h[s].bind(h),h,v);Object.entries(i).forEach((([e,o])=>{const n=parseInt(e,10);let i=p[n];"obj"===e?i=h:"res"===e&&(i=_),Ee(i,r,o,t)}));const y=h._root||`${t}/${i.obj}`;return Ie([_,h,...p],y),[...p,h,_][o]}))}}function We(e){return{smartArgs:e.filter((e=>e._rev)),dumbArgs:e.map((e=>e._rev?"__":e))}}class Fe{constructor({db:e=new we}={}){this.db=e,Fe.proxyDepth=Fe.proxyDepth||0}static getUpdate(e){return m(this,void 0,void 0,(function*(){let t;let o;let n;let r;let i;let c;let s;if("Cls"in e){const{Cls:a}=e;const d=e.args||[];t=a.toString(),o=null,n=N(a,d),r=Te(d),i=d,c=null,s=void 0}else{const{target:a,property:d,args:u}=e;t=null,o=Te(a),n=a,r=Te(u),i=u,c=d,this.proxyDepth+=1,s=O(a[d],a,i),this.proxyDepth-=1}const{smartArgs:a,dumbArgs:d}=We(r);const{smartArgs:u}=We(i);const l=Object.assign(Object.assign(Object.assign({},a),{obj:o}),{_id:"index"});const h=Object.assign(Object.assign(Object.assign({},u),{obj:n}),{_id:"index"});["Object","Array"].includes(me(s))&&(h.res=s);const[p,v,_]=((e,t)=>{const o=Ue(t);const n=o._id;const r=Te(e);const i=Te(o);const c=Be(r);const s=Be(i);const a=Me(c);const d=Me(s);const u=((e,t)=>Ce(t,(([t,o])=>{const n=e[t];var r;return o.__change=(r=n)?qe(r,o)?"same":"diff":"new",[t,o]})))($e(a),$e(d));const l=Re(u,De);const h=Le(l,n);const p=h[n];delete h[n];const v=Re(h,(e=>e._rev));const _=(y=e=>e.__contains||Object.values(p).includes(e._id),Ae(h,(([,e])=>y(e))));var y;const g=Object.values(_);const[f,b]=(w=e=>"new"===e.__change,g.reduce((([e,t],o,n)=>w(o)?[[...e,o],t]:[e,[...t,o]]),[[],[]]));var w;const x=[...b,...f];const m=(e=>e.reduce(((e,t,o)=>Object.assign(Object.assign({},e),{[t._id]:o})),{}))(x);const S=Ke(x,m);const[O]=Ke([p],m);const N=b.map((e=>e._rev));const[j,...q]=((e,t)=>[t,...e].map((e=>{const t=k(e,["_id","_rev","__change","__contains"]);return Ae(t,(([e,t])=>ke.includes(e)||"number"==typeof t))})))(S,O);return[N,q.map(Pe).map((e=>Object.entries(e).reduce(((e,[t,o])=>Object.assign(Object.assign({},e),{[t]:v[o]||o})),{}))),j]})(l,h);void 0!==v[0]&&(v[0].__index=_);const y=_.obj;void 0!==v[y]&&(null!==t&&(v[y].__cls=t),v[y].__func=null===c?"constructor":String(c),v[y].__args=d);const g=_.res;return void 0!==v[g]&&"function Object() { [native code] }"!==s.constructor.toString()&&(v[g].__cls=s.constructor.toString()),[p,v,n,u,s,_]}))}allocate(e,t){return m(this,void 0,void 0,(function*(){const[o,n,r,i,,c]=yield Fe.getUpdate({Cls:e,args:t});const[s]=yield this.db.update(o,n);const{txId:a}=P(s);Object.entries(c).forEach((([e,t])=>{const o=parseInt(e,10);let c=i[o];"obj"===e&&(c=r),Ee(c,n,t,a)}));const d=`${a}/${c.obj}`;return Ie([r,...i],d),r}))}update(e,t,o){return m(this,void 0,void 0,(function*(){const[n,r,,i,c,s]=yield Fe.getUpdate({target:e,property:t,args:o});const[a]=yield this.db.update(n,r);const{txId:d}=P(a);Object.entries(s).forEach((([t,o])=>{const n=parseInt(t,10);let s=i[n];"obj"===t?s=e:t.startsWith("res")&&(s=c),Ee(s,r,o,d)}));const u="string"==typeof e._root?e._root:`${d}/${s.obj}`;return Ie([c,e,...i],u),c}))}get(e,t){return Fe.proxyDepth>0||"function"!=typeof e[t]?Reflect.get(e,t):(...o)=>this.update(e,t,o)}}const{PublicKey:Ge}=t.Bitcoin;class Je{constructor({seed:e="",path:t="",chain:o=C.CHAIN,network:n=C.NETWORK,url:r=C.BCN_URL,passphrase:i=L.PASSPHRASE}={}){const c=o.toUpperCase();const s=n.toLowerCase();const a=t||re(c,s);if(!["LTC","BTC","DOGE","BCH"].includes(c))throw new Error("We currently only support LTC.");if(!["mainnet","testnet","regtest"].includes(s))throw new Error("Please set 'network' to 'regtest', 'testnet', or 'mainnet'");const d=new be({seed:e,chain:c,network:s,url:r,path:a,passphrase:i});this.db=new we({wallet:d})}get chain(){return this.db.chain}get network(){return this.db.network}parseContract(e){const t=e.startsWith("export ")?e.slice(7):e;const o=t.startsWith("default ")?t.slice(8):t;return S(`(${o})`)}new(e,t){return m(this,void 0,void 0,(function*(){const o=e.toString();const n=yield this.parseContract(o);const r=new Fe({db:this.db});const i=yield r.allocate(n,t);return new Proxy(i,r)}))}sync(e){return m(this,void 0,void 0,(function*(){B(e);const{db:t}=this;const o=new He({db:t});const n=new Fe({db:t});const r=yield o.get(e);return new Proxy(r,n)}))}getOwnedRevs(e=this.db.wallet.getPublicKey()){return this.db.wallet.restClient.getOwnedRevs(e)}queryRevs(e){return m(this,void 0,void 0,(function*(){const{publicKey:t,contractName:o,contractHash:n}=e;const r=t?new Ge(t):void 0;return this.db.wallet.restClient.queryRevs({publicKey:r,contractName:o,contractHash:n})}))}getRevs(e=this.db.wallet.getPublicKey()){return m(this,void 0,void 0,(function*(){return(yield this.getOwnedRevs(e)).map((({rev:e})=>e))}))}getLatestRev(e){return m(this,void 0,void 0,(function*(){return this.db.wallet.restClient.getLatestRev(e)}))}getLatestRevs(e){return m(this,void 0,void 0,(function*(){return this.db.wallet.restClient.getLatestRevs(e)}))}}var ze=g.default;var Ye=f.default;var Ze=b.default;function Xe(e){"string"==typeof e&&(e=function(e){var t=Ze.parse(e);var o=t.hostname;var n=parseInt(t.port,10);var r=t.protocol;r=r.substring(0,r.length-1);var i=t.auth.split(":");return{host:o,port:n,protocol:r,user:i[0]?decodeURIComponent(i[0]):null,pass:i[1]?decodeURIComponent(i[1]):null}}(e)),e=e||{},this.host=e.host||"127.0.0.1",this.port=e.port||8332,this.user=e.user||"user",this.pass=e.pass||"pass",this.protocol="http"===e.protocol?ze:Ye,this.batchedCalls=null,this.disableAgent=e.disableAgent||!1;var t=void 0!==e.rejectUnauthorized;this.rejectUnauthorized=!t||e.rejectUnauthorized,Xe.config.log?this.log=Xe.config.log:this.log=Xe.loggers[Xe.config.logger||"normal"]}var Qe=console.log.bind(console);var Ve=function(){};function et(e,t){var o=this;e=JSON.stringify(e);var n=this.user+":"+this.pass;var r=Buffer.from&&Buffer.from!==Uint8Array.from?Buffer.from(n):new Buffer(n);this.auth=r.toString("base64");var i={host:o.host,path:"/",method:"POST",port:o.port,rejectUnauthorized:o.rejectUnauthorized,agent:!o.disableAgent&&void 0};if(o.httpOptions)for(var c in o.httpOptions)i[c]=o.httpOptions[c];var s=!1;var a="Bitcoin JSON-RPC: ";var d=this.protocol.request(i,(function(e){var n="";e.on("data",(function(e){n+=e})),e.on("end",(function(){if(!s)if(s=!0,401!==e.statusCode)if(403!==e.statusCode){if(500===e.statusCode&&"Work queue depth exceeded"===n.toString("utf8")){var r=new Error("Bitcoin JSON-RPC: "+n.toString("utf8"));return r.code=429,void t(r)}var i;try{i=JSON.parse(n)}catch(r){o.log.err(r.stack),o.log.err(n),o.log.err("HTTP Status code:"+e.statusCode);var c=new Error(a+"Error Parsing JSON: "+r.message);return void t(c)}t(i.error,i)}else t(new Error(a+"Connection Rejected: 403 Forbidden"));else t(new Error(a+"Connection Rejected: 401 Unnauthorized"))}))}));d.on("error",(function(e){var o=new Error(a+"Request Error: "+e.message);s||(s=!0,t(o))})),d.setHeader("Content-Length",e.length),d.setHeader("Content-Type","application/json"),d.setHeader("Authorization","Basic "+o.auth),d.write(e),d.end()}Xe.loggers={none:{info:Ve,warn:Ve,err:Ve,debug:Ve},normal:{info:Qe,warn:Qe,err:Qe,debug:Ve},debug:{info:Qe,warn:Qe,err:Qe,debug:Qe}},Xe.config={logger:"normal"},Xe.prototype.batch=function(e,t){this.batchedCalls=[],e(),et.call(this,this.batchedCalls,t),this.batchedCalls=null},Xe.callspec={abandonTransaction:"str",abortRescan:"",addMultiSigAddress:"",addNode:"",analyzePSBT:"str",backupWallet:"",bumpFee:"str",clearBanned:"",combinePSBT:"obj",combineRawTransaction:"obj",convertToPSBT:"str",createMultiSig:"",createPSBT:"obj",createRawTransaction:"obj obj",createWallet:"str",decodePSBT:"str",decodeScript:"str",decodeRawTransaction:"",deriveAddresses:"str",disconnectNode:"",dumpPrivKey:"",dumpWallet:"str",encryptWallet:"",enumerateSigners:"",estimateFee:"",estimateSmartFee:"int str",estimatePriority:"int",generate:"int",generateBlock:"str obj",generateToAddress:"int str",generateToDescriptor:"int str",getAccount:"",getAccountAddress:"str",getAddedNodeInfo:"",getAddressMempool:"obj",getAddressUtxos:"obj",getAddressBalance:"obj",getAddressDeltas:"obj",getAddressesByLabel:"str",getAddressInfo:"str",getAddressTxids:"obj",getAddressesByAccount:"",getBalance:"str int",getBalances:"",getBestBlockHash:"",getBlockDeltas:"str",getBlock:"str int",getBlockchainInfo:"",getBlockCount:"",getBlockFilter:"str",getBlockHashes:"int int obj",getBlockHash:"int",getBlockHeader:"str",getBlockNumber:"",getBlockStats:"str",getBlockTemplate:"",getConnectionCount:"",getChainTips:"",getChainTxStats:"",getDescriptorInfo:"str",getDifficulty:"",getGenerate:"",getHashesPerSec:"",getIndexInfo:"",getInfo:"",getMemoryInfo:"",getMemoryPool:"",getMemPoolAncestors:"str",getMemPoolDescendants:"str",getMemPoolEntry:"str",getMemPoolInfo:"",getMiningInfo:"",getNetTotals:"",getNetworkHashPS:"",getNetworkInfo:"",getNewAddress:"str str",getNodeAddresses:"",getPeerInfo:"",getRawChangeAddress:"",getRawMemPool:"bool",getRawTransaction:"str int",getReceivedByAccount:"str int",getReceivedByAddress:"str int",getReceivedByLabel:"str",getRpcInfo:"",getSpentInfo:"obj",getTransaction:"",getTxOut:"str int bool",getTxOutProof:"",getTxOutSetInfo:"",getUnconfirmedBalance:"",getWalletInfo:"",getWork:"",getZmqNotifications:"",finalizePSBT:"str",fundRawTransaction:"str",help:"",importAddress:"str str bool",importDescriptors:"str",importMulti:"obj obj",importPrivKey:"str str bool",importPrunedFunds:"str, str",importPubKey:"str",importWallet:"str",invalidateBlock:"str",joinPSBTs:"obj",keyPoolRefill:"",listAccounts:"int",listAddressGroupings:"",listBanned:"",listDescriptors:"",listLabels:"",listLockUnspent:"bool",listReceivedByAccount:"int bool",listReceivedByAddress:"int bool",listReceivedByLabel:"",listSinceBlock:"str int",listTransactions:"str int int",listUnspent:"int int",listWalletDir:"",listWallets:"",loadWallet:"str",lockUnspent:"",logging:"",move:"str str float int str",ping:"",preciousBlock:"str",prioritiseTransaction:"str float int",pruneBlockChain:"int",psbtBumpFee:"str",removePrunedFunds:"str",reScanBlockChain:"",saveMemPool:"",send:"obj",setHDSeed:"",setLabel:"str str",setWalletFlag:"str",scanTxOutSet:"str",sendFrom:"str str float int str str",sendMany:"str obj int str",sendRawTransaction:"str",sendToAddress:"str float str str",setAccount:"",setBan:"str str",setNetworkActive:"bool",setGenerate:"bool int",setTxFee:"float",signMessage:"",signMessageWithPrivKey:"str str",signRawTransaction:"",signRawTransactionWithKey:"str obj",signRawTransactionWithWallet:"str",stop:"",submitBlock:"str",submitHeader:"str",testMemPoolAccept:"obj",unloadWallet:"",upgradeWallet:"",uptime:"",utxoUpdatePSBT:"str",validateAddress:"",verifyChain:"",verifyMessage:"",verifyTxOutProof:"str",walletCreateFundedPSBT:"",walletDisplayAddress:"str",walletLock:"",walletPassPhrase:"string int",walletPassphraseChange:"",walletProcessPSBT:"str"};var tt=function(e,t,o){return Array.prototype.slice.call(e,t,o)};function ot(){return parseInt(1e5*Math.random())}!function(e,t,o){function n(e,t){return function(){var n=arguments.length-1;this.batchedCalls&&(n=arguments.length);for(var r=0;r<n;r++)t[r]&&(arguments[r]=t[r](arguments[r]));this.batchedCalls?this.batchedCalls.push({jsonrpc:"2.0",method:e,params:tt(arguments),id:ot()}):o.call(this,{method:e,params:tt(arguments,0,arguments.length-1),id:ot()},arguments[arguments.length-1])}}var r={str:function(e){return e.toString()},int:function(e){return parseFloat(e)},float:function(e){return parseFloat(e)},bool:function(e){return!0===e||"1"==e||"true"==e||"true"==e.toString().toLowerCase()},obj:function(e){return"string"==typeof e?JSON.parse(e):e}};for(var i in t){var c=[];if(t[i].length){c=t[i].split(" ");for(var s=0;s<c.length;s++)r[c[s]]?c[s]=r[c[s]]:c[s]=r.str}var a=i.toLowerCase();e.prototype[i]=n(a,c),e.prototype[a]=e.prototype[i]}}(Xe,Xe.callspec,et);var nt=Xe;const rt=new nt({protocol:process.env.RPC_PROTOCOL,user:process.env.RPC_USER,pass:process.env.RPC_PASSWORD,host:process.env.RPC_HOST,port:process.env.RPC_PORT});const ct={createwallet:w.default.promisify(nt.prototype.createwallet.bind(rt)),getaddressinfo:w.default.promisify(nt.prototype.getaddressinfo.bind(rt)),getBlock:w.default.promisify(nt.prototype.getBlock.bind(rt)),getBlockchainInfo:w.default.promisify(nt.prototype.getBlockchainInfo.bind(rt)),getBlockHash:w.default.promisify(nt.prototype.getBlockHash.bind(rt)),generateToAddress:w.default.promisify(nt.prototype.generateToAddress.bind(rt)),getRawTransaction:w.default.promisify(nt.prototype.getRawTransaction.bind(rt)),importaddress:w.default.promisify(nt.prototype.importaddress.bind(rt)),listunspent:w.default.promisify(nt.prototype.listunspent.bind(rt)),sendRawTransaction:w.default.promisify(nt.prototype.sendRawTransaction.bind(rt))};const{PrivateKey:st,Opcode:at,Script:dt,Mnemonic:ut,crypto:lt,Transaction:ht,encoding:pt}=t.Bitcoin;const{CHAIN:vt,NETWORK:_t,TEST_SEEDS:yt}=C;function gt(e=0){return yt.split(";")[e]}function ft(e=0){return new Je(function(e=0){return{mnemonic:new ut(gt()),chain:vt,network:_t,path:ce({account:e})}}(e))}new R;const bt=({random:e=!1}={})=>m(void 0,void 0,void 0,(function*(){const t=e?ce():re();const o=gt();const r=new be({seed:o,path:t});return yield n.backOff((()=>m(void 0,void 0,void 0,(function*(){return(e=>m(void 0,void 0,void 0,(function*(){const{result:t}=yield ct.generateToAddress(1,e.getAddress());const{result:o}=yield ct.getBlock(t[0],2);if(o.confirmations<=0)throw new Error(`No confirmations on block mining: ${o.confirmations}`)})))(r)})))),t}));function wt(t,o){const n=Object.keys(o);const r=Object.keys(t);if(n.length!==r.length)throw new Error("Actual keys do not match expected keys");n.forEach((n=>{const r=t[n];const i=o[n];if(void 0===i)throw new Error(`${n} is not defined in expected object`);if("value"===i.check)e.expect(t).to.have.property(n),e.expect(t[n]).to.deep.eq(i.value);else{if("type"!==i.check)throw new Error("Error configuring expectToEqual: set 'check' to 'type' or 'value'");if("string"===i.type)e.expect(t).to.have.property(n).that.is.a("string");else if("number"===i.type)e.expect(t).to.have.property(n).that.is.a("number");else if("array"===i.type){if(e.expect(t).to.have.property(n).that.is.a("array").that.have.lengthOf(i.length),void 0!==i.length&&i.length>0)for(let t=0;t<r.length;t+=1)e.expect(r[t]).to.be.an(i.subtype)}else{if("object"!==i.type)throw new Error("Error configuring expectToEqual: set 'type' to 'number', 'string', array', or 'object'.");e.expect(t).to.have.property(n).that.is.an("object")}}}))}const{CHAIN:kt="LTC",NETWORK:xt="regtest",RPC_USER:mt,RPC_PASSWORD:St,RPC_HOST:Ot}=process.env;const Nt="LTC"===process.env.CHAIN?19332:8332;var jt=Object.assign(Object.assign({},C),{CHAIN:kt,NETWORK:xt,BCN_URL:"http://127.0.0.1:3000",RPC_PROTOCOL:"http",RPC_USER:mt,RPC_PASSWORD:St,RPC_HOST:Ot,RPC_PORT:Nt,TEST_ADDRESSES:"mwADSUHvPCGrrX4ozP8Kcd5JCWK93rnc8h;moMoH1vTgCc2dkDfGSKYPnafxy22wSqgrr;mmQEk8VwtSehRryLF8jhVapYg553hJGhNa;miKQVhZbFKSsJcQZ8eXwBQ89xNyetpN34q;mzoGRNh55y9j57TPdwRGi3nt9X4CFwpqUS;n1X6JFDyxibtdhYrc7mrkuft6o168ELFNW;mjLcig6eTZVJkgRgJFMkwrYHpfMnZ1t4kk;mfYkMQAe7afeRSkgLxAtwnMVryjLTfr95Q"});const qt=new R;const Tt=e=>e.split("/")[0];const Ct=gt();const Rt=e=>{const[t,o]=e.split("/");const n=parseFloat(o);return[64,65].includes(t.length)&&!Number.isNaN(n)&&Number.isFinite(n)};let At=[];before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){At=yield function({n:e=1,random:t=!1}={}){return m(this,void 0,void 0,(function*(){const o=[];for(let n=0;n<e;n+=1)o.push(yield bt({random:t}));return yield m(void 0,void 0,void 0,(function*(){let e=!1;do{try{const{result:t}=yield ct.generateToAddress(100,(new ut).toHDPrivateKey("",_t).derive(re(vt,_t)).privateKey.toPublicKey().toAddress());e=100===t.length}catch(e){te(500)}}while(!e)})),o}))}({n:44,random:!0})}))));let Et=0;function It(){if(Et+=1,At.length)return At.pop();throw Error(`No more paths ${Et}`)}describe("Computer",(()=>{describe("New",(()=>{describe("Should create a smart object without argument",(()=>{class t{constructor(){this.n=1}}let o;let n;let r;let i;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){n=new Je({seed:Ct,path:It()}),r=new Je({seed:Ct,path:It()}),({db:i}=n),o=yield n.new(t)})))),it("Should create a smart object when computer.new is called",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{n:{check:"value",type:"number",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>m(void 0,void 0,void 0,(function*(){e.expect(o._id).eq(o._rev),e.expect(o._id).eq(o._root),e.expect(Rt(o._id)),e.expect(Rt(o._rev)),e.expect(Rt(o._root))})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:i});e.expect(yield t.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>m(void 0,void 0,void 0,(function*(){const n=yield i.get([o._rev]);e.expect(n).to.be.an("array").that.have.lengthOf(1),wt(n[0],{__func:{check:"value",value:"constructor",type:"string"},__args:{check:"type",type:"array",length:0},__index:{check:"type",type:"object"},__cls:{check:"value",value:t.toString(),type:"string"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT,type:"number"}}),e.expect(n[0].__index).to.deep.eq({obj:0})})))),it("should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield n.getLatestRev(o._id)).eq(o._rev)})))),it("should work with getLatestRevs",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield n.getLatestRevs([o._id])).to.deep.eq([o._rev])})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create a smart object with a dumb argument",(()=>{class t{constructor(e){this.n=e}}let o;const n=Math.random();let r;let i;let c;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){r=new Je({seed:Ct,path:It()}),i=new Je({seed:Ct,path:It()}),({db:c}=r),o=yield r.new(t,[n])})))),it("Should create a smart object when computer.new is called",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{n:{check:"value",type:"number",value:n},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>m(void 0,void 0,void 0,(function*(){e.expect(o._id).eq(o._rev),e.expect(o._id).eq(o._root),e.expect(Rt(o._id)),e.expect(Rt(o._rev)),e.expect(Rt(o._root))})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:c});e.expect(yield t.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>m(void 0,void 0,void 0,(function*(){const r=yield c.get([o._rev]);e.expect(r).to.be.an("array").that.have.lengthOf(1),wt(r[0],{__func:{check:"value",value:"constructor",type:"string"},__args:{check:"type",type:"array",length:1,subtype:"number"},__index:{check:"type",type:"object"},__cls:{check:"value",value:t.toString(),type:"string"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT,type:"number"}}),e.expect(r[0].__args).to.deep.eq([n]),e.expect(r[0].__index).to.deep.eq({obj:0})})))),it("should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create a smart object with a smart argument",(()=>{class t{constructor(){this.n=1}}class o{constructor(e){this.a=e}}let n;let r;let i;let c;let s;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){i=new Je({seed:Ct,path:It()}),c=new Je({seed:Ct,path:It()}),({db:s}=i),n=yield i.new(t,[]),r=yield i.new(o,[n])})))),it("Should create a smart object when computer.new is called",(()=>m(void 0,void 0,void 0,(function*(){wt(n,{n:{check:"value",type:"number",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(r.a,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),e.expect(r.a).to.deep.eq(n)})))),it("Should set the location correctly",(()=>m(void 0,void 0,void 0,(function*(){e.expect(Rt(n._id)),e.expect(Rt(n._rev)),e.expect(Rt(n._root)),e.expect(Rt(r._id)),e.expect(Rt(r._rev)),e.expect(Rt(r._root));const t=Tt(n._id);const o=Tt(r._id);e.expect(t).not.eq(o),e.expect(n._id).eq(`${t}/0`),e.expect(n._rev).eq(`${o}/0`),e.expect(r._id).eq(`${o}/1`),e.expect(r._rev).eq(`${o}/1`),e.expect(r.a._id).eq(n._id),e.expect(r.a._rev).eq(n._rev),e.expect(n._root).eq(n._id),e.expect(r._root).eq(r._id)})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:s});e.expect(yield t.get(n._rev)).to.deep.eq(n),e.expect(yield t.get(r._rev)).to.deep.eq(r)})))),it("Should broadcast a transaction with an output containing data",(()=>m(void 0,void 0,void 0,(function*(){const i=yield s.get([n._id]);e.expect(i).to.be.an("array").that.have.lengthOf(1),wt(i[0],{__func:{check:"value",value:"constructor",type:"string"},__args:{check:"type",type:"array",length:0},__index:{check:"type",type:"object"},__cls:{check:"value",value:t.toString(),type:"string"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT,type:"number"}}),e.expect(i[0].__index).to.deep.eq({obj:0});const c=Tt(r._id);const a=yield s.get([`${c}/0`,`${c}/1`]);e.expect(a).to.be.an("array").that.have.lengthOf(2),wt(a[0],{__index:{check:"type",type:"object"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT,type:"number"}}),e.expect(a[0].__index).to.deep.eq({0:0,obj:1}),wt(a[1],{a:{check:"value",value:0},__func:{check:"value",value:"constructor"},__args:{check:"value",value:["__"]},__cls:{check:"value",value:o.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}})})))),it("Should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield i.getLatestRev(r._id)).eq(r._rev),e.expect(yield i.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with getLatestRevs",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield i.getLatestRevs([n._id])).to.deep.eq([n._rev]),e.expect(yield i.getLatestRevs([r._id])).to.deep.eq([r._rev])})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield c.sync(n._rev)).to.deep.eq(n),e.expect(yield c.sync(r._rev)).to.deep.eq(r)}))))})),describe("Should create a smart object with a sub-object",(()=>{class t{constructor(){this.n={m:1}}}let o;let n;let r;let i;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){n=new Je({seed:Ct,path:It()}),r=new Je({seed:Ct,path:It()}),({db:i}=n),o=yield n.new(t,[])})))),it("Should create a smart object when computer.new is called",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{n:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(o.n,{m:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>m(void 0,void 0,void 0,(function*(){e.expect(o._id).eq(o._rev),e.expect(o.n._id).eq(o.n._rev),e.expect(o._root).eq(o._id),e.expect(o.n._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:i});const n=yield t.get(o._rev);e.expect(n).to.deep.eq(o),e.expect(o.n._id.startsWith("__temp__")).eq(!1),e.expect(o.n._rev.startsWith("__temp__")).eq(!1);const r=yield t.get(o.n._rev);e.expect(r).to.be.undefined})))),it("Should broadcast a transaction with an output containing data",(()=>m(void 0,void 0,void 0,(function*(){const n=yield i.get([o._rev]);e.expect(n).to.be.an("array").that.have.lengthOf(1),wt(n[0],{n:{check:"value",value:1},__func:{check:"value",value:"constructor"},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:t.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}})})))),it("Should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield n.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create a smart object with a smart sub-object",(()=>{class t{constructor(e){this.b=e?new t(!1):void 0}}let o;let n;let r;let i;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){n=new Je({seed:Ct,path:It()}),r=new Je({seed:Ct,path:It()}),({db:i}=n),o=yield n.new(t,[!0])})))),it("Should create a smart object when computer.new is called",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{b:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(o.b,{b:{check:"value",value:void 0},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>m(void 0,void 0,void 0,(function*(){e.expect(o._id).eq(o._rev),e.expect(o.b._id).eq(o.b._rev),e.expect(o._root).eq(o._id),e.expect(o.b._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:i});const n=yield t.get(o._rev);e.expect(n).to.deep.eq(o),e.expect(o.b._id.startsWith("__temp__")).eq(!1),e.expect(o.b._rev.startsWith("__temp__")).eq(!1);const r=yield t.get(o.b._rev);e.expect(r).to.be.undefined})))),it("Should broadcast a transaction with an output containing data",(()=>m(void 0,void 0,void 0,(function*(){const n=yield i.get([o._rev]);e.expect(n).to.be.an("array").that.have.lengthOf(1),wt(n[0],{b:{check:"value",value:1},__func:{check:"value",value:"constructor"},__args:{check:"value",value:[!0]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:t.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}})})))),it("Should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield n.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create a smart object with an owner defined",(()=>{class t{constructor(e,t){this.n=e,this._owners=[t]}}let o;const n=Math.random();let r;let i;let c;let s;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){r=new Je({seed:Ct,path:It()}),i=new Je({seed:Ct,path:It()}),({db:c}=r),s=r.db.wallet.getPublicKey().toString(),o=yield r.new(t,[n,s])})))),it("Should create a smart object when computer.new is called",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{n:{check:"value",value:n},_owners:{check:"value",value:[s]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>m(void 0,void 0,void 0,(function*(){e.expect(o._id).eq(o._rev),e.expect(o._id).eq(o._root),e.expect(Rt(o._id)),e.expect(Rt(o._rev)),e.expect(Rt(o._root))})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:c});e.expect(yield t.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>m(void 0,void 0,void 0,(function*(){const r=yield c.get([o._rev]);e.expect(r).to.be.an("array").that.have.lengthOf(1),wt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[n,s]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:t.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}})})))),it("should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create an encrypted smart object",(()=>{class t{constructor(e,t){this.n=e,this._readers=[t]}}let o;const n=Math.random();let r;let i;let c;let s;let a;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){r=new Je({seed:Ct,path:It()}),i=new Je({seed:"average metal token tube twice idle yellow mail imitate nuclear clerk cover",path:It()}),({db:c}=r),({db:s}=i),a=r.db.wallet.getPublicKey().toString(),o=yield r.new(t,[n,a])})))),it("Should create a smart object when computer.new is called",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{n:{check:"value",value:n},_readers:{check:"value",value:[a]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>m(void 0,void 0,void 0,(function*(){e.expect(o._id).eq(o._rev),e.expect(o._id).eq(o._root),e.expect(Rt(o._id)),e.expect(Rt(o._rev)),e.expect(Rt(o._root))})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:c});e.expect(yield t.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with encoded data",(()=>m(void 0,void 0,void 0,(function*(){const r=yield c.get([o._id]);e.expect(r).to.be.an("array").that.have.lengthOf(1),wt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[n,a]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:t.toString()},_readers:{check:"value",value:[]},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}})})))),it("Should be able to decode the output when db has access",(()=>m(void 0,void 0,void 0,(function*(){const r=yield c.get([o._rev]);e.expect(r).to.be.an("array").that.have.lengthOf(1),wt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[n,a]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:t.toString()},_readers:{check:"value",value:[]},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}})})))),it("Should be not able to decode the output when db does not has access",(()=>m(void 0,void 0,void 0,(function*(){try{yield s.get([o._rev])}catch(t){e.expect(t).to.be.instanceof(Error),e.expect(t).to.have.property("message","Decryption failure")}})))),it("should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield r.sync(o._rev)).to.deep.eq(o);try{yield i.sync(o._rev),e.expect(!0).eq(!1)}catch(t){e.expect(t.message).eq("Cannot read properties of undefined (reading '__cls')")}}))))})),describe("Should create an off-chain object",(()=>{class t{constructor(e){this.n=e,this._url="http://127.0.0.1:3000"}}let o;const n=Math.random();let r;let i;let c;let s;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){r=new Je({seed:Ct,path:It()}),i=new Je({seed:Ct,path:It()}),({db:c}=r),({db:s}=i),o=yield r.new(t,[n])})))),it("Should create a smart object when computer.new is called",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{n:{check:"value",value:n},_url:{check:"value",value:"http://127.0.0.1:3000"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:c});e.expect(yield t.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with encoded data data",(()=>m(void 0,void 0,void 0,(function*(){const i=o._rev.split("/")[0];const c=yield fe.fromTxId(i,qt,r.db.wallet.getPrivateKey());const{outData:s}=c;e.expect(s).to.be.an("array").that.have.lengthOf(1),wt(s[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[n]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:t.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT},_url:{check:"type",type:"string"}})})))),it("Should be able to get the output from the server when db has access",(()=>m(void 0,void 0,void 0,(function*(){const r=yield c.get([o._rev]);e.expect(r).to.be.an("array").that.have.lengthOf(1),wt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[n]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:t.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("Should give all users access to the server",(()=>m(void 0,void 0,void 0,(function*(){const r=yield s.get([o._rev]);e.expect(r).to.be.an("array").that.have.lengthOf(1),wt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[n]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:t.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work if the contract is a string",(()=>{let t=null;let o;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){o=new Je({seed:Ct,path:It()}),t=yield o.new("class A {\n        constructor(n) {\n          this.n = n\n        }\n      }",[1])})))),it("should work",(()=>{e.expect(t).to.not.be.undefined,e.expect(typeof t).eq("object"),wt(t,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),e.expect(t._id).eq(t._rev)})),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){const o=ft();e.expect(yield o.sync(t._rev)).to.deep.eq(t)}))))})),describe("Should not create a smart object if no args as passed to the constructor",(()=>{class t{constructor(e,t){this.n=e,this._owners=[t]}}let o;it("Should throw an error",(()=>m(void 0,void 0,void 0,(function*(){try{const n=new Je;o=o||(yield n.new(t,[])),e.expect(!0).eq(!1)}catch(t){e.expect(o).to.be.undefined,e.expect(t.message).to.not.be.undefined}}))))}))})),describe("Function calls",(()=>{describe("Should work for a function call with a dumb argument",(()=>{class t{constructor(e){this.n=e}inc(e){return this.n+=e,this.n}}let o;let n;let r;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){const e=new Je({seed:Ct,path:It()});r=new Je({seed:Ct,path:It()}),({db:n}=e),o=yield e.new(t,[1]),yield o.inc(1)})))),it("Should update the smart object",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{n:{check:"value",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>m(void 0,void 0,void 0,(function*(){e.expect(Rt(o._id)).eq(!0),e.expect(Rt(o._rev)).eq(!0),e.expect(Rt(o._root)).eq(!0),e.expect(o._id).not.eq(o._rev),e.expect(o._id).eq(o._root)})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:n});e.expect(yield t.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>m(void 0,void 0,void 0,(function*(){const r=yield n.get([o._id]);e.expect(r).to.be.an("array").that.have.lengthOf(1),wt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:t.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}});const i=yield n.get([o._rev]);e.expect(i).to.be.an("array").that.have.lengthOf(1),wt(i[0],{__func:{check:"value",value:"inc"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}})})))),it("Should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){const t=new Je;e.expect(yield t.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work for a function call on an encrypted object",(()=>{class t{constructor(e,t){this.n=e,this._readers=[t]}inc(e){return this.n+=e,this.n}}let o;const n=Math.random();let r;let i;let c;let s;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){r=new Je({seed:Ct,path:It()}),i=new Je({seed:"average metal token tube twice idle yellow mail imitate nuclear clerk cover",path:It()}),({db:c}=r),s=r.db.wallet.getPublicKey().toString(),o=yield r.new(t,[n,s]),yield o.inc(1)})))),it("Should update the smart object",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{n:{check:"type",type:"number"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"},_readers:{check:"value",value:[s]}})})))),it("Should set the location correctly",(()=>m(void 0,void 0,void 0,(function*(){e.expect(Rt(o._id)).eq(!0),e.expect(Rt(o._rev)).eq(!0),e.expect(Rt(o._root)).eq(!0),e.expect(o._id).not.eq(o._rev),e.expect(o._id).eq(o._root)})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:c});e.expect(yield t.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>m(void 0,void 0,void 0,(function*(){const r=yield c.get([o._id]);e.expect(r).to.be.an("array").that.have.lengthOf(1),wt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[n,s]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:t.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT},_readers:{check:"value",value:[]}});const i=yield c.get([o._rev]);e.expect(i).to.be.an("array").that.have.lengthOf(1),wt(i[0],{__func:{check:"value",value:"inc"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT},_readers:{check:"value",value:[]}})})))),it("Should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield r.sync(o._rev)).to.deep.eq(o);try{yield i.sync(o._rev),e.expect(!0).eq(!1)}catch(t){e.expect(t.message).eq("Cannot read properties of undefined (reading '__cls')")}}))))})),describe("Should work for a function call on an off chain object",(()=>{class t{constructor(e){this.n=e,this._url="http://127.0.0.1:3000"}inc(e){return this.n+=e,this.n}}let o;const n=Math.random();let r;let i;let c;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){r=new Je({seed:Ct,path:It()}),i=new Je({seed:Ct,path:It()}),({db:c}=r),o=yield r.new(t,[n]),yield o.inc(1)})))),it("Should update the smart object",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{n:{check:"type",type:"number"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("Should set the location correctly",(()=>m(void 0,void 0,void 0,(function*(){e.expect(Rt(o._id)).eq(!0),e.expect(Rt(o._rev)).eq(!0),e.expect(Rt(o._root)).eq(!0),e.expect(o._id).not.eq(o._rev),e.expect(o._id).eq(o._root)})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:c});e.expect(yield t.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>m(void 0,void 0,void 0,(function*(){const r=yield c.get([o._id]);e.expect(r).to.be.an("array").that.have.lengthOf(1),wt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[n]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:t.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT},_url:{check:"value",value:"http://127.0.0.1:3000"}});const i=yield c.get([o._rev]);e.expect(i).to.be.an("array").that.have.lengthOf(1),wt(i[0],{__func:{check:"value",value:"inc"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("Should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work for a function with a smart argument",(()=>{class t{constructor(){this.n=1}}class o{constructor(){this.m=2}objInc(e){return e.n+=1,this.m+=e.n,this.m}}let n;let r;let i;let c;let s;let a;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){c=new Je({seed:Ct,path:It()}),s=new Je({seed:Ct,path:It()}),a=c.db,n=yield c.new(t,[]),r=yield c.new(o,[]),i=yield r.objInc(n)})))),it("Should update the smart object",(()=>m(void 0,void 0,void 0,(function*(){wt(n,{n:{check:"value",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(r,{m:{check:"value",value:4},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should return the correct value",(()=>{e.expect(i).eq(4)})),it("Should set the location correctly",(()=>m(void 0,void 0,void 0,(function*(){e.expect(Rt(n._id)).eq(!0),e.expect(Rt(n._rev)).eq(!0),e.expect(Rt(n._root)).eq(!0),e.expect(Rt(r._id)).eq(!0),e.expect(Rt(r._rev)).eq(!0),e.expect(Rt(r._root)).eq(!0);const t=Tt(n._id);const o=Tt(r._id);const i=Tt(r._rev);e.expect(t).not.eq(o),e.expect(o).not.eq(i),e.expect(i).not.eq(t),e.expect(n._id).eq(`${t}/0`),e.expect(r._id).eq(`${o}/0`),e.expect(n._rev).eq(`${i}/0`),e.expect(r._rev).eq(`${i}/1`),e.expect(n._root).eq(n._id),e.expect(r._root).eq(r._id)})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:a});e.expect(yield t.get(n._rev)).to.deep.eq(n),e.expect(yield t.get(r._rev)).to.deep.eq(r)})))),it("Should broadcast a transaction with an output containing data",(()=>m(void 0,void 0,void 0,(function*(){const i=yield a.get([n._id]);e.expect(i).to.be.an("array").that.have.lengthOf(1),wt(i[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[]},__cls:{check:"value",value:t.toString()},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}});const c=Tt(r._id);const s=yield a.get([`${c}/0`]);e.expect(s).to.be.an("array").that.have.lengthOf(1),wt(s[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[]},__cls:{check:"value",value:o.toString()},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}});const d=Tt(r._rev);const u=yield a.get([`${d}/0`,`${d}/1`]);e.expect(u).to.be.an("array").that.have.lengthOf(2),wt(u[0],{__index:{check:"value",value:{obj:1,0:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}}),wt(u[1],{__func:{check:"value",value:"objInc"},__args:{check:"value",value:["__"]},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}})})))),it("Should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield c.getLatestRev(n._id)).eq(n._rev),e.expect(yield c.getLatestRev(r._id)).eq(r._rev)})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield s.sync(n._rev)).to.deep.eq(n),e.expect(yield s.sync(r._rev)).to.deep.eq(r)}))))})),describe("Should work for a function that returns a dumb object",(()=>{class t{getJson(){return{n:1}}}let o;let n;let r;let i;let c;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){r=new Je({seed:Ct,path:It()}),i=new Je({seed:Ct,path:It()}),({db:c}=r),o=yield r.new(t,[]),n=n||(yield o.getJson(3))})))),it("Should update the smart object",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(n,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>m(void 0,void 0,void 0,(function*(){e.expect(Rt(o._id)).eq(!0),e.expect(Rt(o._rev)).eq(!0),e.expect(Rt(o._root)).eq(!0),e.expect(Rt(n._id)).eq(!0),e.expect(Rt(n._rev)).eq(!0),e.expect(Rt(n._root)).eq(!0);const t=Tt(o._id);const r=Tt(n._id);e.expect(t).not.eq(r),e.expect(o._id).eq(`${t}/0`),e.expect(n._id).eq(`${r}/1`),e.expect(o._rev).eq(`${r}/0`),e.expect(n._rev).eq(`${r}/1`),e.expect(o._root).eq(o._id),e.expect(n._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:c});e.expect(yield t.get(o._rev)).to.deep.eq(o),e.expect(yield t.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with an output containing data",(()=>m(void 0,void 0,void 0,(function*(){const r=yield c.get([o._id]);e.expect(r).to.be.an("array").that.have.lengthOf(1),wt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:t.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}});const i=Tt(n._id);const s=yield c.get([`${i}/0`,`${i}/1`]);e.expect(s).to.be.an("array").that.have.lengthOf(2),wt(s[0],{__func:{check:"value",value:"getJson"},__args:{check:"value",value:[3]},__index:{check:"value",value:{obj:0,res:1}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}}),wt(s[1],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}})})))),it("Should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield r.getLatestRev(o._id)).eq(o._rev),e.expect(yield r.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield i.sync(o._rev)).to.deep.eq(o),e.expect(yield i.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should work for a function that returns a smart object",(()=>{class t{constructor(e){this.n=e}send(e){if(e>this.n)throw new Error;return this.n-=e,new t(e)}}let o;let n;let r;let i;let c;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){r=new Je({seed:Ct,path:It()}),i=new Je({seed:Ct,path:It()}),({db:c}=r),o=yield r.new(t,[10]),n=yield o.send(3)})))),it("Should update the smart object",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{n:{check:"value",value:7},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(n,{n:{check:"value",value:3},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>m(void 0,void 0,void 0,(function*(){e.expect(Rt(o._id)).eq(!0),e.expect(Rt(o._rev)).eq(!0),e.expect(Rt(o._root)).eq(!0),e.expect(Rt(n._id)).eq(!0),e.expect(Rt(n._rev)).eq(!0),e.expect(Rt(n._root)).eq(!0);const t=Tt(o._id);const r=Tt(n._id);e.expect(t).not.eq(r),e.expect(o._id).eq(`${t}/0`),e.expect(n._id).eq(`${r}/1`),e.expect(o._rev).eq(`${r}/0`),e.expect(n._rev).eq(`${r}/1`),e.expect(o._root).eq(o._id),e.expect(n._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:c});e.expect(yield t.get(o._rev)).to.deep.eq(o),e.expect(yield t.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with an output containing data",(()=>m(void 0,void 0,void 0,(function*(){const r=yield c.get([o._id]);e.expect(r).to.be.an("array").that.have.lengthOf(1),wt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[10]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:t.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}});const i=Tt(n._id);const s=yield c.get([`${i}/0`,`${i}/1`]);e.expect(s).to.be.an("array").that.have.lengthOf(2),wt(s[0],{__func:{check:"value",value:"send"},__args:{check:"value",value:[3]},__index:{check:"value",value:{obj:0,res:1}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}}),wt(s[1],{__cls:{check:"value",value:t.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}})})))),it("Should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield r.getLatestRev(o._id)).eq(o._rev),e.expect(yield r.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield i.sync(o._rev)).to.deep.eq(o),e.expect(yield i.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should work for a function that updates a nested object",(()=>{class t{constructor(){this.a={aa:1},this.b={bb:2}}update(){this.b.bb=3}}let o;let n;let r;let i;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){n=new Je({seed:Ct,path:It()}),r=new Je({seed:Ct,path:It()}),({db:i}=n),o=yield n.new(t,[]),yield o.update()})))),it("Should update the smart object",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{a:{check:"type",type:"object"},b:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(o.a,{aa:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(o.b,{bb:{check:"value",value:3},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>m(void 0,void 0,void 0,(function*(){e.expect(Rt(o._id)).eq(!0),e.expect(Rt(o._rev)).eq(!0),e.expect(Rt(o._root)).eq(!0),e.expect(Rt(o.a._id)).eq(!0),e.expect(Rt(o.a._rev)).eq(!0),e.expect(Rt(o.a._root)).eq(!0),e.expect(Rt(o.b._id)).eq(!0),e.expect(Rt(o.b._rev)).eq(!0),e.expect(Rt(o.b._root)).eq(!0);const t=Tt(o._id);e.expect(o._id).eq(`${t}/0`),e.expect(o.a._id).eq(`${t}/1`),e.expect(o.b._id).eq(`${t}/2`),e.expect(o._root).eq(o._id),e.expect(o.a._root).eq(o._id),e.expect(o.b._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:i});e.expect(yield t.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>m(void 0,void 0,void 0,(function*(){const n=yield i.get([o._id,o.a._id,o.b._id]);e.expect(n).to.be.an("array").that.have.lengthOf(3),wt(n[0],{a:{check:"value",value:1},b:{check:"value",value:2},__func:{check:"value",value:"constructor"},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:t.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}}),wt(n[1],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}}),wt(n[2],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}});const r=yield i.get([o._rev,o.a._rev,o.b._rev]);e.expect(r).to.be.an("array").that.have.lengthOf(3),wt(r[0],{b:{check:"value",value:1},__func:{check:"value",value:"update"},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}}),wt(r[1],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}}),wt(r[2],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:L.MIN_NON_DUST_AMOUNT}})})))),it("Should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield n.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work for a function that returns an array",(()=>{class e{constructor(){this.aa=1}createArray(){return this.a=new e,[new e,new e]}}let t;let o;let n;let r;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){r=new Je({seed:Ct,path:It()}),t=yield r.new(e,[]),[o,n]=yield t.createArray()})))),it("Should return an array",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{aa:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(n,{aa:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns an object created by a property wrapped as object",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}o(){return{o:this.a.f()}}}let o;let n;let r;let i;let c;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){c=new Je({seed:Ct,path:It()}),o=yield c.new(e,[]),r=yield c.new(t,[o]),n=yield r.g(),({o:i}=yield r.o())})))),it("Should return the object",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(i,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns an object created by a property wrapped in an array",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}o(){return[this.a.f()]}}let o;let n;let r;let i;let c;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){c=new Je({seed:Ct,path:It()}),o=yield c.new(e,[]),r=yield c.new(t,[o]),n=yield r.g(),[i]=yield r.o()})))),it("Should return the object",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(i,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns multiple objects created by a property wrapped in an array",(()=>{class t{f(){return new t}}class o{constructor(e){this.a=e}g(){return this.a.f()}o(){return[this.a.f(),this.a.f()]}}let n;let r;let i;let c;let s;let a;let d;let u;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){a=new Je({seed:Ct,path:It()}),d=new Je({seed:Ct,path:It()}),({db:u}=a),n=yield a.new(t,[]),i=yield a.new(o,[n]),r=yield i.g(),[c,s]=yield i.o()})))),it("Should update the smart object",(()=>m(void 0,void 0,void 0,(function*(){wt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(r,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(c,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(s,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(i,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(i.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>m(void 0,void 0,void 0,(function*(){const t=[n,r,c,s,i];for(let o=0;o<t.length;o+=1){const n=t[o];e.expect(Rt(n._id)).eq(!0),e.expect(Rt(n._rev)).eq(!0),e.expect(Rt(n._root)).eq(!0)}e.expect(n._id).not.eq(n._rev),e.expect(i._id).not.eq(i._rev),e.expect(r._id).eq(r._rev)})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:u});e.expect(yield t.get(n._rev)).to.deep.eq(n),e.expect(yield t.get(r._rev)).to.deep.eq(r),e.expect(yield t.get(i._rev)).to.deep.eq(i)})))),it("Should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield a.getLatestRev(n._id)).eq(n._rev),e.expect(yield a.getLatestRev(r._id)).eq(r._rev),e.expect(yield a.getLatestRev(i._id)).eq(i._rev)})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield d.sync(n._rev)).to.deep.eq(n),e.expect(yield d.sync(r._rev)).to.deep.eq(r),e.expect(yield d.sync(i._rev)).to.deep.eq(i)}))))})),describe("Should work for a function that returns multiple objects created by a property",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}o(){return this.a.f()}}let o;let n;let r;let i;let c;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){c=new Je({seed:Ct,path:It()}),o=yield c.new(e,[]),r=yield c.new(t,[o]),n=yield r.g(),i=yield r.o()})))),it("Should return the object",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(i,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns an object created by a property",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}}let o;let n;let r;let i;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){i=new Je({seed:Ct,path:It()}),o=yield i.new(e,[]),r=yield i.new(t,[o]),n=yield r.g()})))),it("Should return the object",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work when setting an owner",(()=>{class t{constructor(e){this._owners=[e]}updateOwner(e){this._owners=[e]}}let o;const n=new Je({chain:jt.CHAIN,network:jt.NETWORK,path:""});const r=n.db.wallet.getPublicKey().toString();let i;let c;let s;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){i=new Je({seed:Ct,path:It()}),s=i.db.wallet.getPublicKey().toString(),({db:c}=i),o=yield i.new(t,[s]),yield o.updateOwner(r)})))),it("Should update the smart object",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{_owners:{check:"value",value:[r]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>m(void 0,void 0,void 0,(function*(){const t=Tt(o._id);e.expect(o._id).eq(`${t}/0`)})))),it("Should return the object if reader.get is called",(()=>m(void 0,void 0,void 0,(function*(){const t=new He({db:c});e.expect(yield t.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>m(void 0,void 0,void 0,(function*(){const[n]=yield c.get([o._id]);e.expect(n).to.deep.eq({__func:"constructor",__args:[s],__index:{obj:0},__cls:t.toString(),_amount:L.MIN_NON_DUST_AMOUNT,_owners:[s]});const[i]=yield c.get([o._rev]);e.expect(i).to.deep.eq({__func:"updateOwner",__args:[r],__index:{obj:0},_owners:[r],_amount:L.MIN_NON_DUST_AMOUNT})})))),it("Should work with getLatestRev",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield i.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with getRevs",(()=>m(void 0,void 0,void 0,(function*(){e.expect((yield n.getRevs()).length).eq(1)})))),it("Should work with sync",(()=>m(void 0,void 0,void 0,(function*(){e.expect(yield n.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work with multiple computers",(()=>{class e{constructor(){this.n=1}inc(){this.n+=1}}let t=null;let o=null;let n;let r;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){n=new Je({seed:Ct,path:It()}),r=new Je({seed:Ct,path:It()}),t=yield n.new(e,[]),o=yield r.new(e,[]),yield t.inc()})))),it("should work",(()=>{wt(t,{n:{check:"value",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),wt(o,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))}))})),describe("sync",(()=>{class t{constructor(e,t){this.n=e,this._owners=[t]}}let o;const n=Math.random();let r;let i;before("Before Computer",(()=>m(void 0,void 0,void 0,(function*(){r=new Je({path:It(),seed:Ct}),i=r.db.wallet.getPublicKey().toString(),o=yield r.new(t,[n,i])})))),it("Should create another instance of the same smart object",(()=>m(void 0,void 0,void 0,(function*(){wt(o,{n:{check:"value",value:n},_owners:{check:"value",value:[i]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}});const t=ft();const r=yield t.sync(o._rev);e.expect(r).to.deep.eq(o)})))),it("throw an error if no params are passed to sync function",(()=>m(void 0,void 0,void 0,(function*(){const t=ft();try{yield t.sync(),e.expect(!0).eq(!1)}catch(t){if(!(t instanceof Error))throw new Error("Unknown error");e.expect(t.message).eq("Invalid outId: undefined")}})))),it("throw an error if rev is not in the right format: tdId:num",(()=>m(void 0,void 0,void 0,(function*(){const t=ft();try{yield t.sync("123"),e.expect(!0).eq(!1)}catch(t){if(!(t instanceof Error))throw new Error("Unknown error");e.expect(t.message).eq("Invalid outId: 123")}})))),it("throw an error if trId in rev is not 64 hex characters",(()=>m(void 0,void 0,void 0,(function*(){const t=ft();try{yield t.sync("123:0"),e.expect(!0).eq(!1)}catch(t){if(!(t instanceof Error))throw new Error("Unknown error");e.expect(t.message).eq("Invalid outId: 123:0")}})))),it("throw an error if trId in rev is contains non hex characters",(()=>m(void 0,void 0,void 0,(function*(){const t=ft();try{yield t.sync("31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844g:0"),e.expect(!0).eq(!1)}catch(t){if(!(t instanceof Error))throw new Error("Unknown error");e.expect(t.message).eq("Invalid outId: 31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844g:0")}})))),it("throw an error if num in rev is not a number",(()=>m(void 0,void 0,void 0,(function*(){const t=ft();try{yield t.sync("31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844f:abc"),e.expect(!0).eq(!1)}catch(t){if(!(t instanceof Error))throw new Error("Unknown error");e.expect(t.message).eq("Invalid outId: 31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844f:abc")}}))))}))}));
