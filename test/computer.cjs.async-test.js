"use strict";var e=require("bitcoin-computer-bitcore");var t=require("chai");require("ses");var n=require("axios");require("child_process");var o=require("crypto");var r=require("crypto-js");var i=require("eciesjs");var c=require("exponential-backoff");var s=require("http");var a=require("https");var d=require("url");var u=require("util");function l(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function h(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var o=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,o.get?o:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var p=l(n);var v=l(o);var _=l(r);var y=h(i);var g=l(s);var f=l(a);var b=l(d);var w=l(u);function k(e,t){var n={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(o=Object.getOwnPropertySymbols(e);r<o.length;r++)t.indexOf(o[r])<0&&Object.prototype.propertyIsEnumerable.call(e,o[r])&&(n[o[r]]=e[o[r]])}return n}function m(e,t,n,o){var r,i=arguments.length,c=i<3?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)c=Reflect.decorate(e,t,n,o);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(c=(i<3?r(c):i>3?r(t,n,c):r(t,n))||c);return i>3&&c&&Object.defineProperty(t,n,c),c}function x(e,t,n,o){return new(n||(n=Promise))((function(r,i){function c(e){try{a(o.next(e))}catch(e){i(e)}}function s(e){try{a(o.throw(e))}catch(e){i(e)}}function a(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(c,s)}a((o=o.apply(e,t||[])).next())}))}const S=e=>new Compartment({}).evaluate(e);const O=(e,t,n)=>new Compartment({target:e,thisArgument:t,argumentsList:n}).evaluate("Reflect.apply(target, thisArgument, argumentsList)");const N=(e,t)=>new Compartment({target:e,argumentsList:t}).evaluate(`Reflect.construct(${e}, argumentsList)`);const{crypto:j}=e.Bitcoin;const q=(e,t)=>{const n=Date.now();const o=j.Hash.sha256(Buffer.from(t+n));const r=[j.ECDSA.sign(o,e,"big").toString("hex"),e.publicKey.toString(),n];return`Bearer ${Buffer.from(r.join(":")).toString("base64")}`};class T{constructor(e,t,n={}){this.baseUrl=e,this.headers=n,this.privateKey=t}get(e){return x(this,void 0,void 0,(function*(){const t=this.privateKey?{Authentication:q(this.privateKey,this.baseUrl)}:{};return(yield p.default.get(`${this.baseUrl}${e}`,{headers:Object.assign(Object.assign({},this.headers),t)})).data}))}post(e,t){return x(this,void 0,void 0,(function*(){const n=this.privateKey?{Authentication:q(this.privateKey,this.baseUrl)}:{};return(yield p.default.post(`${this.baseUrl}${e}`,t,{headers:Object.assign(Object.assign({},this.headers),n)})).data}))}delete(e){return x(this,void 0,void 0,(function*(){const t=this.privateKey?{Authentication:q(this.privateKey,this.baseUrl)}:{};return(yield p.default.delete(`${this.baseUrl}${e}`,{headers:Object.assign(Object.assign({},this.headers),t)})).data}))}}var C={CHAIN:process.env.CHAIN||"LTC",NETWORK:process.env.NETWORK||"testnet",BCN_URL:process.env.BCN_URL||"https://node.bitcoincomputer.io",RPC_USER:process.env.RPC_USER||"bcn-admin",RPC_PASSWORD:process.env.RPC_PASSWORD||"kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=",TEST_MNEMONICS:"travel upgrade inside soda birth essence junk merit never twenty system opinion;toddler hockey salute wheel harvest video narrow riot guitar lake sea call;cannon hour begin test replace fury motion squirrel envelope announce neck culture"};class E extends class{constructor({chain:e=C.CHAIN,network:t=C.NETWORK}={}){this.chain=e,this.network=t}}{constructor({chain:e=C.CHAIN,network:t=C.NETWORK,url:n=C.BCN_URL}={}){super({chain:e,network:t}),this.url=n}}const{PrivateKey:R,Transaction:A}=e.Bitcoin;const{UnspentOutput:I}=A;function U(e){if(!/^[0-9A-Fa-f]{64}$/.test(e))throw new Error(`Invalid txId: ${e}`)}function B(e){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(e))throw new Error(`Invalid outId: ${e}`)}function P(e){B(e);const[t,n]=e.split("/");return{txId:t,outputIndex:parseInt(n,10)}}let M=class{constructor({nodeConfig:e=new E,privateKey:t=new R}={}){this.nodeConfig=e,this.bcn=new T(e.url,t)}get chain(){return this.nodeConfig.chain}get network(){return this.nodeConfig.network}get url(){return this.nodeConfig.url}getBalance(e){return x(this,void 0,void 0,(function*(){const{chain:t,network:n}=this;return yield this.bcn.get(`/v1/${t}/${n}/address/${e}/balance`)}))}getTransactions(e){return x(this,void 0,void 0,(function*(){return(yield this.getRawTxs(e)).map((e=>new A(e)))}))}getRawTxs(e){return x(this,void 0,void 0,(function*(){e.map(U);const{chain:t,network:n}=this;return this.bcn.post(`/v1/${t}/${n}/tx/bulk/`,{txIds:e})}))}sendTransaction(e){return x(this,void 0,void 0,(function*(){return this.bcn.post(`/v1/${this.chain}/${this.network}/tx/send`,{rawTx:e})}))}getUtxosByAddress(e){return x(this,void 0,void 0,(function*(){const{chain:t,network:n}=this;return(yield this.bcn.get(`/v1/${t}/${n}/wallet/${e.toString()}/utxos`)).map((({rev:e,scriptPubKey:t,satoshis:n})=>{const[o,r]=e.split("/");return new I({txId:o,outputIndex:parseInt(r,10),satoshis:n,script:t})}))}))}query({publicKey:e,classHash:t}){return x(this,void 0,void 0,(function*(){if(void 0===e&&void 0===t)throw new Error("Query parameters cannot be empty.");let n="";e&&(n+=`?publicKey=${e}`),t&&(n+=0===n.length?"?":"&",n+=`classHash=${t}`);const{chain:o,network:r}=this;return this.bcn.get(`/v1/${o}/${r}/non-standard-utxos${n}`)}))}idsToRevs(e){return x(this,void 0,void 0,(function*(){e.map(B);const{chain:t,network:n}=this;return this.bcn.post(`/v1/${t}/${n}/revs`,{ids:e})}))}callRPC(e,t){return x(this,void 0,void 0,(function*(){return this.bcn.post(`/v1/${this.chain}/${this.network}/rpc`,{method:e,params:t})}))}static getSecretOutput({_url:e,privateKey:t}){return x(this,void 0,void 0,(function*(){const n=e.split("/");const o=n[n.length-1];const r=n.slice(0,-2).join("/");const i=new T(r,t);return{host:r,data:yield i.get(`/v1/store/${o}`)}}))}static setSecretOutput({secretOutput:e,host:t,privateKey:n}){return x(this,void 0,void 0,(function*(){return new T(t,n).post("/v1/store/",e)}))}static deleteSecretOutput({_url:e,privateKey:t}){return x(this,void 0,void 0,(function*(){const n=e.split("/");const o=n[n.length-1];const r=n.slice(0,-2).join("/");const i=new T(r,t);yield i.delete(`/v1/store/${o}`)}))}};M=m([e=>e],M);const K=parseInt(process.env.BC_DUST_LIMIT||"",10)||1546;const $=parseInt(process.env.BC_DEFAULT_FEE||"",10)||2500;var D={MIN_NON_DUST_AMOUNT:K,SCRIPT_CHUNK_SIZE:parseInt(process.env.BC_SCRIPT_CHUNK_SIZE||"",10)||479,DEFAULT_FEE:$,SIGHASH_ALL:1,FEE_PER_KB:2e4,PUBLIC_KEY_SIZE:65,ANYONE_CAN_SPEND_MNEMONIC:"replace this seed",PASSPHRASE:"",ENCODING_LENGTH:3,ENCODING_NUMBER_LENGTH:3,MAX_PUBKEYS_PER_SCRIPT:3,OP_RETURN_SIZE:80,CHANGE_OUTPUT_MAX_SIZE:62};const{PublicKey:L,crypto:H}=e.Bitcoin;const{Point:F}=H;function W(e){return Buffer.from(e,"hex").toString().replace(/\0/g,"")}function G(e,t){return e.slice(t)+e.slice(0,t)}function J(e,t,n){if(e.length*Math.log2(t)>53)throw new Error(`Input too large ${e.length} ${Math.log2(t)}`);if(![2,10,16].includes(t)||![2,10,16].includes(n))throw new Error("ToBase or FromBase invalid in covertNumber.");if(2===t&&e.length%8!=0)throw new Error("Binary strings must be byte aligned.");if(16===t&&e.length%2!=0)throw new Error("Hex strings must be of even length.");const o=parseInt(e,t).toString(n);return 2===n?o.padStart(8*Math.ceil(o.length/8),"0"):16===n?o.padStart(2*Math.ceil(o.length/2),"0"):o}function Y(e,t){const n=new RegExp(`.{1,${t}}`,"g");return e.match(n)||[]}function z(e){return Y(e,2).map((e=>J(e,16,2))).join("")}function X(e){return Y(e,8).map((e=>J(e,2,16))).join("")}function Z(e){return e.toString(16).padStart(D.ENCODING_NUMBER_LENGTH,"0")}function Q(e){return parseInt(e,16)}function V(e){if(62!==e.length)throw new Error("Input to hexToPublicKey must be of length 62");let t=!1;let n=0;let o;for(;!t;){if(n>=256)throw new Error("Something went wrong storing data");const r=n.toString(16).padStart(2,"0")+X(G(z(e).padStart(64,"0"),n));try{o=F.fromX(!1,r),t=!0}catch(e){n+=1}}if(!o)throw new Error("Something went wrong storing data");return new L(o)}function ee(e){const t=e.point.getX().toString("hex").padStart(64,"0");const n=J(t.slice(0,2),16,10);return X((r=parseInt(n,10),(o=z(t.slice(2))).slice(-r)+o.slice(0,-r)));var o,r}function te(e){return new Promise((t=>{setTimeout(t,e)}))}function ne(e=C.CHAIN,t=C.NETWORK){if("testnet"===t||"regtest"===t)return 1;if("BTC"===e)return 0;if("LTC"===e)return 2;if("DOGE"===e)return 3;if("BCH"===e)return 145;if("BSV"===e)return 236;throw new Error(`Unsupported chain ${e}`)}function oe({purpose:e=44,coinType:t=2,account:n=0}={}){return`m/${e.toString()}'/${t.toString()}'/${n.toString()}'`}function re(e=C.CHAIN,t=C.NETWORK){return oe({coinType:ne(e,t)})}function ie(){return Math.round(Math.random()*Math.pow(2,31))}function ce({chain:e=C.CHAIN,network:t=C.NETWORK,account:n=ie()}={}){return oe({account:n,coinType:ne(e,t)})}const{PublicKey:se,Script:ae}=e.Bitcoin;function de(e){if(e.length>D.MAX_PUBKEYS_PER_SCRIPT)throw new Error("Too many owners");return function(e){const t=new ae;return t.add("OP_1"),e.forEach((e=>{t.add(e)})),t.add(`OP_${e.length}`),t.add("OP_CHECKMULTISIG"),t}(e.map((e=>e.toBuffer())))}function ue(e){return function(e){return e.chunks.filter((e=>e.buf)).map((e=>e.buf))}(e).map((e=>se.fromBuffer(e)))}function le(e){return Buffer.from(_.default.SHA256(e).toString(),"hex").toString("hex").substr(0,4)}function he(e){return`${le(e)};${e}`}function pe(e){const t=e.substr(0,4);const n=e.substr(5);if(!function(e,t){return le(e)===t}(n,t))throw new Error("Decryption failure");return n}function ve(e){if(void 0!==e._readers){const{_readers:t,_url:n,_owners:o,_amount:r}=e,i=k(e,["_readers","_url","_owners","_amount"]);const c=function(e,t){const n=v.default.randomBytes(32).toString("hex");const o=function(e,t){if(!/^[0-9a-f]{64}$/.test(t))throw new Error("Invalid secret");const n=Buffer.from(t,"hex").toString("binary");const o=he(e);return _.default.AES.encrypt(o,n).toString()}(e,n);const r=t.map((e=>function(e,t){if(!/^0[2-3][0-9a-f]{64}|04[0-9a-f]{128}$/.test(t))throw new Error("Invalid publicKey");const n=he(e);return y.encrypt(t,Buffer.from(n,"utf8")).toString("base64")}(n,e)));return{__cypher:o,__secrets:r}}(JSON.stringify(i),t);return void 0!==n&&(c._url=n),void 0!==o&&(c._owners=o),void 0!==r&&(c._amount=r),c}return e}const{Transaction:_e}=e.Bitcoin;const{Output:ye}=_e;const{UnspentOutput:ge}=_e;let fe=class{constructor(e,t,n){const o=new _e(n);o.feePerKb(D.FEE_PER_KB),this.nodeConfig=e,this.tx=o,this.outData=[],this.privateKey=t}get txId(){return this.tx.id}get chain(){return this.nodeConfig.chain}get network(){return this.nodeConfig.network}get restClient(){const{nodeConfig:e,privateKey:t}=this;return new M({nodeConfig:e,privateKey:t})}get inputs(){return this.tx.inputs.map((e=>`${e.prevTxId.toString("hex")}/${e.outputIndex}`))}get inRevs(){const{enc:e}=this;let[t]=e;return t=Number.isFinite(t)?t:0,this.tx.inputs.slice(0,t).map((({prevTxId:e,outputIndex:t})=>`${e.toString("hex")}/${t}`))}get outRevs(){const{enc:e}=this;let[,t]=e;return t=Number.isFinite(t)?t:0,Array.from(Array(t).keys()).map((e=>`${this.tx.id}/${e}`))}get opReturns(){try{const{outputs:e}=this.tx;return e.filter((({script:e})=>e.isDataOut())).map((({script:e})=>e.getData())).map((e=>e.toString())).join()}catch(e){return""}}get enc(){return Y(this.opReturns.slice(0,D.ENCODING_LENGTH*D.ENCODING_NUMBER_LENGTH),D.ENCODING_NUMBER_LENGTH).map(Q)}get dataPrefix(){return this.opReturns.slice(9)}isFullyFunded(){return this.tx._getInputAmount()-this.tx._getOutputAmount()>=this.tx.getFee()}getOwnerOutputs(){const{enc:e}=this;const[,t=0]=e;return this.tx.outputs.slice(0,t)}getDataOutputs(){const{enc:e}=this;const[,t,n]=e;return this.tx.outputs.slice(t,n)}getOutData(e){return x(this,void 0,void 0,(function*(){try{const t=this.getDataOutputs().map((e=>e.script)).map((e=>ue(e))).flat().map(ee).map(W).join("");const{dataPrefix:n}=this;const o=JSON.parse(n+t);const r=e.toBuffer().toString("hex");const i=this.getOwnerOutputs();if(i.length!==o.length)throw new Error("Inconsistent state");const c=i.map(((e,t)=>Object.assign(Object.assign({},o[t]),{_owners:ue(e.script).map((e=>e.toString())),_amount:e.satoshis})));return Promise.all(c.map((t=>x(this,void 0,void 0,(function*(){try{const n=yield function(e){return t=>x(this,void 0,void 0,(function*(){if(function(e){return void 0!==e._url}(t)){const{_url:n}=t,o=k(t,["_url"]);const{host:r,data:i}=yield M.getSecretOutput({_url:n,privateKey:e});return Object.assign(Object.assign(Object.assign({},o),JSON.parse(i)),{_url:r})}return t}))}(e)(t);return function(e,t){if(function(e){return void 0!==e.__cypher&&void 0!==e.__secrets}(e)){const{__cypher:n,__secrets:o}=e,r=k(e,["__cypher","__secrets"]);return Object.assign(Object.assign(Object.assign({},r),JSON.parse(function({__cypher:e,__secrets:t},n){let o="";if(n.forEach((n=>{t.forEach((t=>{try{const r=function(e,t){if(!/^[0-9a-f]{64}$/.test(t))throw new Error("Invalid privateKey");return pe(y.decrypt(t,Buffer.from(e,"base64")).toString("utf8"))}(t,n);o=function(e,t){if(!/^[0-9a-f]{64}$/.test(t))throw new Error("Invalid secret");const n=Buffer.from(t,"hex").toString("binary");return pe(_.default.AES.decrypt(e,n).toString(_.default.enc.Utf8))}(e,r)}catch(e){const t=["Decryption failure","Unsupported state or unable to authenticate data"];if(e instanceof Error&&!t.includes(e.message))throw e}}))})),o)return o;throw new Error("Decryption failure")}({__cypher:n,__secrets:o},t))),{_readers:[]})}return e}(n,[r])}catch(e){return null}})))))}catch(e){return[]}}))}getOwners(){return this.getOwnerOutputs().map((e=>ue(e.script).map((e=>e.toString()))))}getAmounts(){return this.getOwnerOutputs().map((e=>e.satoshis))}spendFromData(t){return x(this,void 0,void 0,(function*(){if(!t.length)return;const n=t.map(P);const o=n.map((e=>e.txId));const r=yield this.restClient.getTransactions(o);for(let t=0;t<n.length;t+=1){const{txId:o,outputIndex:i}=n[t];const{outputs:c}=r[t];const s=c[i];const a=Math.round(s.satoshis);const d=new e.Bitcoin.Script(s.script);const u=new ge({txId:o,outputIndex:i,satoshis:a,script:d});const l=ue(d).map((e=>e.toString()));this.tx.from([u],l,1)}}))}createDataOuts(t){t.forEach((({_amount:t,_owners:n=[]})=>{if(Array.isArray(n)&&n.length>D.MAX_PUBKEYS_PER_SCRIPT)throw new Error("Too many owners.");const o=n.map((t=>e.Bitcoin.PublicKey.fromString(t)));const r=t||D.MIN_NON_DUST_AMOUNT;const i=de(o);this.tx.addOutput(new ye({script:i,satoshis:r}))}));const n=t.map((e=>k(e,["_amount","_owners"])));const o=D.MIN_NON_DUST_AMOUNT;const r=JSON.stringify(n);const i=D.OP_RETURN_SIZE-D.ENCODING_LENGTH*D.ENCODING_NUMBER_LENGTH;const c=r.slice(0,i);const s=function(e){var t;return function(e,t){const n=[];for(let o=0;o<e.length;o+=t)n.push(e.slice(o,o+t));return n}(Y((t=e,Buffer.from(t).toString("hex")),62).map((e=>e.padStart(62,"0"))).map(V),D.MAX_PUBKEYS_PER_SCRIPT).map((e=>de(e)))}(r.slice(i));const a=Z(this.tx.inputs.length)+Z(this.tx.outputs.length)+Z(this.tx.outputs.length+s.length);s.forEach((e=>{this.tx.addOutput(new ye({script:e,satoshis:o}))})),this.tx.addData(a+c)}static fromTxHex(e,t,n){return x(this,void 0,void 0,(function*(){let o=[];let r=[];let i=[];const c=new this(t,n);c.tx.fromString(e);try{o=yield c.getOutData(n)}catch(e){}try{r=c.getOwners()}catch(e){}try{i=c.getAmounts()}catch(e){}return c.outData=o.map(((e,t)=>Object.assign(Object.assign({},e),{_owners:r[t],_amount:i[t]}))),c}))}static fromTxId(e,t,n){return x(this,void 0,void 0,(function*(){const o=new M({nodeConfig:t,privateKey:n});const[r]=yield o.getRawTxs([e]);return this.fromTxHex(r,t,n)}))}};fe=m([e=>e],fe);class be{constructor({mnemonic:t=new e.Bitcoin.Mnemonic,nodeConfig:n=new E,path:o=re(),passphrase:r=""}={}){this.passphrase=r,this.mnemonic=t,this.path=o,this.nodeConfig=n}get chain(){return this.nodeConfig.chain}get network(){return this.nodeConfig.network}get url(){return this.nodeConfig.url}get restClient(){const{nodeConfig:e,privateKey:t}=this;return new M({nodeConfig:e,privateKey:t})}get address(){return this._address=this._address||this.publicKey.toAddress(this.nodeConfig.network),this._address}derive(e="0"){const t=`${this.path}${this.path.length>0?"/":""}${e}`;const{mnemonic:n,nodeConfig:o,passphrase:r}=this;return new be({mnemonic:n,nodeConfig:o,path:t,passphrase:r})}get hdPrivateKey(){return this._hdPrivateKey=this._hdPrivateKey||this.mnemonic.toHDPrivateKey(this.passphrase,this.network).deriveChild(this.path),this._hdPrivateKey}get privateKey(){return this.hdPrivateKey.privateKey}get publicKey(){return this.hdPrivateKey.publicKey}getBalance(){return x(this,void 0,void 0,(function*(){return this.restClient.getBalance(this.address)}))}getUtxosByAmount(e){return x(this,void 0,void 0,(function*(){const t=yield this.restClient.getUtxosByAddress(this.address);let n=0;const o=[];!function(e){const t=e;for(let e=t.length-1;e>0;e-=1){const n=Math.floor(Math.random()*(e+1));[t[e],t[n]]=[t[n],t[e]]}}(t);for(const r of t)if(n+=r.satoshis,o.push(r),n>=e)return o;const{network:r,chain:i}=this.restClient.nodeConfig;const c=this.address.toString();throw new Error(`Insufficient balance in address ${c} on ${r} ${i}. Found ${n}, required ${e}.`)}))}fundAndSendTx(t){return x(this,void 0,void 0,(function*(){t.tx.feePerKb(2*D.FEE_PER_KB);const n=t.tx.outputs.length;t.tx.to(function(e,t){const n={"any-testnet":"uTKUDCkpo12vstJBsMWmrTPz9wFE6DuzGH","BTC-mainnet":"igpnnoLziUyxtQuWYCP13gHYVhUru6iLaY","LTC-mainnet":"t77o829ngHnuUorwDkf129fL6ERLFNqKG8","DOGE-mainnet":"XfNRUdvrv6uCDbCF5xJ18UYwVkkefkXvEd","BCH-mainnet":"CSAkkS8Mro9mYRqhksS1FyYrsnSE5MVQ5m"};return G("testnet"===t||"regtest"===t?n["any-testnet"]:n[`${e}-${t}`],19)}(this.nodeConfig.chain,this.nodeConfig.network),0);const o=yield this.restClient.getUtxosByAddress(this.address);if(t.tx.change(this.address),0===o.length){const{address:e}=this;throw new Error(`Insufficient balance in address ${e}.`)}let r=0;let i=0;let c=0;do{const[n]=o.splice(0,1);t.tx.from([new e.Bitcoin.Transaction.UnspentOutput(n)]),t.tx.sign(this.privateKey,D.SIGHASH_ALL),i=t.tx.toString().length,t.tx.fee(i*D.FEE_PER_KB*2),t.tx._updateChangeOutput(),c=t.tx._getInputAmount()-t.tx._getOutputAmount(),r=c/i*1e3}while(0!==o.length&&r<2*D.FEE_PER_KB);if(r<2*D.FEE_PER_KB&&0===o.length){const{address:e}=this;throw new Error(`Insufficient balance in address ${e}. Current fee_per_kb ${r}`)}if(i=t.tx.toString().length,c=Math.ceil(i/1e3*D.FEE_PER_KB),t.tx.fee(c),t.tx.outputs[n].satoshis=c,t.tx._outputAmount=void 0,t.tx.feePerKb(D.FEE_PER_KB),t.tx._outputAmount=void 0,t.tx._updateChangeOutput(),!1===t.isFullyFunded()||!1===t.tx.verify())throw new Error(`Something went wrong. Address ${this.address}. Transaction: ${JSON.stringify(t.tx,null,2)}`);return t.tx.sign(this.privateKey,D.SIGHASH_ALL),this.restClient.sendTransaction(t.tx.toString())}))}send(e,t){return x(this,void 0,void 0,(function*(){const{privateKey:n,nodeConfig:o}=this;const r=new fe(o,n);return r.tx.to(t,e),this.fundAndSendTx(r)}))}}class we{constructor({wallet:e=new be}={}){this.wallet=e}get chain(){return this.wallet.chain}get network(){return this.wallet.network}get nodeConfig(){return this.wallet.nodeConfig}fromTxHex(e){return x(this,void 0,void 0,(function*(){const{wallet:t,nodeConfig:n}=this;const{privateKey:o}=t;return fe.fromTxHex(e,n,o)}))}fromTxId(e){return x(this,void 0,void 0,(function*(){const{wallet:t,nodeConfig:n}=this;const{privateKey:o}=t;const r=new M({nodeConfig:n,privateKey:o});const[i]=yield r.getRawTxs([e]);return this.fromTxHex(i)}))}get(e){return x(this,void 0,void 0,(function*(){const t=e.map(P);return Promise.all(t.map((({txId:e,outputIndex:t})=>x(this,void 0,void 0,(function*(){const{outData:n}=yield this.fromTxId(e);if(t>n.length)throw new Error("Index out of bounds");return n[t]})))))}))}put(e){return this.update([],e)}createTx(e,t){return x(this,void 0,void 0,(function*(){const{wallet:n,nodeConfig:o}=this;const{privateKey:r}=n;const i=new fe(o,r);const c=t.map((e=>{var{_owners:t}=e,n=k(e,["_owners"]);return Object.assign({_owners:t||[this.wallet.publicKey.toString()]},n)})).map(ve);const s=yield Promise.all(c.map(function(e){return t=>x(this,void 0,void 0,(function*(){if(void 0!==t._url){const{_url:n,_owners:o,_amount:r}=t,i=k(t,["_url","_owners","_amount"]);const c=yield M.setSecretOutput({host:n,secretOutput:{data:JSON.stringify(i)},privateKey:e});return void 0!==o&&(c._owners=o),void 0!==r&&(c._amount=r),c}return t}))}(r)));return yield i.spendFromData(e),yield i.createDataOuts(s),i}))}update(e,t){return x(this,void 0,void 0,(function*(){const n=yield this.createTx(e,t);return yield this.wallet.fundAndSendTx(n),n.outRevs}))}}const ke=["_id","_rev","_owners","_amount","_readers","_url","__vouts","__func","__index","__args"];const me=e=>(Object.prototype.toString.call(e).match(/\s([a-zA-Z]+)/)||[])[1];const xe=e=>"object"==typeof e?me(e):me(e).toLowerCase();const Se=e=>["number","string","boolean","undefined","Null"].includes(xe(e));const Oe=e=>"Array"===xe(e);const Ne=e=>"Object"===xe(e);const je=e=>Se(e)||["Array","Object"].includes(xe(e));const qe=(e,t)=>{if(!je(e)||!je(t))throw new Error(`Unsupported data types for deep equals: ${xe(e)} & ${xe(t)}`);if(xe(e)!==xe(t))return!1;if(Se(e)&&Se(t))return e===t;const n=(e,t)=>Object.entries(e).every((([e,n])=>qe(t[e],n)));return e&&t&&n(e,t)&&n(t,e)};const Te=e=>{if(Se(e))return e;if(Oe(e))return e.map(Te);if(Ne(e)){const t=Object.keys(e).reduce(((t,n)=>(t[n]=Te(e[n]),t)),{});const n=Object.create(Object.getPrototypeOf(e));return Object.assign(n,t)}throw new Error(`Unsupported data type for clone: ${xe(e)}`)};const Ce=(e,t)=>Object.fromEntries(Object.entries(e).map((e=>t(e))));const Ee=(e,t)=>Ce(e,(([e,n])=>[e,t(n)]));const Re=(e,t)=>Object.fromEntries(Object.entries(e).filter((e=>t(e))));const Ae=(e,t,n,o)=>{if(Se(e))return e;if(Oe(e))return e.map((e=>Ae(e,t,n,o)));if(Ne(e)){e._rev=`${o}/${n}`;const r=t[n];return Object.entries(e).forEach((([n,i])=>{"object"==typeof r&&Object.keys(r).includes(n)&&(e[n]=Ae(i,t,r[n],o))})),e}throw new Error(`Unsupported type ${xe(e)} in deep.updateRev`)};const Ie=(e,t)=>{if(Se(e))return e;if(Oe(e))return e.map((e=>Ie(e,t)));if(Ne(e))return e._id=!e._id||e._id.startsWith("__temp__")?e._rev:e._id,e._root=e._root||t,Object.entries(e).forEach((([n,o])=>{e[n]=Ie(o,t)})),e;throw new Error(`Unsupported type ${xe(e)} in deep.addId`)};const Ue=e=>{if(Se(e))return e;if(Oe(e))return e.map((e=>Ue(e)));if(Ne(e)){const t=`__temp__/${Math.random()}`;return e._id=e._id||t,e._rev=e._rev||t,Object.values(e).map((e=>Ue(e))),e}throw new Error(`Unsupported type ${xe(e)} in addRandomId`)};const Be=e=>{if(Se(e))return e;if(Oe(e))return e.map((e=>Be(e)));if(Ne(e))return Ce(e,(([e,t])=>["_owners","_readers"].includes(e)?[e,JSON.stringify(t)]:Se(t)?[e,t]:[e,Be(t)]));throw new Error(`Unexpected type ${xe(e)} in stringifyOwners`)};const Pe=e=>(e._owners&&(e._owners=JSON.parse(e._owners)),e._readers&&(e._readers=JSON.parse(e._readers)),e);const Me=e=>{if(Se(e))return e;if(Oe(e)||Ne(e))return Object.entries(e).reduce(((e,[t,n])=>{const o=Me(n);return(e=>"Object"===xe(e)&&Object.keys(e).every((e=>!Number.isNaN(parseInt(e,10)))))(o)?Object.entries(o).forEach((([n,o])=>{e[`${t}_${n}`]=o})):e[t]=o,e}),{});throw new Error(`Unsupported type ${xe(e)} in encodeArraysAsObjects`)};const Ke=e=>{const t={[e._id]:Object.entries(e).reduce(((e,[t,n])=>ke.includes(t)?Object.assign(Object.assign({},e),{[t]:n}):Se(n)?Object.assign(Object.assign({},e),{[`__basic__${t}`]:n}):Object.assign(Object.assign({},e),{[t]:n._id})),{})};return Object.values(e).filter((e=>!Se(e))).reduce(((e,t)=>Object.assign(Object.assign({},e),Ke(t))),t)};const $e=e=>Re(e,(([e])=>!e.startsWith("__basic__")));const De=(e,t)=>{const n=e[t];return n.__contains=Object.entries(n).reduce(((t,[n,o])=>["__contains",...ke].includes(n)?t:"__change"===n?"new"===o||"diff"===o||t:De(e,o)[o].__contains||t),!1),e};const Le=(e,t)=>e.map((e=>Object.entries(e).reduce(((e,[n,o])=>{const r="string"==typeof o&&"undefined"!==xe(t[o])?t[o]:o;return Object.assign(Object.assign({},e),{[n]:r})}),{})));class He{constructor({db:e=new we}={}){this.db=e}get(e){return x(this,void 0,void 0,(function*(){const{txId:t,outputIndex:n}=P(e);const{inRevs:o,outData:r}=yield this.db.fromTxId(t);if(!Array.isArray(o)||!Array.isArray(r)||0===r.length)return;const i=r[0].__index||{};const c=r[i.obj].__cls||"";const s=r[i.obj].__func||"";const a=r[i.obj].__args||[];const d=yield Promise.all(Object.values(i).map((e=>{const t=o[e];return t?this.get(t):Promise.resolve({})})));const u=Object.keys(i).map(((e,t)=>[e,d[t]]));const l=Object.fromEntries(u);let h=l.obj;delete l.obj;const p=Object.entries(l).reduce(((e,[t,n])=>{const o=parseInt(t,10);return Number.isNaN(o)||(e[o]=n),e}),[]);const v=function(e,t){let n=0;return t.map((t=>"__"===t?e[n++]:t))}(p,a);let _;if("constructor"===s){const e=S(`(${c})`);h=N(e,v)}else _=O(h[s].bind(h),h,v);Object.entries(i).forEach((([e,n])=>{const o=parseInt(e,10);let i=p[o];"obj"===e?i=h:"res"===e&&(i=_),Ae(i,r,n,t)}));const y=h._root||`${t}/${i.obj}`;return Ie([_,h,...p],y),[...p,h,_][n]}))}}function Fe(e){return{smartArgs:e.filter((e=>e._rev)),dumbArgs:e.map((e=>e._rev?"__":e))}}class We{constructor({db:e=new we}={}){this.db=e,We.proxyDepth=We.proxyDepth||0}static getUpdate(e){return x(this,void 0,void 0,(function*(){let t;let n;let o;let r;let i;let c;let s;if("Cls"in e){const{Cls:a}=e;const d=e.args||[];t=a.toString(),n=null,o=N(a,d),r=Te(d),i=d,c=null,s=void 0}else{const{target:a,property:d,args:u}=e;t=null,n=Te(a),o=a,r=Te(u),i=u,c=d,this.proxyDepth+=1,s=O(a[d],a,i),this.proxyDepth-=1}const{smartArgs:a,dumbArgs:d}=Fe(r);const{smartArgs:u}=Fe(i);const l=Object.assign(Object.assign(Object.assign({},a),{obj:n}),{_id:"index"});const h=Object.assign(Object.assign(Object.assign({},u),{obj:o}),{_id:"index"});["Object","Array"].includes(xe(s))&&(h.res=s);const[p,v,_]=((e,t)=>{const n=Ue(t);const o=n._id;const r=Te(e);const i=Te(n);const c=Be(r);const s=Be(i);const a=Me(c);const d=Me(s);const u=((e,t)=>Ce(t,(([t,n])=>{const o=e[t];var r;return n.__change=(r=o)?qe(r,n)?"same":"diff":"new",[t,n]})))(Ke(a),Ke(d));const l=Ee(u,$e);const h=De(l,o);const p=h[o];delete h[o];const v=Ee(h,(e=>e._rev));const _=(y=e=>e.__contains||Object.values(p).includes(e._id),Re(h,(([,e])=>y(e))));var y;const g=Object.values(_);const[f,b]=(w=e=>"new"===e.__change,g.reduce((([e,t],n,o)=>w(n)?[[...e,n],t]:[e,[...t,n]]),[[],[]]));var w;const m=[...b,...f];const x=(e=>e.reduce(((e,t,n)=>Object.assign(Object.assign({},e),{[t._id]:n})),{}))(m);const S=Le(m,x);const[O]=Le([p],x);const N=b.map((e=>e._rev));const[j,...q]=((e,t)=>[t,...e].map((e=>{const t=k(e,["_id","_rev","__change","__contains"]);return Re(t,(([e,t])=>ke.includes(e)||"number"==typeof t))})))(S,O);return[N,q.map(Pe).map((e=>Object.entries(e).reduce(((e,[t,n])=>Object.assign(Object.assign({},e),{[t]:v[n]||n})),{}))),j]})(l,h);void 0!==v[0]&&(v[0].__index=_);const y=_.obj;void 0!==v[y]&&(null!==t&&(v[y].__cls=t),v[y].__func=null===c?"constructor":String(c),v[y].__args=d);const g=_.res;return void 0!==v[g]&&"function Object() { [native code] }"!==s.constructor.toString()&&(v[g].__cls=s.constructor.toString()),[p,v,o,u,s,_]}))}allocate(e,t){return x(this,void 0,void 0,(function*(){const[n,o,r,i,,c]=yield We.getUpdate({Cls:e,args:t});const[s]=yield this.db.update(n,o);const{txId:a}=P(s);Object.entries(c).forEach((([e,t])=>{const n=parseInt(e,10);let c=i[n];"obj"===e&&(c=r),Ae(c,o,t,a)}));const d=`${a}/${c.obj}`;return Ie([r,...i],d),r}))}update(e,t,n){return x(this,void 0,void 0,(function*(){const[o,r,,i,c,s]=yield We.getUpdate({target:e,property:t,args:n});const[a]=yield this.db.update(o,r);const{txId:d}=P(a);Object.entries(s).forEach((([t,n])=>{const o=parseInt(t,10);let s=i[o];"obj"===t?s=e:t.startsWith("res")&&(s=c),Ae(s,r,n,d)}));const u="string"==typeof e._root?e._root:`${d}/${s.obj}`;return Ie([c,e,...i],u),c}))}get(e,t){return We.proxyDepth>0||"function"!=typeof e[t]?Reflect.get(e,t):(...n)=>this.update(e,t,n)}}class Ge{constructor({mnemonic:t=new e.Bitcoin.Mnemonic,nodeConfig:n=new E,path:o=re(),passphrase:r=""}={}){this.passphrase=r,this.mnemonic=t,this.path=o,this.nodeConfig=n,this.hdPrivateKey=this.hdPrivateKey||this.mnemonic.toHDPrivateKey(this.passphrase,this.nodeConfig.network).deriveChild(this.path),this.restClient=new M({nodeConfig:this.nodeConfig,privateKey:this.hdPrivateKey.privateKey})}get(e,t){return x(this,void 0,void 0,(function*(){return this.restClient.callRPC(e,t)}))}}const{crypto:Je}=e.Bitcoin;class Ye{constructor({mnemonic:t="",seed:n="",path:o="",chain:r=C.CHAIN,network:i=C.NETWORK,url:c=C.BCN_URL,passphrase:s=D.PASSPHRASE}={}){const a=r.toUpperCase();const d=i.toLowerCase();if(!["LTC","BTC","DOGE","BCH"].includes(a))throw new Error("We currently only support LTC.");if(!["mainnet","testnet","regtest"].includes(d))throw new Error("Please set 'network' to 'regtest', 'testnet', or 'mainnet'");if(n&&t)throw new Error('Cannot set both "seed" and "mnemonic", please use "mnemonic"');const u=new E({chain:a,network:d,url:c});const l=new be({mnemonic:new e.Bitcoin.Mnemonic(n||t),path:o||re(a,d),nodeConfig:u,passphrase:s});this.rpc=new Ge({mnemonic:new e.Bitcoin.Mnemonic(n||t),path:o||re(a,d),nodeConfig:u,passphrase:s}),this.db=new we({wallet:l})}parseContract(e){const t=e.startsWith("export ")?e.slice(7):e;const n=t.startsWith("default ")?t.slice(8):t;return S(`(${n})`)}new(e,t){return x(this,void 0,void 0,(function*(){const n=e.toString();const o=yield this.parseContract(n);const r=new We({db:this.db});const i=yield r.allocate(o,t);return new Proxy(i,r)}))}sync(e){return x(this,void 0,void 0,(function*(){B(e);const{db:t}=this;const n=new He({db:t});const o=new We({db:t});const r=yield n.get(e);return new Proxy(r,o)}))}query({publicKey:t,contract:n}){return x(this,void 0,void 0,(function*(){let o={};if(t&&(o=Object.assign(Object.assign({},o),{publicKey:new e.Bitcoin.PublicKey(t).toString()})),n){const e="string"==typeof n?n:n.toString();o=Object.assign(Object.assign({},o),{classHash:Je.Hash.sha256(Buffer.from(e)).toString("hex")})}return this.db.wallet.restClient.query(o)}))}idsToRevs(e){return x(this,void 0,void 0,(function*(){return this.db.wallet.restClient.idsToRevs(e)}))}get chain(){return this.db.chain}get network(){return this.db.network}getMnemonic(){return this.db.wallet.mnemonic.toString()}getPublicKey(){return this.db.wallet.publicKey.toString()}getAddress(){return this.db.wallet.address.toString()}getBalance(){return x(this,void 0,void 0,(function*(){return this.db.wallet.getBalance()}))}getUtxos(){return x(this,void 0,void 0,(function*(){const t=new e.Bitcoin.Address(this.getAddress());return this.db.wallet.restClient.getUtxosByAddress(t)}))}broadcast(e){return x(this,void 0,void 0,(function*(){return this.db.wallet.restClient.sendTransaction(e)}))}queryRevs(e){return x(this,void 0,void 0,(function*(){return this.query(e)}))}getOwnedRevs(e=this.db.wallet.publicKey){return this.query({publicKey:e.toString()})}getRevs(e=this.db.wallet.publicKey){return x(this,void 0,void 0,(function*(){return this.query({publicKey:e.toString()})}))}getLatestRevs(e){return x(this,void 0,void 0,(function*(){return this.idsToRevs(e)}))}getLatestRev(e){return x(this,void 0,void 0,(function*(){const[t]=yield this.idsToRevs([e]);return t}))}rpcCall(e,t){return x(this,void 0,void 0,(function*(){const n=yield this.rpc.get(e,t);return n.result?n.result:{}}))}}var ze=g.default;var Xe=f.default;var Ze=b.default;function Qe(e){"string"==typeof e&&(e=function(e){var t=Ze.parse(e);var n=t.hostname;var o=parseInt(t.port,10);var r=t.protocol;r=r.substring(0,r.length-1);var i=t.auth.split(":");return{host:n,port:o,protocol:r,user:i[0]?decodeURIComponent(i[0]):null,pass:i[1]?decodeURIComponent(i[1]):null}}(e)),e=e||{},this.host=e.host||"127.0.0.1",this.port=e.port||8332,this.user=e.user||"user",this.pass=e.pass||"pass",this.protocol="http"===e.protocol?ze:Xe,this.batchedCalls=null,this.disableAgent=e.disableAgent||!1;var t=void 0!==e.rejectUnauthorized;this.rejectUnauthorized=!t||e.rejectUnauthorized,Qe.config.log?this.log=Qe.config.log:this.log=Qe.loggers[Qe.config.logger||"normal"]}var Ve=console.log.bind(console);var et=function(){};function tt(e,t){var n=this;e=JSON.stringify(e);var o=this.user+":"+this.pass;var r=Buffer.from&&Buffer.from!==Uint8Array.from?Buffer.from(o):new Buffer(o);this.auth=r.toString("base64");var i={host:n.host,path:"/",method:"POST",port:n.port,rejectUnauthorized:n.rejectUnauthorized,agent:!n.disableAgent&&void 0};if(n.httpOptions)for(var c in n.httpOptions)i[c]=n.httpOptions[c];var s=!1;var a="Bitcoin JSON-RPC: ";var d=this.protocol.request(i,(function(e){var o="";e.on("data",(function(e){o+=e})),e.on("end",(function(){if(!s)if(s=!0,401!==e.statusCode)if(403!==e.statusCode){if(500===e.statusCode&&"Work queue depth exceeded"===o.toString("utf8")){var r=new Error("Bitcoin JSON-RPC: "+o.toString("utf8"));return r.code=429,void t(r)}var i;try{i=JSON.parse(o)}catch(r){n.log.err(r.stack),n.log.err(o),n.log.err("HTTP Status code:"+e.statusCode);var c=new Error(a+"Error Parsing JSON: "+r.message);return void t(c)}t(i.error,i)}else t(new Error(a+"Connection Rejected: 403 Forbidden"));else t(new Error(a+"Connection Rejected: 401 Unnauthorized"))}))}));d.on("error",(function(e){var n=new Error(a+"Request Error: "+e.message);s||(s=!0,t(n))})),d.setHeader("Content-Length",e.length),d.setHeader("Content-Type","application/json"),d.setHeader("Authorization","Basic "+n.auth),d.write(e),d.end()}Qe.loggers={none:{info:et,warn:et,err:et,debug:et},normal:{info:Ve,warn:Ve,err:Ve,debug:et},debug:{info:Ve,warn:Ve,err:Ve,debug:Ve}},Qe.config={logger:"normal"},Qe.prototype.batch=function(e,t){this.batchedCalls=[],e(),tt.call(this,this.batchedCalls,t),this.batchedCalls=null},Qe.callspec={abandonTransaction:"str",abortRescan:"",addMultiSigAddress:"",addNode:"",analyzePSBT:"str",backupWallet:"",bumpFee:"str",clearBanned:"",combinePSBT:"obj",combineRawTransaction:"obj",convertToPSBT:"str",createMultiSig:"",createPSBT:"obj",createRawTransaction:"obj obj",createWallet:"str",decodePSBT:"str",decodeScript:"str",decodeRawTransaction:"",deriveAddresses:"str",disconnectNode:"",dumpPrivKey:"",dumpWallet:"str",encryptWallet:"",enumerateSigners:"",estimateFee:"",estimateSmartFee:"int str",estimatePriority:"int",generate:"int",generateBlock:"str obj",generateToAddress:"int str",generateToDescriptor:"int str",getAccount:"",getAccountAddress:"str",getAddedNodeInfo:"",getAddressMempool:"obj",getAddressUtxos:"obj",getAddressBalance:"obj",getAddressDeltas:"obj",getAddressesByLabel:"str",getAddressInfo:"str",getAddressTxids:"obj",getAddressesByAccount:"",getBalance:"str int",getBalances:"",getBestBlockHash:"",getBlockDeltas:"str",getBlock:"str int",getBlockchainInfo:"",getBlockCount:"",getBlockFilter:"str",getBlockHashes:"int int obj",getBlockHash:"int",getBlockHeader:"str",getBlockNumber:"",getBlockStats:"str",getBlockTemplate:"",getConnectionCount:"",getChainTips:"",getChainTxStats:"",getDescriptorInfo:"str",getDifficulty:"",getGenerate:"",getHashesPerSec:"",getIndexInfo:"",getInfo:"",getMemoryInfo:"",getMemoryPool:"",getMemPoolAncestors:"str",getMemPoolDescendants:"str",getMemPoolEntry:"str",getMemPoolInfo:"",getMiningInfo:"",getNetTotals:"",getNetworkHashPS:"",getNetworkInfo:"",getNewAddress:"str str",getNodeAddresses:"",getPeerInfo:"",getRawChangeAddress:"",getRawMemPool:"bool",getRawTransaction:"str int",getReceivedByAccount:"str int",getReceivedByAddress:"str int",getReceivedByLabel:"str",getRpcInfo:"",getSpentInfo:"obj",getTransaction:"",getTxOut:"str int bool",getTxOutProof:"",getTxOutSetInfo:"",getUnconfirmedBalance:"",getWalletInfo:"",getWork:"",getZmqNotifications:"",finalizePSBT:"str",fundRawTransaction:"str",help:"",importAddress:"str str bool",importDescriptors:"str",importMulti:"obj obj",importPrivKey:"str str bool",importPrunedFunds:"str, str",importPubKey:"str",importWallet:"str",invalidateBlock:"str",joinPSBTs:"obj",keyPoolRefill:"",listAccounts:"int",listAddressGroupings:"",listBanned:"",listDescriptors:"",listLabels:"",listLockUnspent:"bool",listReceivedByAccount:"int bool",listReceivedByAddress:"int bool",listReceivedByLabel:"",listSinceBlock:"str int",listTransactions:"str int int",listUnspent:"int int",listWalletDir:"",listWallets:"",loadWallet:"str",lockUnspent:"",logging:"",move:"str str float int str",ping:"",preciousBlock:"str",prioritiseTransaction:"str float int",pruneBlockChain:"int",psbtBumpFee:"str",removePrunedFunds:"str",reScanBlockChain:"",saveMemPool:"",send:"obj",setHDSeed:"",setLabel:"str str",setWalletFlag:"str",scanTxOutSet:"str",sendFrom:"str str float int str str",sendMany:"str obj int str",sendRawTransaction:"str",sendToAddress:"str float str str",setAccount:"",setBan:"str str",setNetworkActive:"bool",setGenerate:"bool int",setTxFee:"float",signMessage:"",signMessageWithPrivKey:"str str",signRawTransaction:"",signRawTransactionWithKey:"str obj",signRawTransactionWithWallet:"str",stop:"",submitBlock:"str",submitHeader:"str",testMemPoolAccept:"obj",unloadWallet:"",upgradeWallet:"",uptime:"",utxoUpdatePSBT:"str",validateAddress:"",verifyChain:"",verifyMessage:"",verifyTxOutProof:"str",walletCreateFundedPSBT:"",walletDisplayAddress:"str",walletLock:"",walletPassPhrase:"string int",walletPassphraseChange:"",walletProcessPSBT:"str"};var nt=function(e,t,n){return Array.prototype.slice.call(e,t,n)};function ot(){return parseInt(1e5*Math.random())}!function(e,t,n){function o(e,t){return function(){var o=arguments.length-1;this.batchedCalls&&(o=arguments.length);for(var r=0;r<o;r++)t[r]&&(arguments[r]=t[r](arguments[r]));this.batchedCalls?this.batchedCalls.push({jsonrpc:"2.0",method:e,params:nt(arguments),id:ot()}):n.call(this,{method:e,params:nt(arguments,0,arguments.length-1),id:ot()},arguments[arguments.length-1])}}var r={str:function(e){return e.toString()},int:function(e){return parseFloat(e)},float:function(e){return parseFloat(e)},bool:function(e){return!0===e||"1"==e||"true"==e||"true"==e.toString().toLowerCase()},obj:function(e){return"string"==typeof e?JSON.parse(e):e}};for(var i in t){var c=[];if(t[i].length){c=t[i].split(" ");for(var s=0;s<c.length;s++)r[c[s]]?c[s]=r[c[s]]:c[s]=r.str}var a=i.toLowerCase();e.prototype[i]=o(a,c),e.prototype[a]=e.prototype[i]}}(Qe,Qe.callspec,tt);var rt=Qe;const ct=new rt({protocol:process.env.RPC_PROTOCOL,user:process.env.RPC_USER,pass:process.env.RPC_PASSWORD,host:process.env.RPC_HOST,port:process.env.RPC_PORT});const st={createwallet:w.default.promisify(rt.prototype.createwallet.bind(ct)),getaddressinfo:w.default.promisify(rt.prototype.getaddressinfo.bind(ct)),getBlock:w.default.promisify(rt.prototype.getBlock.bind(ct)),getBlockchainInfo:w.default.promisify(rt.prototype.getBlockchainInfo.bind(ct)),getBlockHash:w.default.promisify(rt.prototype.getBlockHash.bind(ct)),generateToAddress:w.default.promisify(rt.prototype.generateToAddress.bind(ct)),getRawTransaction:w.default.promisify(rt.prototype.getRawTransaction.bind(ct)),importaddress:w.default.promisify(rt.prototype.importaddress.bind(ct)),listunspent:w.default.promisify(rt.prototype.listunspent.bind(ct)),sendRawTransaction:w.default.promisify(rt.prototype.sendRawTransaction.bind(ct))};const{PrivateKey:at,Opcode:dt,Script:ut,Mnemonic:lt,crypto:ht,Transaction:pt,encoding:vt}=e.Bitcoin;const{CHAIN:_t,NETWORK:yt,TEST_MNEMONICS:gt}=C;function ft(e=0){return gt.split(";")[e]}function bt(e=0){return new Ye(function(e=0){return{mnemonic:ft(),chain:_t,network:yt,path:ce({account:e})}}(e))}new E;const wt=({random:e=!1}={})=>x(void 0,void 0,void 0,(function*(){const t=e?ce():re();const n=function(e=0){return new lt(ft(e))}();const o=new be({mnemonic:n,path:t});return yield c.backOff((()=>x(void 0,void 0,void 0,(function*(){return(e=>x(void 0,void 0,void 0,(function*(){const{result:t}=yield st.generateToAddress(1,e.address);const{result:n}=yield st.getBlock(t[0],2);if(n.confirmations<=0)throw new Error(`No confirmations on block mining: ${n.confirmations}`)})))(o)})))),t}));function kt(e,n){const o=Object.keys(n);const r=Object.keys(e);if(o.length!==r.length)throw new Error("Actual keys do not match expected keys");o.forEach((o=>{const r=e[o];const i=n[o];if(void 0===i)throw new Error(`${o} is not defined in expected object`);if("value"===i.check)t.expect(e).to.have.property(o),t.expect(e[o]).to.deep.eq(i.value);else{if("type"!==i.check)throw new Error("Error configuring expectToEqual: set 'check' to 'type' or 'value'");if("string"===i.type)t.expect(e).to.have.property(o).that.is.a("string");else if("number"===i.type)t.expect(e).to.have.property(o).that.is.a("number");else if("array"===i.type){if(t.expect(e).to.have.property(o).that.is.a("array").that.have.lengthOf(i.length),void 0!==i.length&&i.length>0)for(let e=0;e<r.length;e+=1)t.expect(r[e]).to.be.an(i.subtype)}else{if("object"!==i.type)throw new Error("Error configuring expectToEqual: set 'type' to 'number', 'string', array', or 'object'.");t.expect(e).to.have.property(o).that.is.an("object")}}}))}const{CHAIN:mt="LTC",NETWORK:xt="regtest",RPC_USER:St,RPC_PASSWORD:Ot,RPC_HOST:Nt}=process.env;const jt="LTC"===process.env.CHAIN?19332:8332;var qt=Object.assign(Object.assign({},C),{CHAIN:mt,NETWORK:xt,BCN_URL:"http://127.0.0.1:3000",RPC_PROTOCOL:"http",RPC_USER:St,RPC_PASSWORD:Ot,RPC_HOST:Nt,RPC_PORT:jt,TEST_ADDRESSES:"mwADSUHvPCGrrX4ozP8Kcd5JCWK93rnc8h;moMoH1vTgCc2dkDfGSKYPnafxy22wSqgrr;mmQEk8VwtSehRryLF8jhVapYg553hJGhNa;miKQVhZbFKSsJcQZ8eXwBQ89xNyetpN34q;mzoGRNh55y9j57TPdwRGi3nt9X4CFwpqUS;n1X6JFDyxibtdhYrc7mrkuft6o168ELFNW;mjLcig6eTZVJkgRgJFMkwrYHpfMnZ1t4kk;mfYkMQAe7afeRSkgLxAtwnMVryjLTfr95Q"});const Tt=new E;const Ct=e=>e.split("/")[0];const Et=ft();const Rt=e=>{const[t,n]=e.split("/");const o=parseFloat(n);return[64,65].includes(t.length)&&!Number.isNaN(o)&&Number.isFinite(o)};let At=[];before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){At=yield function({n:e=1,random:t=!1}={}){return x(this,void 0,void 0,(function*(){const n=[];for(let o=0;o<e;o+=1)n.push(yield wt({random:t}));return yield x(void 0,void 0,void 0,(function*(){let e=!1;do{try{const{result:t}=yield st.generateToAddress(100,(new lt).toHDPrivateKey("",yt).derive(re(_t,yt)).privateKey.toPublicKey().toAddress());e=100===t.length}catch(e){te(500)}}while(!e)})),n}))}({n:48,random:!0})}))));let It=0;function Ut(){if(It+=1,At.length)return At.pop();throw Error(`No more paths ${It}`)}describe("Computer",(()=>{describe("New",(()=>{describe("Should create a smart object without argument",(()=>{class e{constructor(){this.n=1}}let n;let o;let r;let i;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){o=new Ye({mnemonic:Et,path:Ut()}),r=new Ye({mnemonic:Et,path:Ut()}),({db:i}=o),n=yield o.new(e)})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{n:{check:"value",type:"number",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(n._id).eq(n._rev),t.expect(n._id).eq(n._root),t.expect(Rt(n._id)),t.expect(Rt(n._rev)),t.expect(Rt(n._root))})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:i});t.expect(yield e.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const o=yield i.get([n._rev]);t.expect(o).to.be.an("array").that.have.lengthOf(1),kt(o[0],{__func:{check:"value",value:"constructor",type:"string"},__args:{check:"type",type:"array",length:0},__index:{check:"type",type:"object"},__cls:{check:"value",value:e.toString(),type:"string"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT,type:"number"}}),t.expect(o[0].__index).to.deep.eq({obj:0})})))),it("should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield o.getLatestRev(n._id)).eq(n._rev)})))),it("should work with idsToRevs",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield o.idsToRevs([n._id])).to.deep.eq([n._rev])})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(n._rev)).to.deep.eq(n)})))),it("Should be able to call the RPC methods",(()=>x(void 0,void 0,void 0,(function*(){yield o.rpcCall("getIndexInfo","")}))))})),describe("Should create a smart object with a dumb argument",(()=>{class e{constructor(e){this.n=e}}let n;const o=Math.random();let r;let i;let c;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Ye({mnemonic:Et,path:Ut()}),i=new Ye({mnemonic:Et,path:Ut()}),({db:c}=r),n=yield r.new(e,[o])})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{n:{check:"value",type:"number",value:o},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(n._id).eq(n._rev),t.expect(n._id).eq(n._root),t.expect(Rt(n._id)),t.expect(Rt(n._rev)),t.expect(Rt(n._root))})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:c});t.expect(yield e.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([n._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(1),kt(r[0],{__func:{check:"value",value:"constructor",type:"string"},__args:{check:"type",type:"array",length:1,subtype:"number"},__index:{check:"type",type:"object"},__cls:{check:"value",value:e.toString(),type:"string"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT,type:"number"}}),t.expect(r[0].__args).to.deep.eq([o]),t.expect(r[0].__index).to.deep.eq({obj:0})})))),it("should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should create a smart object with a smart argument",(()=>{class e{constructor(){this.n=1}}class n{constructor(e){this.a=e}}let o;let r;let i;let c;let s;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){i=new Ye({mnemonic:Et,path:Ut()}),c=new Ye({mnemonic:Et,path:Ut()}),({db:s}=i),o=yield i.new(e,[]),r=yield i.new(n,[o])})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){kt(o,{n:{check:"value",type:"number",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(r.a,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),t.expect(r.a).to.deep.eq(o)})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(Rt(o._id)),t.expect(Rt(o._rev)),t.expect(Rt(o._root)),t.expect(Rt(r._id)),t.expect(Rt(r._rev)),t.expect(Rt(r._root));const e=Ct(o._id);const n=Ct(r._id);t.expect(e).not.eq(n),t.expect(o._id).eq(`${e}/0`),t.expect(o._rev).eq(`${n}/0`),t.expect(r._id).eq(`${n}/1`),t.expect(r._rev).eq(`${n}/1`),t.expect(r.a._id).eq(o._id),t.expect(r.a._rev).eq(o._rev),t.expect(o._root).eq(o._id),t.expect(r._root).eq(r._id)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:s});t.expect(yield e.get(o._rev)).to.deep.eq(o),t.expect(yield e.get(r._rev)).to.deep.eq(r)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const i=yield s.get([o._id]);t.expect(i).to.be.an("array").that.have.lengthOf(1),kt(i[0],{__func:{check:"value",value:"constructor",type:"string"},__args:{check:"type",type:"array",length:0},__index:{check:"type",type:"object"},__cls:{check:"value",value:e.toString(),type:"string"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT,type:"number"}}),t.expect(i[0].__index).to.deep.eq({obj:0});const c=Ct(r._id);const a=yield s.get([`${c}/0`,`${c}/1`]);t.expect(a).to.be.an("array").that.have.lengthOf(2),kt(a[0],{__index:{check:"type",type:"object"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT,type:"number"}}),t.expect(a[0].__index).to.deep.eq({0:0,obj:1}),kt(a[1],{a:{check:"value",value:0},__func:{check:"value",value:"constructor"},__args:{check:"value",value:["__"]},__cls:{check:"value",value:n.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.getLatestRev(r._id)).eq(r._rev),t.expect(yield i.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with idsToRevs",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.idsToRevs([o._id])).to.deep.eq([o._rev]),t.expect(yield i.idsToRevs([r._id])).to.deep.eq([r._rev])})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield c.sync(o._rev)).to.deep.eq(o),t.expect(yield c.sync(r._rev)).to.deep.eq(r)}))))})),describe("Should create a smart object with a sub-object",(()=>{class e{constructor(){this.n={m:1}}}let n;let o;let r;let i;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){o=new Ye({mnemonic:Et,path:Ut()}),r=new Ye({mnemonic:Et,path:Ut()}),({db:i}=o),n=yield o.new(e,[])})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{n:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(n.n,{m:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(n._id).eq(n._rev),t.expect(n.n._id).eq(n.n._rev),t.expect(n._root).eq(n._id),t.expect(n.n._root).eq(n._id)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:i});const o=yield e.get(n._rev);t.expect(o).to.deep.eq(n),t.expect(n.n._id.startsWith("__temp__")).eq(!1),t.expect(n.n._rev.startsWith("__temp__")).eq(!1);const r=yield e.get(n.n._rev);t.expect(r).to.be.undefined})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const o=yield i.get([n._rev]);t.expect(o).to.be.an("array").that.have.lengthOf(1),kt(o[0],{n:{check:"value",value:1},__func:{check:"value",value:"constructor"},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield o.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should create a smart object with a smart sub-object",(()=>{class e{constructor(t){this.b=t?new e(!1):void 0}}let n;let o;let r;let i;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){o=new Ye({mnemonic:Et,path:Ut()}),r=new Ye({mnemonic:Et,path:Ut()}),({db:i}=o),n=yield o.new(e,[!0])})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{b:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(n.b,{b:{check:"value",value:void 0},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(n._id).eq(n._rev),t.expect(n.b._id).eq(n.b._rev),t.expect(n._root).eq(n._id),t.expect(n.b._root).eq(n._id)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:i});const o=yield e.get(n._rev);t.expect(o).to.deep.eq(n),t.expect(n.b._id.startsWith("__temp__")).eq(!1),t.expect(n.b._rev.startsWith("__temp__")).eq(!1);const r=yield e.get(n.b._rev);t.expect(r).to.be.undefined})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const o=yield i.get([n._rev]);t.expect(o).to.be.an("array").that.have.lengthOf(1),kt(o[0],{b:{check:"value",value:1},__func:{check:"value",value:"constructor"},__args:{check:"value",value:[!0]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield o.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should create a smart object with an owner defined",(()=>{class e{constructor(e,t){this.n=e,this._owners=[t]}}let n;const o=Math.random();let r;let i;let c;let s;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Ye({mnemonic:Et,path:Ut()}),i=new Ye({mnemonic:Et,path:Ut()}),({db:c}=r),s=r.db.wallet.publicKey.toString(),n=yield r.new(e,[o,s])})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{n:{check:"value",value:o},_owners:{check:"value",value:[s]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(n._id).eq(n._rev),t.expect(n._id).eq(n._root),t.expect(Rt(n._id)),t.expect(Rt(n._rev)),t.expect(Rt(n._root))})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:c});t.expect(yield e.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([n._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(1),kt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[o,s]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}})})))),it("should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should create an encrypted smart object",(()=>{class e{constructor(e,t){this.n=e,this._readers=[t]}}let n;const o=Math.random();let r;let i;let c;let s;let a;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Ye({mnemonic:Et,path:Ut()}),i=new Ye({mnemonic:"average metal token tube twice idle yellow mail imitate nuclear clerk cover",path:Ut()}),({db:c}=r),({db:s}=i),a=r.db.wallet.publicKey.toString(),n=yield r.new(e,[o,a])})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{n:{check:"value",value:o},_readers:{check:"value",value:[a]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(n._id).eq(n._rev),t.expect(n._id).eq(n._root),t.expect(Rt(n._id)),t.expect(Rt(n._rev)),t.expect(Rt(n._root))})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:c});t.expect(yield e.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with encoded data",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([n._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),kt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[o,a]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_readers:{check:"value",value:[]},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}})})))),it("Should be able to decode the output when db has access",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([n._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(1),kt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[o,a]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_readers:{check:"value",value:[]},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}})})))),it("Should be not able to decode the output when db does not has access",(()=>x(void 0,void 0,void 0,(function*(){try{yield s.get([n._rev])}catch(e){t.expect(e).to.be.instanceof(Error),t.expect(e).to.have.property("message","Decryption failure")}})))),it("should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(n._rev)).to.deep.eq(n);try{yield i.sync(n._rev),t.expect(!0).eq(!1)}catch(e){t.expect(e.message).eq("Cannot read properties of undefined (reading '__cls')")}}))))})),describe("Should create an off-chain object",(()=>{class e{constructor(e){this.n=e,this._url="http://127.0.0.1:3000"}}let n;const o=Math.random();let r;let i;let c;let s;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Ye({mnemonic:Et,path:Ut()}),i=new Ye({mnemonic:Et,path:Ut()}),({db:c}=r),({db:s}=i),n=yield r.new(e,[o])})))),it("Should create a smart object when computer.new is called",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{n:{check:"value",value:o},_url:{check:"value",value:"http://127.0.0.1:3000"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:c});t.expect(yield e.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with encoded data data",(()=>x(void 0,void 0,void 0,(function*(){const i=n._rev.split("/")[0];const c=yield fe.fromTxId(i,Tt,r.db.wallet.privateKey);const{outData:s}=c;t.expect(s).to.be.an("array").that.have.lengthOf(1),kt(s[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[o]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT},_url:{check:"type",type:"string"}})})))),it("Should be able to get the output from the server when db has access",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([n._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(1),kt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[o]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("Should give all users access to the server",(()=>x(void 0,void 0,void 0,(function*(){const r=yield s.get([n._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(1),kt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[o]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should work if the contract is a string",(()=>{let e=null;let n;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){n=new Ye({mnemonic:Et,path:Ut()}),e=yield n.new("class A {\n        constructor(n) {\n          this.n = n\n        }\n      }",[1])})))),it("should work",(()=>{t.expect(e).to.not.be.undefined,t.expect(typeof e).eq("object"),kt(e,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),t.expect(e._id).eq(e._rev)})),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){const n=bt();t.expect(yield n.sync(e._rev)).to.deep.eq(e)}))))})),describe("Should not create a smart object if no args as passed to the constructor",(()=>{class e{constructor(e,t){this.n=e,this._owners=[t]}}let n;it("Should throw an error",(()=>x(void 0,void 0,void 0,(function*(){try{const o=new Ye;n=n||(yield o.new(e,[])),t.expect(!0).eq(!1)}catch(e){t.expect(n).to.be.undefined,t.expect(e.message).to.not.be.undefined}}))))}))})),describe("Function calls",(()=>{describe("Should work for a function call with a dumb argument",(()=>{class e{constructor(e){this.n=e}inc(e){return this.n+=e,this.n}}let n;let o;let r;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){const t=new Ye({mnemonic:Et,path:Ut()});r=new Ye({mnemonic:Et,path:Ut()}),({db:o}=t),n=yield t.new(e,[1]),yield n.inc(1)})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{n:{check:"value",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(Rt(n._id)).eq(!0),t.expect(Rt(n._rev)).eq(!0),t.expect(Rt(n._root)).eq(!0),t.expect(n._id).not.eq(n._rev),t.expect(n._id).eq(n._root)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:o});t.expect(yield e.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const r=yield o.get([n._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),kt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}});const i=yield o.get([n._rev]);t.expect(i).to.be.an("array").that.have.lengthOf(1),kt(i[0],{__func:{check:"value",value:"inc"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){const e=new Ye;t.expect(yield e.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should work for a function call on an encrypted object",(()=>{class e{constructor(e,t){this.n=e,this._readers=[t]}inc(e){return this.n+=e,this.n}}let n;const o=Math.random();let r;let i;let c;let s;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Ye({mnemonic:Et,path:Ut()}),i=new Ye({mnemonic:"average metal token tube twice idle yellow mail imitate nuclear clerk cover",path:Ut()}),({db:c}=r),s=r.db.wallet.publicKey.toString(),n=yield r.new(e,[o,s]),yield n.inc(1)})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{n:{check:"type",type:"number"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"},_readers:{check:"value",value:[s]}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(Rt(n._id)).eq(!0),t.expect(Rt(n._rev)).eq(!0),t.expect(Rt(n._root)).eq(!0),t.expect(n._id).not.eq(n._rev),t.expect(n._id).eq(n._root)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:c});t.expect(yield e.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([n._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),kt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[o,s]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT},_readers:{check:"value",value:[]}});const i=yield c.get([n._rev]);t.expect(i).to.be.an("array").that.have.lengthOf(1),kt(i[0],{__func:{check:"value",value:"inc"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT},_readers:{check:"value",value:[]}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(n._rev)).to.deep.eq(n);try{yield i.sync(n._rev),t.expect(!0).eq(!1)}catch(e){t.expect(e.message).eq("Cannot read properties of undefined (reading '__cls')")}}))))})),describe("Should work for a function call on an off chain object",(()=>{class e{constructor(e){this.n=e,this._url="http://127.0.0.1:3000"}inc(e){return this.n+=e,this.n}}let n;const o=Math.random();let r;let i;let c;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Ye({mnemonic:Et,path:Ut()}),i=new Ye({mnemonic:Et,path:Ut()}),({db:c}=r),n=yield r.new(e,[o]),yield n.inc(1)})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{n:{check:"type",type:"number"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(Rt(n._id)).eq(!0),t.expect(Rt(n._rev)).eq(!0),t.expect(Rt(n._root)).eq(!0),t.expect(n._id).not.eq(n._rev),t.expect(n._id).eq(n._root)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:c});t.expect(yield e.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([n._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),kt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[o]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT},_url:{check:"value",value:"http://127.0.0.1:3000"}});const i=yield c.get([n._rev]);t.expect(i).to.be.an("array").that.have.lengthOf(1),kt(i[0],{__func:{check:"value",value:"inc"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should work for a function with a smart argument",(()=>{class e{constructor(){this.n=1}}class n{constructor(){this.m=2}objInc(e){return e.n+=1,this.m+=e.n,this.m}}let o;let r;let i;let c;let s;let a;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){c=new Ye({mnemonic:Et,path:Ut()}),s=new Ye({mnemonic:Et,path:Ut()}),a=c.db,o=yield c.new(e,[]),r=yield c.new(n,[]),i=yield r.objInc(o)})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){kt(o,{n:{check:"value",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(r,{m:{check:"value",value:4},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should return the correct value",(()=>{t.expect(i).eq(4)})),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(Rt(o._id)).eq(!0),t.expect(Rt(o._rev)).eq(!0),t.expect(Rt(o._root)).eq(!0),t.expect(Rt(r._id)).eq(!0),t.expect(Rt(r._rev)).eq(!0),t.expect(Rt(r._root)).eq(!0);const e=Ct(o._id);const n=Ct(r._id);const i=Ct(r._rev);t.expect(e).not.eq(n),t.expect(n).not.eq(i),t.expect(i).not.eq(e),t.expect(o._id).eq(`${e}/0`),t.expect(r._id).eq(`${n}/0`),t.expect(o._rev).eq(`${i}/0`),t.expect(r._rev).eq(`${i}/1`),t.expect(o._root).eq(o._id),t.expect(r._root).eq(r._id)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:a});t.expect(yield e.get(o._rev)).to.deep.eq(o),t.expect(yield e.get(r._rev)).to.deep.eq(r)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const i=yield a.get([o._id]);t.expect(i).to.be.an("array").that.have.lengthOf(1),kt(i[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[]},__cls:{check:"value",value:e.toString()},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}});const c=Ct(r._id);const s=yield a.get([`${c}/0`]);t.expect(s).to.be.an("array").that.have.lengthOf(1),kt(s[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[]},__cls:{check:"value",value:n.toString()},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}});const d=Ct(r._rev);const u=yield a.get([`${d}/0`,`${d}/1`]);t.expect(u).to.be.an("array").that.have.lengthOf(2),kt(u[0],{__index:{check:"value",value:{obj:1,0:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}}),kt(u[1],{__func:{check:"value",value:"objInc"},__args:{check:"value",value:["__"]},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield c.getLatestRev(o._id)).eq(o._rev),t.expect(yield c.getLatestRev(r._id)).eq(r._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield s.sync(o._rev)).to.deep.eq(o),t.expect(yield s.sync(r._rev)).to.deep.eq(r)}))))})),describe("Should work for a function that returns a dumb object",(()=>{class e{getJson(){return{n:1}}}let n;let o;let r;let i;let c;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Ye({mnemonic:Et,path:Ut()}),i=new Ye({mnemonic:Et,path:Ut()}),({db:c}=r),n=yield r.new(e,[]),o=o||(yield n.getJson(3))})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(o,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(Rt(n._id)).eq(!0),t.expect(Rt(n._rev)).eq(!0),t.expect(Rt(n._root)).eq(!0),t.expect(Rt(o._id)).eq(!0),t.expect(Rt(o._rev)).eq(!0),t.expect(Rt(o._root)).eq(!0);const e=Ct(n._id);const r=Ct(o._id);t.expect(e).not.eq(r),t.expect(n._id).eq(`${e}/0`),t.expect(o._id).eq(`${r}/1`),t.expect(n._rev).eq(`${r}/0`),t.expect(o._rev).eq(`${r}/1`),t.expect(n._root).eq(n._id),t.expect(o._root).eq(n._id)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:c});t.expect(yield e.get(n._rev)).to.deep.eq(n),t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([n._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),kt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}});const i=Ct(o._id);const s=yield c.get([`${i}/0`,`${i}/1`]);t.expect(s).to.be.an("array").that.have.lengthOf(2),kt(s[0],{__func:{check:"value",value:"getJson"},__args:{check:"value",value:[3]},__index:{check:"value",value:{obj:0,res:1}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}}),kt(s[1],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(n._id)).eq(n._rev),t.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(n._rev)).to.deep.eq(n),t.expect(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work for a function that returns a smart object",(()=>{class e{constructor(e){this.n=e}send(t){if(t>this.n)throw new Error;return this.n-=t,new e(t)}}let n;let o;let r;let i;let c;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Ye({mnemonic:Et,path:Ut()}),i=new Ye({mnemonic:Et,path:Ut()}),({db:c}=r),n=yield r.new(e,[10]),o=yield n.send(3)})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{n:{check:"value",value:7},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(o,{n:{check:"value",value:3},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(Rt(n._id)).eq(!0),t.expect(Rt(n._rev)).eq(!0),t.expect(Rt(n._root)).eq(!0),t.expect(Rt(o._id)).eq(!0),t.expect(Rt(o._rev)).eq(!0),t.expect(Rt(o._root)).eq(!0);const e=Ct(n._id);const r=Ct(o._id);t.expect(e).not.eq(r),t.expect(n._id).eq(`${e}/0`),t.expect(o._id).eq(`${r}/1`),t.expect(n._rev).eq(`${r}/0`),t.expect(o._rev).eq(`${r}/1`),t.expect(n._root).eq(n._id),t.expect(o._root).eq(n._id)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:c});t.expect(yield e.get(n._rev)).to.deep.eq(n),t.expect(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const r=yield c.get([n._id]);t.expect(r).to.be.an("array").that.have.lengthOf(1),kt(r[0],{__func:{check:"value",value:"constructor"},__args:{check:"value",value:[10]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}});const i=Ct(o._id);const s=yield c.get([`${i}/0`,`${i}/1`]);t.expect(s).to.be.an("array").that.have.lengthOf(2),kt(s[0],{__func:{check:"value",value:"send"},__args:{check:"value",value:[3]},__index:{check:"value",value:{obj:0,res:1}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}}),kt(s[1],{__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.getLatestRev(n._id)).eq(n._rev),t.expect(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.sync(n._rev)).to.deep.eq(n),t.expect(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work for a function that updates a nested object",(()=>{class e{constructor(){this.a={aa:1},this.b={bb:2}}update(){this.b.bb=3}}let n;let o;let r;let i;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){o=new Ye({mnemonic:Et,path:Ut()}),r=new Ye({mnemonic:Et,path:Ut()}),({db:i}=o),n=yield o.new(e,[]),yield n.update()})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{a:{check:"type",type:"object"},b:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(n.a,{aa:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(n.b,{bb:{check:"value",value:3},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){t.expect(Rt(n._id)).eq(!0),t.expect(Rt(n._rev)).eq(!0),t.expect(Rt(n._root)).eq(!0),t.expect(Rt(n.a._id)).eq(!0),t.expect(Rt(n.a._rev)).eq(!0),t.expect(Rt(n.a._root)).eq(!0),t.expect(Rt(n.b._id)).eq(!0),t.expect(Rt(n.b._rev)).eq(!0),t.expect(Rt(n.b._root)).eq(!0);const e=Ct(n._id);t.expect(n._id).eq(`${e}/0`),t.expect(n.a._id).eq(`${e}/1`),t.expect(n.b._id).eq(`${e}/2`),t.expect(n._root).eq(n._id),t.expect(n.a._root).eq(n._id),t.expect(n.b._root).eq(n._id)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:i});t.expect(yield e.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const o=yield i.get([n._id,n.a._id,n.b._id]);t.expect(o).to.be.an("array").that.have.lengthOf(3),kt(o[0],{a:{check:"value",value:1},b:{check:"value",value:2},__func:{check:"value",value:"constructor"},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}}),kt(o[1],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}}),kt(o[2],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}});const r=yield i.get([n._rev,n.a._rev,n.b._rev]);t.expect(r).to.be.an("array").that.have.lengthOf(3),kt(r[0],{b:{check:"value",value:1},__func:{check:"value",value:"update"},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}}),kt(r[1],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}}),kt(r[2],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:D.MIN_NON_DUST_AMOUNT}})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield o.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield r.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should work for a function that returns an array",(()=>{class e{constructor(){this.aa=1}createArray(){return this.a=new e,[new e,new e]}}let t;let n;let o;let r;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Ye({mnemonic:Et,path:Ut()}),t=yield r.new(e,[]),[n,o]=yield t.createArray()})))),it("Should return an array",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{aa:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(o,{aa:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns an object created by a property wrapped as object",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}o(){return{o:this.a.f()}}}let n;let o;let r;let i;let c;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){c=new Ye({mnemonic:Et,path:Ut()}),n=yield c.new(e,[]),r=yield c.new(t,[n]),o=yield r.g(),({o:i}=yield r.o())})))),it("Should return the object",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(i,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns an object created by a property wrapped in an array",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}o(){return[this.a.f()]}}let n;let o;let r;let i;let c;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){c=new Ye({mnemonic:Et,path:Ut()}),n=yield c.new(e,[]),r=yield c.new(t,[n]),o=yield r.g(),[i]=yield r.o()})))),it("Should return the object",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(i,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns multiple objects created by a property wrapped in an array",(()=>{class e{f(){return new e}}class n{constructor(e){this.a=e}g(){return this.a.f()}o(){return[this.a.f(),this.a.f()]}}let o;let r;let i;let c;let s;let a;let d;let u;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){a=new Ye({mnemonic:Et,path:Ut()}),d=new Ye({mnemonic:Et,path:Ut()}),({db:u}=a),o=yield a.new(e,[]),i=yield a.new(n,[o]),r=yield i.g(),[c,s]=yield i.o()})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){kt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(r,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(c,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(s,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(i,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(i.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){const e=[o,r,c,s,i];for(let n=0;n<e.length;n+=1){const o=e[n];t.expect(Rt(o._id)).eq(!0),t.expect(Rt(o._rev)).eq(!0),t.expect(Rt(o._root)).eq(!0)}t.expect(o._id).not.eq(o._rev),t.expect(i._id).not.eq(i._rev),t.expect(r._id).eq(r._rev)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:u});t.expect(yield e.get(o._rev)).to.deep.eq(o),t.expect(yield e.get(r._rev)).to.deep.eq(r),t.expect(yield e.get(i._rev)).to.deep.eq(i)})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield a.getLatestRev(o._id)).eq(o._rev),t.expect(yield a.getLatestRev(r._id)).eq(r._rev),t.expect(yield a.getLatestRev(i._id)).eq(i._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield d.sync(o._rev)).to.deep.eq(o),t.expect(yield d.sync(r._rev)).to.deep.eq(r),t.expect(yield d.sync(i._rev)).to.deep.eq(i)}))))})),describe("Should work for a function that returns multiple objects created by a property",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}o(){return this.a.f()}}let n;let o;let r;let i;let c;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){c=new Ye({mnemonic:Et,path:Ut()}),n=yield c.new(e,[]),r=yield c.new(t,[n]),o=yield r.g(),i=yield r.o()})))),it("Should return the object",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(i,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns an object created by a property",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}}let n;let o;let r;let i;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){i=new Ye({mnemonic:Et,path:Ut()}),n=yield i.new(e,[]),r=yield i.new(t,[n]),o=yield r.g()})))),it("Should return the object",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work when setting an owner",(()=>{class e{constructor(e){this._owners=[e]}updateOwner(e){this._owners=[e]}}let n;const o=new Ye({chain:qt.CHAIN,network:qt.NETWORK,path:""});const r=o.db.wallet.publicKey.toString();let i;let c;let s;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){i=new Ye({mnemonic:Et,path:Ut()}),s=i.db.wallet.publicKey.toString(),({db:c}=i),n=yield i.new(e,[s]),yield n.updateOwner(r)})))),it("Should update the smart object",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{_owners:{check:"value",value:[r]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>x(void 0,void 0,void 0,(function*(){const e=Ct(n._id);t.expect(n._id).eq(`${e}/0`)})))),it("Should return the object if reader.get is called",(()=>x(void 0,void 0,void 0,(function*(){const e=new He({db:c});t.expect(yield e.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with an output containing data",(()=>x(void 0,void 0,void 0,(function*(){const[o]=yield c.get([n._id]);t.expect(o).to.deep.eq({__func:"constructor",__args:[s],__index:{obj:0},__cls:e.toString(),_amount:D.MIN_NON_DUST_AMOUNT,_owners:[s]});const[i]=yield c.get([n._rev]);t.expect(i).to.deep.eq({__func:"updateOwner",__args:[r],__index:{obj:0},_owners:[r],_amount:D.MIN_NON_DUST_AMOUNT})})))),it("Should work with getLatestRev",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield i.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>x(void 0,void 0,void 0,(function*(){t.expect(yield o.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should work with multiple computers",(()=>{class e{constructor(){this.n=1}inc(){this.n+=1}}let t=null;let n=null;let o;let r;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){o=new Ye({mnemonic:Et,path:Ut()}),r=new Ye({mnemonic:Et,path:Ut()}),t=yield o.new(e,[]),n=yield r.new(e,[]),yield t.inc()})))),it("should work",(()=>{kt(t,{n:{check:"value",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),kt(n,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))}))})),describe("sync",(()=>{class e{constructor(e,t){this.n=e,this._owners=[t]}}let n;const o=Math.random();let r;let i;before("Before Computer",(()=>x(void 0,void 0,void 0,(function*(){r=new Ye({path:Ut(),mnemonic:Et}),i=r.db.wallet.publicKey.toString(),n=yield r.new(e,[o,i])})))),it("Should create another instance of the same smart object",(()=>x(void 0,void 0,void 0,(function*(){kt(n,{n:{check:"value",value:o},_owners:{check:"value",value:[i]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}});const e=bt();const r=yield e.sync(n._rev);t.expect(r).to.deep.eq(n)})))),it("throw an error if no params are passed to sync function",(()=>x(void 0,void 0,void 0,(function*(){const e=bt();try{yield e.sync(),t.expect(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t.expect(e.message).eq("Invalid outId: undefined")}})))),it("throw an error if rev is not in the right format: tdId:num",(()=>x(void 0,void 0,void 0,(function*(){const e=bt();try{yield e.sync("123"),t.expect(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t.expect(e.message).eq("Invalid outId: 123")}})))),it("throw an error if trId in rev is not 64 hex characters",(()=>x(void 0,void 0,void 0,(function*(){const e=bt();try{yield e.sync("123:0"),t.expect(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t.expect(e.message).eq("Invalid outId: 123:0")}})))),it("throw an error if trId in rev is contains non hex characters",(()=>x(void 0,void 0,void 0,(function*(){const e=bt();try{yield e.sync("31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844g:0"),t.expect(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t.expect(e.message).eq("Invalid outId: 31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844g:0")}})))),it("throw an error if num in rev is not a number",(()=>x(void 0,void 0,void 0,(function*(){const e=bt();try{yield e.sync("31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844f:abc"),t.expect(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t.expect(e.message).eq("Invalid outId: 31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844f:abc")}}))))})),describe("getBalance",(()=>{it("Should return the network",(()=>x(void 0,void 0,void 0,(function*(){const e=new Ye;t.expect(typeof(yield e.getBalance())).to.eq("number")}))))})),describe("Query",(()=>{class n{constructor(){this.n=1}}let o;let r;it("Should work with a string encoded public key",(()=>x(void 0,void 0,void 0,(function*(){r=new Ye({mnemonic:Et,path:Ut()}),o=yield r.new(n);const e=r.getPublicKey();const i=yield r.query({publicKey:e});t.expect(i.length).to.eq(1);const[c]=i;t.expect(typeof c).to.eq("string"),t.expect(c).to.eq(o._rev)})))),it("Should work with a public key",(()=>x(void 0,void 0,void 0,(function*(){r=new Ye({mnemonic:Et,path:Ut()}),o=yield r.new(n);const i=r.getPublicKey();const c=yield r.query({publicKey:new e.Bitcoin.PublicKey(i)});t.expect(c.length).to.eq(1);const[s]=c;t.expect(typeof s).to.eq("string"),t.expect(s).to.eq(o._rev)})))),it("Should work with a class",(()=>x(void 0,void 0,void 0,(function*(){r=new Ye({mnemonic:Et,path:Ut()}),o=yield r.new(n);const e=yield r.query({contract:n});t.expect(e.length).to.be.above(1);const[i]=e;t.expect(typeof i).to.eq("string"),t.expect(e.includes(o._rev)).to.be.true})))),it("Should work with a class string",(()=>x(void 0,void 0,void 0,(function*(){r=new Ye({mnemonic:Et,path:Ut()}),o=yield r.new(n);const e=yield r.query({contract:n.toString()});t.expect(e.length).to.be.above(1);const[i]=e;t.expect(typeof i).to.eq("string"),t.expect(e.includes(o._rev)).to.be.true})))),it("Should work with a class and a public key",(()=>x(void 0,void 0,void 0,(function*(){r=new Ye({mnemonic:Et,path:Ut()}),o=yield r.new(n);const e=r.getPublicKey();const i=yield r.query({contract:n,publicKey:e});t.expect(i.length).to.eq(1);const[c]=i;t.expect(typeof c).to.eq("string"),t.expect(c).to.eq(o._rev)}))))}))}));
