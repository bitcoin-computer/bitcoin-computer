import{Bitcoin as e}from"bitcoin-computer-bitcore";import{expect as t}from"chai";import o from"axios";import"child_process";import n from"crypto";import r from"crypto-js";import*as i from"eciesjs";import{StaticModuleRecord as s}from"@endo/static-module-record";import c from"util";import a,{fileURLToPath as d}from"url";import{readFile as u}from"fs/promises";import"ses";import{backOff as l}from"exponential-backoff";import h from"http";import v from"https";function p(e,t){var o={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(o[n]=e[n]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(n=Object.getOwnPropertySymbols(e);r<n.length;r++)t.indexOf(n[r])<0&&Object.prototype.propertyIsEnumerable.call(e,n[r])&&(o[n[r]]=e[n[r]])}return o}function y(e,t,o,n){return new(o||(o=Promise))((function(r,i){function s(e){try{a(n.next(e))}catch(e){i(e)}}function c(e){try{a(n.throw(e))}catch(e){i(e)}}function a(e){var t;e.done?r(e.value):(t=e.value,t instanceof o?t:new o((function(e){e(t)}))).then(s,c)}a((n=n.apply(e,t||[])).next())}))}const{CHAIN:g,NETWORK:_,BCN_URL:f,RPC_USER:b,RPC_PASSWORD:w,TEST_MNEMONICS:m}=process.env;const k=g||"LTC";const S=_||"testnet";const j=f||"https://node.bitcoincomputer.io";const q=m||"travel upgrade inside soda birth essence junk merit never twenty system opinion;toddler hockey salute wheel harvest video narrow riot guitar lake sea call;cannon hour begin test replace fury motion squirrel envelope announce neck culture";const x=parseInt(process.env.BC_DUST_LIMIT||"",10)||("LTC"===k?15460:1546);const{crypto:O}=e;const C=(e,t)=>{const o=Date.now();const n=O.Hash.sha256(Buffer.from(t+o));const r=[O.ECDSA.sign(n,e,"big").toString("hex"),e.publicKey.toString(),o];return`Bearer ${Buffer.from(r.join(":")).toString("base64")}`};class T{constructor(t=j,o=new e.PrivateKey,n={}){this.baseUrl=t,this.headers=n,this.privateKey=o}get(e){return y(this,void 0,void 0,(function*(){const t=this.privateKey?{Authentication:C(this.privateKey,this.baseUrl)}:{};return(yield o.get(`${this.baseUrl}${e}`,{headers:Object.assign(Object.assign({},this.headers),t)})).data}))}post(e,t){return y(this,void 0,void 0,(function*(){const n=this.privateKey?{Authentication:C(this.privateKey,this.baseUrl)}:{};return(yield o.post(`${this.baseUrl}${e}`,t,{headers:Object.assign(Object.assign({},this.headers),n)})).data}))}delete(e){return y(this,void 0,void 0,(function*(){const t=this.privateKey?{Authentication:C(this.privateKey,this.baseUrl)}:{};return(yield o.delete(`${this.baseUrl}${e}`,{headers:Object.assign(Object.assign({},this.headers),t)})).data}))}}parseInt(process.env.BC_DEFAULT_FEE||"",10),parseInt(process.env.BC_SCRIPT_CHUNK_SIZE||"",10),parseInt(process.env.MWEB_HEIGHT||"",10);const{PublicKey:R,Mnemonic:B,crypto:$}=e;const{Point:A}=$;function E(e){return Buffer.from(e,"hex").toString().replace(/\0/g,"")}function I(e,t){return e.slice(t)+e.slice(0,t)}function P(e,t,o){if(e.length*Math.log2(t)>53)throw new Error(`Input too large ${e.length} ${Math.log2(t)}`);if(![2,10,16].includes(t)||![2,10,16].includes(o))throw new Error("ToBase or FromBase invalid in covertNumber.");if(2===t&&e.length%8!=0)throw new Error("Binary strings must be byte aligned.");if(16===t&&e.length%2!=0)throw new Error("Hex strings must be of even length.");const n=parseInt(e,t).toString(o);return 2===o?n.padStart(8*Math.ceil(n.length/8),"0"):16===o?n.padStart(2*Math.ceil(n.length/2),"0"):n}function K(e,t){const o=new RegExp(`.{1,${t}}`,"g");return e.match(o)||[]}function L(e){return K(e,2).map((e=>P(e,16,2))).join("")}function U(e){return K(e,8).map((e=>P(e,2,16))).join("")}function N(e){return e.toString(16).padStart(3,"0")}function M(e){return parseInt(e,16)}function H(e){if(62!==e.length)throw new Error("Input to hexToPublicKey must be of length 62");let t=!1;let o=0;let n;for(;!t;){if(o>=256)throw new Error("Something went wrong storing data");const r=o.toString(16).padStart(2,"0")+U(I(L(e).padStart(64,"0"),o));try{n=A.fromX(!1,r),t=!0}catch(e){o+=1}}if(!n)throw new Error("Something went wrong storing data");return new R(n)}function D(e){const t=e.point.getX().toString("hex").padStart(64,"0");const o=P(t.slice(0,2),16,10);return U((r=parseInt(o,10),(n=L(t.slice(2))).slice(-r)+n.slice(0,-r)));var n,r}function F(e){return new Promise((t=>{setTimeout(t,e)}))}function W(e=k,t=S){if("testnet"===t||"regtest"===t)return 1;if("BTC"===e)return 0;if("LTC"===e)return 2;if("DOGE"===e)return 3;if("BCH"===e)return 145;if("BSV"===e)return 236;throw new Error(`Unsupported chain ${e}`)}function z({purpose:e=44,coinType:t=2,account:o=0}={}){return`m/${e.toString()}'/${t.toString()}'/${o.toString()}'`}function J({chain:e=k,network:t=S}={}){return z({coinType:W(e,t)})}function G(){return Math.round(Math.random()*Math.pow(2,31))}function Y({chain:e=k,network:t=S,account:o=G()}={}){return z({account:o,coinType:W(e,t)})}function Z(e,t){const o=function(e,t){return((e,t,o={})=>{const{path:n="m/44'/0'/0'/0",passphrase:r=""}=o;let i=e.toHDPrivateKey(r,t);return n&&(i=i.derive(n)),i.privateKey})(new B("replace this seed"),t,{path:J({chain:e,network:t}),passphrase:""})}(e,t);return R.fromPrivateKey(o)}function Q({mnemonic:e=new B,path:t=J(),passphrase:o="",network:n=S}){return e.toHDPrivateKey(o,n).deriveChild(t)}function V(e){return{smartArgs:e.filter((e=>e._rev)),dumbArgs:e.map((e=>e._rev?"__":e))}}function X(e){return/^[0-9A-Fa-f]{64}\/\d+$/.test(e)}function ee(e){if(!/^[0-9A-Fa-f]{64}$/.test(e))throw new Error(`Invalid txId: ${e}`)}function te(e){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(e))throw new Error(`Invalid outId: ${e}`)}function oe(e){te(e);const[t,o]=e.split("/");return{txId:t,outputIndex:parseInt(o,10)}}const ne=e=>e.startsWith("./")||e.startsWith("../")||"."===e||".."===e;const{Transaction:re,Mnemonic:ie}=e;const{UnspentOutput:se}=re;class ce{constructor({chain:e,network:t,mnemonic:o,path:n,passphrase:r,url:i}={}){if(this.chain=e?e.toUpperCase():k,this.network=t?t.toLowerCase():S,this.mnemonic=new ie(o?o.toString():void 0),this.path=n||J({chain:this.chain,network:this.network}),this.passphrase=r||"",this.bcn=new T(i,this.privateKey),!["LTC","BTC"].includes(this.chain))throw new Error("We currently only support LTC, support for other currencies will be added soon.");if(!["mainnet","testnet","regtest"].includes(this.network))throw new Error("Please set 'network' to 'regtest', 'testnet', or 'mainnet'")}get privateKey(){return Q(this).privateKey}getBalance(e){return y(this,void 0,void 0,(function*(){const{chain:t,network:o}=this;return yield this.bcn.get(`/v1/${t}/${o}/address/${e}/balance`)}))}getTransactions(e){return y(this,void 0,void 0,(function*(){return(yield this.getRawTxs(e)).map((e=>new re(e)))}))}getRawTxs(e){return y(this,void 0,void 0,(function*(){e.map(ee);const{chain:t,network:o}=this;return this.bcn.post(`/v1/${t}/${o}/tx/bulk/`,{txIds:e})}))}sendTransaction(e){return y(this,void 0,void 0,(function*(){return this.bcn.post(`/v1/${this.chain}/${this.network}/tx/send`,{rawTx:e})}))}getUtxosByAddress(e){return y(this,void 0,void 0,(function*(){const{chain:t,network:o}=this;return(yield this.bcn.get(`/v1/${t}/${o}/wallet/${e.toString()}/utxos`)).map((({rev:e,scriptPubKey:t,satoshis:o})=>{const[n,r]=e.split("/");return new se({txId:n,outputIndex:parseInt(r,10),satoshis:o,script:t})}))}))}query({publicKey:e,classHash:t}){return y(this,void 0,void 0,(function*(){if(void 0===e&&void 0===t)throw new Error("Query parameters cannot be empty.");let o="";e&&(o+=`?publicKey=${e}`),t&&(o+=0===o.length?"?":"&",o+=`classHash=${t}`);const{chain:n,network:r}=this;return this.bcn.get(`/v1/${n}/${r}/non-standard-utxos${o}`)}))}idsToRevs(e){return y(this,void 0,void 0,(function*(){e.map(te);const{chain:t,network:o}=this;return this.bcn.post(`/v1/${t}/${o}/revs`,{ids:e})}))}rpc(e,t){return y(this,void 0,void 0,(function*(){return this.bcn.post(`/v1/${this.chain}/${this.network}/rpc`,{method:e,params:t})}))}static getSecretOutput({_url:e,privateKey:t}){return y(this,void 0,void 0,(function*(){const o=e.split("/");const n=o[o.length-1];const r=o.slice(0,-2).join("/");const i=new T(r,t);return{host:r,data:yield i.get(`/v1/store/${n}`)}}))}static setSecretOutput({secretOutput:e,host:t,privateKey:o}){return y(this,void 0,void 0,(function*(){return new T(t,o).post("/v1/store/",e)}))}static deleteSecretOutput({_url:e,privateKey:t}){return y(this,void 0,void 0,(function*(){const o=e.split("/");const n=o[o.length-1];const r=o.slice(0,-2).join("/");const i=new T(r,t);yield i.delete(`/v1/store/${n}`)}))}get url(){return this.bcn.baseUrl}}const{PublicKey:ae,Script:de}=e;function ue(e,t,o,n){if(e.length>3)throw new Error("Too many owners");return function(e,t,o,n){const r=n?[...e,Z(t,o).toBuffer()]:e;const i=new de;return i.add("OP_1"),r.forEach((e=>{i.add(e)})),i.add(`OP_${r.length}`),i.add("OP_CHECKMULTISIG"),i}(e.map((e=>e.toBuffer())),t,o,n)}function le(e,t){return function(e,t){const o=e.chunks.filter((e=>e.buf));return(t?o.slice(0,-1):o).map((e=>e.buf))}(e,t).map((e=>ae.fromBuffer(e)))}function he(e){return Buffer.from(r.SHA256(e).toString(),"hex").toString("hex").substr(0,4)}function ve(e){return`${he(e)};${e}`}function pe(e){const t=e.substr(0,4);const o=e.substr(5);if(!function(e,t){return he(e)===t}(o,t))throw new Error("Decryption failure");return o}function ye(e){if(void 0!==e._readers){const{_readers:t,_url:o,_owners:s,_amount:c}=e,a=p(e,["_readers","_url","_owners","_amount"]);const d=function(e,t){const o=n.randomBytes(32).toString("hex");const s=function(e,t){if(!/^[0-9a-f]{64}$/.test(t))throw new Error("Invalid secret");const o=Buffer.from(t,"hex").toString("binary");const n=ve(e);return r.AES.encrypt(n,o).toString()}(e,o);const c=t.map((e=>function(e,t){if(!/^0[2-3][0-9a-f]{64}|04[0-9a-f]{128}$/.test(t))throw new Error("Invalid publicKey");const o=ve(e);return i.encrypt(t,Buffer.from(o,"utf8")).toString("base64")}(o,e)));return{__cypher:s,__secrets:c}}(JSON.stringify(a),t);return void 0!==o&&(d._url=o),void 0!==s&&(d._owners=s),void 0!==c&&(d._amount=c),d}return e}const{Transaction:ge}=e;const{Output:_e,UnspentOutput:fe}=ge;class be{constructor({restClient:e=new ce}={}){this.tx=new ge,this.tx.feePerKb(2e4),this.outData=[],this.restClient=e}get txId(){return this.tx.id}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get inputs(){return this.tx.inputs.map((e=>`${e.prevTxId.toString("hex")}/${e.outputIndex}`))}get inRevs(){const{enc:e}=this;let[t]=e;return t=Number.isFinite(t)?t:0,this.tx.inputs.slice(0,t).map((({prevTxId:e,outputIndex:t})=>`${e.toString("hex")}/${t}`))}get outRevs(){const{enc:e}=this;let[,t]=e;return t=Number.isFinite(t)?t:0,Array.from(Array(t).keys()).map((e=>`${this.tx.id}/${e}`))}get opReturns(){try{const{outputs:e}=this.tx;return e.filter((({script:e})=>e.isDataOut())).map((({script:e})=>e.getData())).map((e=>e.toString())).join()}catch(e){return""}}get enc(){return K(this.opReturns.slice(0,9),3).map(M)}get dataPrefix(){return this.opReturns.slice(9)}isFullyFunded(){return this.tx._getInputAmount()-this.tx._getOutputAmount()>=this.tx.getFee()}getOwnerOutputs(){const{enc:e}=this;const[,t=0]=e;return this.tx.outputs.slice(0,t)}getDataOutputs(){const{enc:e}=this;const[,t,o]=e;return this.tx.outputs.slice(t,o)}getOutData(){return y(this,void 0,void 0,(function*(){try{const e=this.getDataOutputs().map((e=>e.script)).map((e=>le(e,!0))).flat().map(D).map(E).join("");const{dataPrefix:t}=this;const o=JSON.parse(t+e);const n=this.restClient.privateKey.toBuffer().toString("hex");const s=this.getOwnerOutputs();if(s.length!==o.length)throw new Error("Inconsistent state");const c=s.map(((e,t)=>Object.assign(Object.assign({},o[t]),{_owners:le(e.script,!1).map((e=>e.toString())),_amount:e.satoshis})));return Promise.all(c.map((e=>y(this,void 0,void 0,(function*(){try{const t=yield function(e){return t=>y(this,void 0,void 0,(function*(){if(function(e){return void 0!==e._url}(t)){const{_url:o}=t,n=p(t,["_url"]);const{host:r,data:i}=yield ce.getSecretOutput({_url:o,privateKey:e});return Object.assign(Object.assign(Object.assign({},n),JSON.parse(i)),{_url:r})}return t}))}(this.restClient.privateKey)(e);return function(e,t){if(function(e){return void 0!==e.__cypher&&void 0!==e.__secrets}(e)){const{__cypher:o,__secrets:n}=e,s=p(e,["__cypher","__secrets"]);return Object.assign(Object.assign(Object.assign({},s),JSON.parse(function({__cypher:e,__secrets:t},o){let n="";if(o.forEach((o=>{t.forEach((t=>{try{const s=function(e,t){if(!/^[0-9a-f]{64}$/.test(t))throw new Error("Invalid privateKey");return pe(i.decrypt(t,Buffer.from(e,"base64")).toString("utf8"))}(t,o);n=function(e,t){if(!/^[0-9a-f]{64}$/.test(t))throw new Error("Invalid secret");const o=Buffer.from(t,"hex").toString("binary");return pe(r.AES.decrypt(e,o).toString(r.enc.Utf8))}(e,s)}catch(e){const t=["Decryption failure","Unsupported state or unable to authenticate data"];if(e instanceof Error&&!t.includes(e.message))throw e}}))})),n)return n;throw new Error("Decryption failure")}({__cypher:o,__secrets:n},t))),{_readers:[]})}return e}(t,[n])}catch(e){return null}})))))}catch(e){return[]}}))}getOwners(){return this.getOwnerOutputs().map((e=>le(e.script,!1).map((e=>e.toString()))))}getAmounts(){return this.getOwnerOutputs().map((e=>e.satoshis))}spendFromData(t){return y(this,void 0,void 0,(function*(){if(!t.length)return;const o=t.map(oe);const n=o.map((e=>e.txId));const r=yield this.restClient.getTransactions(n);for(let t=0;t<o.length;t+=1){const{txId:n,outputIndex:i}=o[t];const{outputs:s}=r[t];const c=s[i];const a=Math.round(c.satoshis);const d=new e.Script(c.script);const u=new fe({txId:n,outputIndex:i,satoshis:a,script:d});const l=le(d,!1).map((e=>e.toString()));this.tx.from([u],l,1)}}))}createDataOuts(t){t.forEach((({_amount:t,_owners:o=[]})=>{if(Array.isArray(o)&&o.length>3)throw new Error("Too many owners.");const n=o.map((t=>e.PublicKey.fromString(t)));const r=t||x;const i=ue(n,this.chain,this.network,!1);this.tx.addOutput(new _e({script:i,satoshis:r}))}));const o=t.map((e=>p(e,["_amount","_owners"])));const n=x;const r=JSON.stringify(o);const i=r.slice(0,71);const s=function(e,t,o,n){var r;return function(e,t){const o=[];for(let t=0;t<e.length;t+=2)o.push(e.slice(t,t+2));return o}(K((r=e,Buffer.from(r).toString("hex")),62).map((e=>e.padStart(62,"0"))).map(H)).map((e=>ue(e,t,o,!0)))}(r.slice(71),this.chain,this.network);const c=N(this.tx.inputs.length)+N(this.tx.outputs.length)+N(this.tx.outputs.length+s.length);s.forEach((e=>{this.tx.addOutput(new _e({script:e,satoshis:n}))})),this.tx.addData(c+i)}static fromTxHex({hex:e="",restClient:t=new ce}){return y(this,void 0,void 0,(function*(){let o=[];let n=[];let r=[];const i=new this({restClient:t});i.tx.fromString(e);try{o=yield i.getOutData()}catch(e){}try{n=i.getOwners()}catch(e){}try{r=i.getAmounts()}catch(e){}return i.outData=o.map(((e,t)=>Object.assign(Object.assign({},e),{_owners:n[t],_amount:r[t]}))),i}))}static fromTxId({txId:e="",restClient:t=new ce}){return y(this,void 0,void 0,(function*(){const[o]=yield t.getRawTxs([e]);return this.fromTxHex({hex:o,restClient:t})}))}}class we{constructor(e={}){this.restClient=new ce(e)}derive(e="0"){const t=`${this.path}${this.path.length>0?"/":""}${e}`;const{chain:o,network:n,url:r,mnemonic:i,passphrase:s}=this.restClient;return new we({chain:o,network:n,url:r,mnemonic:i.toString(),path:t,passphrase:s})}getBalance(){return y(this,void 0,void 0,(function*(){return this.restClient.getBalance(this.address)}))}getUtxosByAmount(e){return y(this,void 0,void 0,(function*(){const t=yield this.restClient.getUtxosByAddress(this.address);let o=0;const n=[];!function(e){const t=e;for(let e=t.length-1;e>0;e-=1){const o=Math.floor(Math.random()*(e+1));[t[e],t[o]]=[t[o],t[e]]}}(t);for(const r of t)if(o+=r.satoshis,n.push(r),o>=e)return n;const{network:r,chain:i}=this.restClient;const s=this.address.toString();throw new Error(`Insufficient balance in address ${s} on ${r} ${i}. Found ${o}, required ${e}.`)}))}fundAndSendTx(t){return y(this,void 0,void 0,(function*(){t.tx.feePerKb(4e4);const o=t.tx.outputs.length;const{chain:n,network:r}=this.restClient;t.tx.to(function(e,t){const o={"any-testnet":"uTKUDCkpo12vstJBsMWmrTPz9wFE6DuzGH","BTC-mainnet":"igpnnoLziUyxtQuWYCP13gHYVhUru6iLaY","LTC-mainnet":"t77o829ngHnuUorwDkf129fL6ERLFNqKG8","DOGE-mainnet":"XfNRUdvrv6uCDbCF5xJ18UYwVkkefkXvEd","BCH-mainnet":"CSAkkS8Mro9mYRqhksS1FyYrsnSE5MVQ5m"};return I("testnet"===t||"regtest"===t?o["any-testnet"]:o[`${e}-${t}`],19)}(n,r),0);const i=yield this.restClient.getUtxosByAddress(this.address);if(t.tx.change(this.address),0===i.length)throw new Error(`Insufficient balance in address ${this.address}.`);let s=0;let c=0;let a=0;do{const[o]=i.splice(0,1);t.tx.from([new e.Transaction.UnspentOutput(o)]),t.tx.sign(this.privateKey,1),c=t.tx.toString().length,t.tx.fee(2e4*c*2),t.tx._updateChangeOutput(),a=t.tx._getInputAmount()-t.tx._getOutputAmount(),s=a/c*1e3}while(0!==i.length&&s<4e4);if(s<4e4&&0===i.length)throw new Error(`Insufficient balance in address ${this.address}. Current fee_per_kb ${s}. Fee ${a}. Utxo set size ${i.length}. CTransaction size ${c} Inputs ${JSON.stringify(t.tx.inputs,null,2)} Outpus ${JSON.stringify(t.tx.outputs,null,2)}`);if(c=t.tx.toString().length,a=Math.max(Math.ceil(c/1e3*2e4),x),t.tx.fee(a),t.tx.outputs[o].satoshis=a,t.tx._outputAmount=void 0,t.tx.feePerKb(2e4),t.tx._outputAmount=void 0,t.tx._updateChangeOutput(),!1===t.isFullyFunded()||!1===t.tx.verify())throw new Error(`Something went wrong. Address ${this.address}. Transaction: ${JSON.stringify(t.tx,null,2)}`);return t.tx.sign(this.privateKey,1),this.restClient.sendTransaction(t.tx.toString())}))}send(e,t){return y(this,void 0,void 0,(function*(){const{restClient:o}=this;const n=new be({restClient:o});return n.tx.to(t,e),this.fundAndSendTx(n)}))}get hdPrivateKey(){return Q(this.restClient)}get privateKey(){return this.hdPrivateKey.privateKey}get publicKey(){return this.hdPrivateKey.publicKey}get passphrase(){return this.restClient.passphrase}get path(){return this.restClient.path}get chain(){return this.restClient.chain}get network(){return this.restClient.network}get url(){return this.restClient.url}get mnemonic(){return this.restClient.mnemonic}get address(){return this.publicKey.toAddress(this.restClient.network)}}class me{constructor(e={}){this.wallet=new we(e)}fromTxHex(e){return y(this,void 0,void 0,(function*(){const{restClient:t}=this.wallet;return be.fromTxHex({hex:e,restClient:t})}))}fromTxId(e){return y(this,void 0,void 0,(function*(){const[t]=yield this.wallet.restClient.getRawTxs([e]);return this.fromTxHex(t)}))}get(e){return y(this,void 0,void 0,(function*(){const t=e.map(oe);return Promise.all(t.map((({txId:e,outputIndex:t})=>y(this,void 0,void 0,(function*(){const{outData:o}=yield this.fromTxId(e);if(t>o.length)throw new Error("Index out of bounds");return o[t]})))))}))}put(e){return this.update([],e)}createTx(e,t){return y(this,void 0,void 0,(function*(){const{wallet:o}=this;const{restClient:n}=o;const r=new be({restClient:n});const{privateKey:i,publicKey:s}=o;const c=t.map((e=>{var{_owners:t}=e,o=p(e,["_owners"]);return Object.assign({_owners:t||[s.toString()]},o)})).map(ye);const a=yield Promise.all(c.map(function(e){return t=>y(this,void 0,void 0,(function*(){if(void 0!==t._url){const{_url:o,_owners:n,_amount:r}=t,i=p(t,["_url","_owners","_amount"]);const s=yield ce.setSecretOutput({host:o,secretOutput:{data:JSON.stringify(i)},privateKey:e});return void 0!==n&&(s._owners=n),void 0!==r&&(s._amount=r),s}return t}))}(i)));return yield r.spendFromData(e),yield r.createDataOuts(a),r}))}update(e,t){return y(this,void 0,void 0,(function*(){const o=yield this.createTx(e,t);return yield this.wallet.fundAndSendTx(o),o.outRevs}))}}const ke=["_id","_rev","_owners","_amount","_readers","_url","__vouts","__func","__index","__args"];const Se=e=>(Object.prototype.toString.call(e).match(/\s([a-zA-Z]+)/)||[])[1];const je=e=>"object"==typeof e?Se(e):Se(e).toLowerCase();const qe=e=>["number","string","boolean","undefined","Null"].includes(je(e));const xe=e=>"Array"===je(e);const Oe=e=>"Object"===je(e);const Ce=e=>qe(e)||["Array","Object"].includes(je(e));const Te=(e,t)=>{if(!Ce(e)||!Ce(t))throw new Error(`Unsupported data types for deep equals: ${je(e)} & ${je(t)}`);if(je(e)!==je(t))return!1;if(qe(e)&&qe(t))return e===t;const o=(e,t)=>Object.entries(e).every((([e,o])=>Te(t[e],o)));return e&&t&&o(e,t)&&o(t,e)};const Re=e=>{if(qe(e))return e;if(xe(e))return e.map(Re);if(Oe(e)){const t=Object.keys(e).reduce(((t,o)=>(t[o]=Re(e[o]),t)),{});const o=Object.create(Object.getPrototypeOf(e));return Object.assign(o,t)}throw new Error(`Unsupported data type for clone: ${je(e)}`)};const Be=(e,t)=>Object.fromEntries(Object.entries(e).map((e=>t(e))));const $e=(e,t)=>Be(e,(([e,o])=>[e,t(o)]));const Ae=(e,t)=>Object.fromEntries(Object.entries(e).filter((e=>t(e))));const Ee=(e,t,o,n)=>{if(qe(e))return e;if(xe(e))return e.map((e=>Ee(e,t,o,n)));if(Oe(e)){e._rev=`${n}/${o}`;const r=t[o];return Object.entries(e).forEach((([o,i])=>{"object"==typeof r&&Object.keys(r).includes(o)&&(e[o]=Ee(i,t,r[o],n))})),e}throw new Error(`Unsupported type ${je(e)} in deep.updateRev`)};const Ie=(e,t)=>{if(qe(e))return e;if(xe(e))return e.map((e=>Ie(e,t)));if(Oe(e))return e._id=!e._id||e._id.startsWith("__temp__")?e._rev:e._id,e._root=e._root||t,Object.entries(e).forEach((([o,n])=>{e[o]=Ie(n,t)})),e;throw new Error(`Unsupported type ${je(e)} in deep.addId`)};const Pe=e=>{if(qe(e))return e;if(xe(e))return e.map((e=>Pe(e)));if(Oe(e)){const t=`__temp__/${Math.random()}`;return e._id=e._id||t,e._rev=e._rev||t,Object.values(e).map((e=>Pe(e))),e}throw new Error(`Unsupported type ${je(e)} in addRandomId`)};const Ke=e=>{if(qe(e))return e;if(xe(e))return e.map((e=>Ke(e)));if(Oe(e))return Be(e,(([e,t])=>["_owners","_readers"].includes(e)?[e,JSON.stringify(t)]:qe(t)?[e,t]:[e,Ke(t)]));throw new Error(`Unexpected type ${je(e)} in stringifyOwners`)};const Le=e=>(e._owners&&(e._owners=JSON.parse(e._owners)),e._readers&&(e._readers=JSON.parse(e._readers)),e);const Ue=e=>{if(qe(e))return e;if(xe(e)||Oe(e))return Object.entries(e).reduce(((e,[t,o])=>{const n=Ue(o);return(e=>"Object"===je(e)&&Object.keys(e).every((e=>!Number.isNaN(parseInt(e,10)))))(n)?Object.entries(n).forEach((([o,n])=>{e[`${t}_${o}`]=n})):e[t]=n,e}),{});throw new Error(`Unsupported type ${je(e)} in encodeArraysAsObjects`)};const Ne=e=>{const t={[e._id]:Object.entries(e).reduce(((e,[t,o])=>ke.includes(t)?Object.assign(Object.assign({},e),{[t]:o}):qe(o)?Object.assign(Object.assign({},e),{[`__basic__${t}`]:o}):Object.assign(Object.assign({},e),{[t]:o._id})),{})};return Object.values(e).filter((e=>!qe(e))).reduce(((e,t)=>Object.assign(Object.assign({},e),Ne(t))),t)};const Me=e=>Ae(e,(([e])=>!e.startsWith("__basic__")));const He=(e,t)=>{const o=e[t];return o.__contains=Object.entries(o).reduce(((t,[o,n])=>["__contains",...ke].includes(o)?t:"__change"===o?"new"===n||"diff"===n||t:He(e,n)[n].__contains||t),!1),e};const De=(e,t)=>e.map((e=>Object.entries(e).reduce(((e,[o,n])=>{const r="string"==typeof n&&"undefined"!==je(t[n])?t[n]:n;return Object.assign(Object.assign({},e),{[o]:r})}),{})));var Fe={exports:{}};var We="win32"===process.platform;var ze=c;function Je(e,t){var o=[];for(var n=0;n<e.length;n++){var r=e[n];r&&"."!==r&&(".."===r?o.length&&".."!==o[o.length-1]?o.pop():t&&o.push(".."):o.push(r))}return o}function Ge(e){var t=e.length-1;var o=0;for(;o<=t&&!e[o];o++);var n=t;for(;n>=0&&!e[n];n--);return 0===o&&n===t?e:o>n?[]:e.slice(o,n+1)}var Ye=/^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;var Ze=/^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;var Qe={};function Ve(e){var t=Ye.exec(e),o=(t[1]||"")+(t[2]||""),n=t[3]||"";var r=Ze.exec(n);return[o,r[1],r[2],r[3]]}function Xe(e){var t=Ye.exec(e),o=t[1]||"",n=!!o&&":"!==o[1];return{device:o,isUnc:n,isAbsolute:n||!!t[2],tail:t[3]}}function et(e){return"\\\\"+e.replace(/^[\\\/]+/,"").replace(/[\\\/]+/g,"\\")}Qe.resolve=function(){var e="",t="",o=!1;for(var n=arguments.length-1;n>=-1;n--){var r;if(n>=0?r=arguments[n]:e?(r=process.env["="+e])&&r.substr(0,3).toLowerCase()===e.toLowerCase()+"\\"||(r=e+"\\"):r=process.cwd(),!ze.isString(r))throw new TypeError("Arguments to path.resolve must be strings");if(r){var i=Xe(r),s=i.device,c=i.isUnc,a=i.isAbsolute,d=i.tail;if((!s||!e||s.toLowerCase()===e.toLowerCase())&&(e||(e=s),o||(t=d+"\\"+t,o=a),e&&o))break}}return c&&(e=et(e)),e+(o?"\\":"")+(t=Je(t.split(/[\\\/]+/),!o).join("\\"))||"."},Qe.normalize=function(e){var t=Xe(e),o=t.device,n=t.isUnc,r=t.isAbsolute,i=t.tail,s=/[\\\/]$/.test(i);return(i=Je(i.split(/[\\\/]+/),!r).join("\\"))||r||(i="."),i&&s&&(i+="\\"),n&&(o=et(o)),o+(r?"\\":"")+i},Qe.isAbsolute=function(e){return Xe(e).isAbsolute},Qe.join=function(){var e=[];for(var t=0;t<arguments.length;t++){var o=arguments[t];if(!ze.isString(o))throw new TypeError("Arguments to path.join must be strings");o&&e.push(o)}var n=e.join("\\");return/^[\\\/]{2}[^\\\/]/.test(e[0])||(n=n.replace(/^[\\\/]{2,}/,"\\")),Qe.normalize(n)},Qe.relative=function(e,t){e=Qe.resolve(e),t=Qe.resolve(t);var o=e.toLowerCase();var n=t.toLowerCase();var r=Ge(t.split("\\"));var i=Ge(o.split("\\"));var s=Ge(n.split("\\"));var c=Math.min(i.length,s.length);var a=c;for(var d=0;d<c;d++)if(i[d]!==s[d]){a=d;break}if(0==a)return t;var u=[];for(d=a;d<i.length;d++)u.push("..");return(u=u.concat(r.slice(a))).join("\\")},Qe._makeLong=function(e){if(!ze.isString(e))return e;if(!e)return"";var t=Qe.resolve(e);return/^[a-zA-Z]\:\\/.test(t)?"\\\\?\\"+t:/^\\\\[^?.]/.test(t)?"\\\\?\\UNC\\"+t.substring(2):e},Qe.dirname=function(e){var t=Ve(e),o=t[0],n=t[1];return o||n?(n&&(n=n.substr(0,n.length-1)),o+n):"."},Qe.basename=function(e,t){var o=Ve(e)[2];return t&&o.substr(-1*t.length)===t&&(o=o.substr(0,o.length-t.length)),o},Qe.extname=function(e){return Ve(e)[3]},Qe.format=function(e){if(!ze.isObject(e))throw new TypeError("Parameter 'pathObject' must be an object, not "+typeof e);var t=e.root||"";if(!ze.isString(t))throw new TypeError("'pathObject.root' must be a string or undefined, not "+typeof e.root);var o=e.dir;var n=e.base||"";return o?o[o.length-1]===Qe.sep?o+n:o+Qe.sep+n:n},Qe.parse=function(e){if(!ze.isString(e))throw new TypeError("Parameter 'pathString' must be a string, not "+typeof e);var t=Ve(e);if(!t||4!==t.length)throw new TypeError("Invalid path '"+e+"'");return{root:t[0],dir:t[0]+t[1].slice(0,-1),base:t[2],ext:t[3],name:t[2].slice(0,t[2].length-t[3].length)}},Qe.sep="\\",Qe.delimiter=";";var tt=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;var ot={};function nt(e){return tt.exec(e).slice(1)}ot.resolve=function(){var e="",t=!1;for(var o=arguments.length-1;o>=-1&&!t;o--){var n=o>=0?arguments[o]:process.cwd();if(!ze.isString(n))throw new TypeError("Arguments to path.resolve must be strings");n&&(e=n+"/"+e,t="/"===n[0])}return(t?"/":"")+(e=Je(e.split("/"),!t).join("/"))||"."},ot.normalize=function(e){var t=ot.isAbsolute(e),o=e&&"/"===e[e.length-1];return(e=Je(e.split("/"),!t).join("/"))||t||(e="."),e&&o&&(e+="/"),(t?"/":"")+e},ot.isAbsolute=function(e){return"/"===e.charAt(0)},ot.join=function(){var e="";for(var t=0;t<arguments.length;t++){var o=arguments[t];if(!ze.isString(o))throw new TypeError("Arguments to path.join must be strings");o&&(e+=e?"/"+o:o)}return ot.normalize(e)},ot.relative=function(e,t){e=ot.resolve(e).substr(1),t=ot.resolve(t).substr(1);var o=Ge(e.split("/"));var n=Ge(t.split("/"));var r=Math.min(o.length,n.length);var i=r;for(var s=0;s<r;s++)if(o[s]!==n[s]){i=s;break}var c=[];for(s=i;s<o.length;s++)c.push("..");return(c=c.concat(n.slice(i))).join("/")},ot._makeLong=function(e){return e},ot.dirname=function(e){var t=nt(e),o=t[0],n=t[1];return o||n?(n&&(n=n.substr(0,n.length-1)),o+n):"."},ot.basename=function(e,t){var o=nt(e)[2];return t&&o.substr(-1*t.length)===t&&(o=o.substr(0,o.length-t.length)),o},ot.extname=function(e){return nt(e)[3]},ot.format=function(e){if(!ze.isObject(e))throw new TypeError("Parameter 'pathObject' must be an object, not "+typeof e);var t=e.root||"";if(!ze.isString(t))throw new TypeError("'pathObject.root' must be a string or undefined, not "+typeof e.root);return(e.dir?e.dir+ot.sep:"")+(e.base||"")},ot.parse=function(e){if(!ze.isString(e))throw new TypeError("Parameter 'pathString' must be a string, not "+typeof e);var t=nt(e);if(!t||4!==t.length)throw new TypeError("Invalid path '"+e+"'");return t[1]=t[1]||"",t[2]=t[2]||"",t[3]=t[3]||"",{root:t[0],dir:t[0]+t[1].slice(0,-1),base:t[2],ext:t[3],name:t[2].slice(0,t[2].length-t[3].length)}},ot.sep="/",ot.delimiter=":",Fe.exports=We?Qe:ot,Fe.exports.posix=ot,Fe.exports.win32=Qe;class rt{constructor({db:e=new me}={}){this.db=e}deploy(e){return y(this,void 0,void 0,(function*(){const[t]=yield this.db.put([{__mdl:e}]);return t}))}static bitcoinResolveHook(e){return e}static bitcoinImportHook(e){return y(this,void 0,void 0,(function*(){const[t]=yield(new me).get([e]);return new s(t.__mdl,e)}))}static nodeResolveHook(e="",t=""){if(e.startsWith("/"))throw TypeError(`Module specifier ${e} must not begin with "/"`);if(!t.startsWith("./"))throw TypeError(`Module referrer ${t} must begin with "./"`);const o=[];const n=[];ne(e)&&(n.push(...t.split("/")),n.pop(),o.push(".")),n.push(...e.split("/"));for(const r of n)if("."===r||""===r);else if(".."===r){if(0===n.length)throw TypeError(`Module specifier ${e} via referrer ${t} must not traverse behind an empty path`);o.pop()}else o.push(r);return o.join("/")}static nodeImportHook(e,t){return y(this,void 0,void 0,(function*(){if(!ne(e))throw TypeError(`Cannot locate module ${e}.`);const o=Fe.exports.join(t,e);const n=yield u(o,{encoding:"utf8"});if(void 0===n)throw new ReferenceError(`Cannot retrieve module at location ${o}.`);return new s(n,o)}))}static resolveHook(e,t){if(X(t)&&!X(e))throw new Error("Requiring a local file from a module on the blockchain is not supported.");return X(e)?rt.bitcoinResolveHook(e):rt.nodeResolveHook(e,t)}static makeImportHook(e){return t=>X(t)?rt.bitcoinImportHook(t):rt.nodeImportHook(t,e)}static getBitcoinCompartment(e){const{resolveHook:t,makeImportHook:o}=rt;return new Compartment({},{},{resolveHook:t,importHook:o(e)})}static import(e,t=Fe.exports.dirname(d(import.meta.url))){return y(this,void 0,void 0,(function*(){const o=rt.getBitcoinCompartment(t);const{namespace:n}=yield o.import(e);return n}))}}class st{constructor({db:e=new me}={}){this.db=e}get(e){return y(this,void 0,void 0,(function*(){const{txId:t,outputIndex:o}=oe(e);const{inRevs:n,outData:r}=yield this.db.fromTxId(t);if(!Array.isArray(n)||!Array.isArray(r)||0===r.length)return;const i=r[0].__index||{};const s=yield Promise.all(Object.values(i).map((e=>{const t=n[e];return t?this.get(t):Promise.resolve({})})));const c=Object.keys(i).map(((e,t)=>[e,s[t]]));const a=Object.fromEntries(c);let d=a.obj;delete a.obj;const u=Object.entries(a).reduce(((e,[t,o])=>{const n=parseInt(t,10);return Number.isNaN(n)||(e[n]=o),e}),[]);const{__cls:l,__func:h,__expt:v,__mdl:p,__args:y}=r[i.obj]||{};const g=function(e,t){let o=0;return t.map((t=>"__"===t?e[o++]:t))}(u,y||[]);let _;if(void 0!==v&&void 0!==p){const e=rt.getBitcoinCompartment("");const{namespace:t}=yield e.import(p);d=new Compartment(Object.assign(Object.assign({},t),{args:g})).evaluate(`Reflect.construct(${v}, args)`)}else if(void 0!==l){const e=(new Compartment).evaluate(`(${l})`);d=new Compartment({ClsFunc:e,args:g}).evaluate("Reflect.construct(ClsFunc, args)")}else{if(void 0===d||void 0===h)throw new Error("Unrecognized transaction.");{const e=d[h];_=new Compartment({func:e,target:d,args:g}).evaluate("Reflect.apply(func, target, args)")}}Object.entries(i).forEach((([e,o])=>{const n=parseInt(e,10);let i=u[n];"obj"===e?i=d:"res"===e&&(i=_),Ee(i,r,o,t)}));const f=(null==d?void 0:d._root)||`${t}/${i.obj}`;return Ie([_,d,...u],f),[...u,d,_][o]}))}}class ct{constructor({db:e=new me}={}){this.db=e,this.modules=new rt({db:e}),ct.proxyDepth=ct.proxyDepth||0}write(e){return y(this,void 0,void 0,(function*(){let t;let o;let n;let r;const{moduleSpecifier:i,target:s,property:c,constructorFunction:a,exportName:d,args:u=[]}=e;const l=Re(s);const h=Re(u);if(void 0!==d&&void 0!==u&&void 0!==i){const e=rt.getBitcoinCompartment("");const{namespace:s}=yield e.import(i);t=new Compartment(Object.assign(Object.assign({},s),{args:u})).evaluate(`Reflect.construct(${d}, args)`),o=u,r={__expt:d,__mdl:i},n=void 0}else if(void 0!==a&&void 0!==u)t=new Compartment({constructorFunction:a,args:u}).evaluate("Reflect.construct(constructorFunction, args)"),o=u,r={__cls:a.toString()},n=void 0;else{if(void 0===s||void 0===c)throw new Error("Unrecognized constructor or function call parameters.");t=s,o=u,r={__func:String(c)},ct.proxyDepth+=1,n=new Compartment({func:s[c],target:s,args:u}).evaluate("Reflect.apply(func, target, args)"),ct.proxyDepth-=1}const{smartArgs:v,dumbArgs:y}=V(h);const{smartArgs:g}=V(o);const _=Object.assign(Object.assign(Object.assign({},v),{obj:l}),{_id:"index"});const f=Object.assign(Object.assign(Object.assign({},g),{obj:t}),{_id:"index"});["Object","Array"].includes(je(n))&&(f.res=n);const[b,w,m]=((e,t)=>{const o=Pe(t);const n=o._id;const r=Re(e);const i=Re(o);const s=Ke(r);const c=Ke(i);const a=Ue(s);const d=Ue(c);const u=((e,t)=>Be(t,(([t,o])=>{const n=e[t];var r;return o.__change=(r=n)?Te(r,o)?"same":"diff":"new",[t,o]})))(Ne(a),Ne(d));const l=$e(u,Me);const h=He(l,n);const v=h[n];delete h[n];const y=$e(h,(e=>e._rev));const g=(_=e=>e.__contains||Object.values(v).includes(e._id),Ae(h,(([,e])=>_(e))));var _;const f=Object.values(g);const[b,w]=(m=e=>"new"===e.__change,f.reduce((([e,t],o,n)=>m(o)?[[...e,o],t]:[e,[...t,o]]),[[],[]]));var m;const k=[...w,...b];const S=(e=>e.reduce(((e,t,o)=>Object.assign(Object.assign({},e),{[t._id]:o})),{}))(k);const j=De(k,S);const[q]=De([v],S);const x=w.map((e=>e._rev));const[O,...C]=((e,t)=>[t,...e].map((e=>{const t=p(e,["_id","_rev","__change","__contains"]);return Ae(t,(([e,t])=>ke.includes(e)||"number"==typeof t))})))(j,q);return[x,C.map(Le).map((e=>Object.entries(e).reduce(((e,[t,o])=>Object.assign(Object.assign({},e),{[t]:y[o]||o})),{}))),O]})(_,f);void 0!==w[0]&&(w[0].__index=m);const k=m.obj;void 0!==w[k]&&(r.__args=y,w[k]=Object.assign(Object.assign({},w[k]),r));const S=m.res;void 0!==w[S]&&"function Object() { [native code] }"!==n.constructor.toString()&&(w[S].__cls=n.constructor.toString());const[j]=yield this.db.update(b,w);const{txId:q}=oe(j);Object.entries(m).forEach((([e,o])=>{let r;r="obj"===e?t:e.startsWith("res")?n:g[parseInt(e,10)],Ee(r,w,o,q)}));const x=(null==s?void 0:s._root)||`${q}/${m.obj}`;return Ie([n,t,...g],x),void 0!==n?n:t}))}get(e,t){return ct.proxyDepth>0||"function"!=typeof e[t]?Reflect.get(e,t):(...o)=>this.write({target:e,property:t,args:o})}}const{crypto:at}=e;class dt{constructor(e={}){if(void 0!==e.seed)throw new Error('The constructor parameter "seed" has been renamed to "mnemonic".');this.db=new me(e)}new(e,t,o){return y(this,void 0,void 0,(function*(){const n="function"==typeof e?e:void 0;const r="string"==typeof e?e:void 0;const i=new ct({db:this.db});const s=yield i.write({args:t,moduleSpecifier:o,constructorFunction:n,exportName:r});return new Proxy(s,i)}))}sync(e){return y(this,void 0,void 0,(function*(){te(e);const{db:t}=this;const o=new st({db:t});const n=new ct({db:t});const r=yield o.get(e);return new Proxy(r,n)}))}query({publicKey:t,contract:o}){return y(this,void 0,void 0,(function*(){let n={};if(t&&(n=Object.assign(Object.assign({},n),{publicKey:new e.PublicKey(t).toString()})),o){const e="string"==typeof o?o:o.toString();n=Object.assign(Object.assign({},n),{classHash:at.Hash.sha256(Buffer.from(e)).toString("hex")})}return this.db.wallet.restClient.query(n)}))}idsToRevs(e){return y(this,void 0,void 0,(function*(){return this.db.wallet.restClient.idsToRevs(e)}))}deploy(e){return y(this,void 0,void 0,(function*(){return new rt(this).deploy(e)}))}import(e,t){return y(this,void 0,void 0,(function*(){return(yield rt.import(t))[e]}))}getChain(){return this.db.wallet.restClient.chain}getNetwork(){return this.db.wallet.restClient.network}getMnemonic(){return this.db.wallet.restClient.mnemonic.toString()}getPrivateKey(){return this.db.wallet.privateKey.toString()}getPublicKey(){return this.db.wallet.publicKey.toString()}getAddress(){return this.db.wallet.address.toString()}getBalance(){return y(this,void 0,void 0,(function*(){return this.db.wallet.getBalance()}))}getUtxos(){return y(this,void 0,void 0,(function*(){const t=new e.Address(this.getAddress());return this.db.wallet.restClient.getUtxosByAddress(t)}))}broadcast(e){return y(this,void 0,void 0,(function*(){return this.db.wallet.restClient.sendTransaction(e)}))}queryRevs(e){return y(this,void 0,void 0,(function*(){return this.query(e)}))}getOwnedRevs(e=this.db.wallet.publicKey){return this.query({publicKey:e.toString()})}getRevs(e=this.db.wallet.publicKey){return y(this,void 0,void 0,(function*(){return this.query({publicKey:e.toString()})}))}getLatestRevs(e){return y(this,void 0,void 0,(function*(){return this.idsToRevs(e)}))}getLatestRev(e){return y(this,void 0,void 0,(function*(){const[t]=yield this.idsToRevs([e]);return t}))}rpcCall(e,t){return y(this,void 0,void 0,(function*(){const o=yield this.db.wallet.restClient.rpc(e,t);return o.result?o.result:{}}))}}var ut=h;var lt=v;var ht=a;function vt(e){"string"==typeof e&&(e=function(e){var t=ht.parse(e);var o=t.hostname;var n=parseInt(t.port,10);var r=t.protocol;r=r.substring(0,r.length-1);var i=t.auth.split(":");return{host:o,port:n,protocol:r,user:i[0]?decodeURIComponent(i[0]):null,pass:i[1]?decodeURIComponent(i[1]):null}}(e)),e=e||{},this.host=e.host||"127.0.0.1",this.port=e.port||8332,this.user=e.user||"user",this.pass=e.pass||"pass",this.protocol="http"===e.protocol?ut:lt,this.batchedCalls=null,this.disableAgent=e.disableAgent||!1;var t=void 0!==e.rejectUnauthorized;this.rejectUnauthorized=!t||e.rejectUnauthorized,vt.config.log?this.log=vt.config.log:this.log=vt.loggers[vt.config.logger||"normal"]}var pt=console.log.bind(console);var yt=function(){};function gt(e,t){var o=this;e=JSON.stringify(e);var n=this.user+":"+this.pass;var r=Buffer.from&&Buffer.from!==Uint8Array.from?Buffer.from(n):new Buffer(n);this.auth=r.toString("base64");var i={host:o.host,path:"/",method:"POST",port:o.port,rejectUnauthorized:o.rejectUnauthorized,agent:!o.disableAgent&&void 0};if(o.httpOptions)for(var s in o.httpOptions)i[s]=o.httpOptions[s];var c=!1;var a="Bitcoin JSON-RPC: ";var d=this.protocol.request(i,(function(e){var n="";e.on("data",(function(e){n+=e})),e.on("end",(function(){if(!c)if(c=!0,401!==e.statusCode)if(403!==e.statusCode){if(500===e.statusCode&&"Work queue depth exceeded"===n.toString("utf8")){var r=new Error("Bitcoin JSON-RPC: "+n.toString("utf8"));return r.code=429,void t(r)}var i;try{i=JSON.parse(n)}catch(r){o.log.err(r.stack),o.log.err(n),o.log.err("HTTP Status code:"+e.statusCode);var s=new Error(a+"Error Parsing JSON: "+r.message);return void t(s)}t(i.error,i)}else t(new Error(a+"Connection Rejected: 403 Forbidden"));else t(new Error(a+"Connection Rejected: 401 Unnauthorized"))}))}));d.on("error",(function(e){var o=new Error(a+"Request Error: "+e.message);c||(c=!0,t(o))})),d.setHeader("Content-Length",e.length),d.setHeader("Content-Type","application/json"),d.setHeader("Authorization","Basic "+o.auth),d.write(e),d.end()}vt.loggers={none:{info:yt,warn:yt,err:yt,debug:yt},normal:{info:pt,warn:pt,err:pt,debug:yt},debug:{info:pt,warn:pt,err:pt,debug:pt}},vt.config={logger:"normal"},vt.prototype.batch=function(e,t){this.batchedCalls=[],e(),gt.call(this,this.batchedCalls,t),this.batchedCalls=null},vt.callspec={abandonTransaction:"str",abortRescan:"",addMultiSigAddress:"",addNode:"",analyzePSBT:"str",backupWallet:"",bumpFee:"str",clearBanned:"",combinePSBT:"obj",combineRawTransaction:"obj",convertToPSBT:"str",createMultiSig:"",createPSBT:"obj",createRawTransaction:"obj obj",createWallet:"str",decodePSBT:"str",decodeScript:"str",decodeRawTransaction:"",deriveAddresses:"str",disconnectNode:"",dumpPrivKey:"",dumpWallet:"str",encryptWallet:"",enumerateSigners:"",estimateFee:"",estimateSmartFee:"int str",estimatePriority:"int",generate:"int",generateBlock:"str obj",generateToAddress:"int str",generateToDescriptor:"int str",getAccount:"",getAccountAddress:"str",getAddedNodeInfo:"",getAddressMempool:"obj",getAddressUtxos:"obj",getAddressBalance:"obj",getAddressDeltas:"obj",getAddressesByLabel:"str",getAddressInfo:"str",getAddressTxids:"obj",getAddressesByAccount:"",getBalance:"str int",getBalances:"",getBestBlockHash:"",getBlockDeltas:"str",getBlock:"str int",getBlockchainInfo:"",getBlockCount:"",getBlockFilter:"str",getBlockHashes:"int int obj",getBlockHash:"int",getBlockHeader:"str",getBlockNumber:"",getBlockStats:"str",getBlockTemplate:"",getConnectionCount:"",getChainTips:"",getChainTxStats:"",getDescriptorInfo:"str",getDifficulty:"",getGenerate:"",getHashesPerSec:"",getIndexInfo:"",getInfo:"",getMemoryInfo:"",getMemoryPool:"",getMemPoolAncestors:"str",getMemPoolDescendants:"str",getMemPoolEntry:"str",getMemPoolInfo:"",getMiningInfo:"",getNetTotals:"",getNetworkHashPS:"",getNetworkInfo:"",getNewAddress:"str str",getNodeAddresses:"",getPeerInfo:"",getRawChangeAddress:"",getRawMemPool:"bool",getRawTransaction:"str int",getReceivedByAccount:"str int",getReceivedByAddress:"str int",getReceivedByLabel:"str",getRpcInfo:"",getSpentInfo:"obj",getTransaction:"",getTxOut:"str int bool",getTxOutProof:"",getTxOutSetInfo:"",getUnconfirmedBalance:"",getWalletInfo:"",getWork:"",getZmqNotifications:"",finalizePSBT:"str",fundRawTransaction:"str",help:"",importAddress:"str str bool",importDescriptors:"str",importMulti:"obj obj",importPrivKey:"str str bool",importPrunedFunds:"str, str",importPubKey:"str",importWallet:"str",invalidateBlock:"str",joinPSBTs:"obj",keyPoolRefill:"",listAccounts:"int",listAddressGroupings:"",listBanned:"",listDescriptors:"",listLabels:"",listLockUnspent:"bool",listReceivedByAccount:"int bool",listReceivedByAddress:"int bool",listReceivedByLabel:"",listSinceBlock:"str int",listTransactions:"str int int",listUnspent:"int int",listWalletDir:"",listWallets:"",loadWallet:"str",lockUnspent:"",logging:"",move:"str str float int str",ping:"",preciousBlock:"str",prioritiseTransaction:"str float int",pruneBlockChain:"int",psbtBumpFee:"str",removePrunedFunds:"str",reScanBlockChain:"",saveMemPool:"",send:"obj",setHDSeed:"",setLabel:"str str",setWalletFlag:"str",scanTxOutSet:"str",sendFrom:"str str float int str str",sendMany:"str obj int str",sendRawTransaction:"str",sendToAddress:"str float str str",setAccount:"",setBan:"str str",setNetworkActive:"bool",setGenerate:"bool int",setTxFee:"float",signMessage:"",signMessageWithPrivKey:"str str",signRawTransaction:"",signRawTransactionWithKey:"str obj",signRawTransactionWithWallet:"str",stop:"",submitBlock:"str",submitHeader:"str",testMemPoolAccept:"obj",unloadWallet:"",upgradeWallet:"",uptime:"",utxoUpdatePSBT:"str",validateAddress:"",verifyChain:"",verifyMessage:"",verifyTxOutProof:"str",walletCreateFundedPSBT:"",walletDisplayAddress:"str",walletLock:"",walletPassPhrase:"string int",walletPassphraseChange:"",walletProcessPSBT:"str"};var _t=function(e,t,o){return Array.prototype.slice.call(e,t,o)};function ft(){return parseInt(1e5*Math.random())}!function(e,t,o){function n(e,t){return function(){var n=arguments.length-1;this.batchedCalls&&(n=arguments.length);for(var r=0;r<n;r++)t[r]&&(arguments[r]=t[r](arguments[r]));this.batchedCalls?this.batchedCalls.push({jsonrpc:"2.0",method:e,params:_t(arguments),id:ft()}):o.call(this,{method:e,params:_t(arguments,0,arguments.length-1),id:ft()},arguments[arguments.length-1])}}var r={str:function(e){return e.toString()},int:function(e){return parseFloat(e)},float:function(e){return parseFloat(e)},bool:function(e){return!0===e||"1"==e||"true"==e||"true"==e.toString().toLowerCase()},obj:function(e){return"string"==typeof e?JSON.parse(e):e}};for(var i in t){var s=[];if(t[i].length){s=t[i].split(" ");for(var c=0;c<s.length;c++)r[s[c]]?s[c]=r[s[c]]:s[c]=r.str}var a=i.toLowerCase();e.prototype[i]=n(a,s),e.prototype[a]=e.prototype[i]}}(vt,vt.callspec,gt);var bt=vt;const wt=new bt({protocol:process.env.RPC_PROTOCOL,user:process.env.RPC_USER,pass:process.env.RPC_PASSWORD,host:process.env.RPC_HOST,port:process.env.RPC_PORT});const mt={createwallet:c.promisify(bt.prototype.createwallet.bind(wt)),getaddressinfo:c.promisify(bt.prototype.getaddressinfo.bind(wt)),getBlock:c.promisify(bt.prototype.getBlock.bind(wt)),getBlockchainInfo:c.promisify(bt.prototype.getBlockchainInfo.bind(wt)),getBlockHash:c.promisify(bt.prototype.getBlockHash.bind(wt)),getNewAddress:c.promisify(bt.prototype.getNewAddress.bind(wt)),generateToAddress:c.promisify(bt.prototype.generateToAddress.bind(wt)),getRawTransaction:c.promisify(bt.prototype.getRawTransaction.bind(wt)),importaddress:c.promisify(bt.prototype.importaddress.bind(wt)),listunspent:c.promisify(bt.prototype.listunspent.bind(wt)),sendRawTransaction:c.promisify(bt.prototype.sendRawTransaction.bind(wt)),sendToAddress:c.promisify(bt.prototype.sendToAddress.bind(wt))};const{Opcode:kt,Script:St,Mnemonic:jt,crypto:qt,Transaction:xt,encoding:Ot}=e;function Ct(e=0){return q.split(";")[e]}function Tt(e=0){return new dt(function(e=0){return{mnemonic:Ct(),chain:k,network:S,path:Y({account:e})}}(e))}const Rt=({random:e=!1}={})=>y(void 0,void 0,void 0,(function*(){const t=e?Y():J();const o=function(e=0){return new jt(Ct(e))}();const n=new we({mnemonic:o,path:t});return yield l((()=>y(void 0,void 0,void 0,(function*(){return(e=>y(void 0,void 0,void 0,(function*(){const{result:t}=yield mt.generateToAddress(1,e.address);const{result:o}=yield mt.getBlock(t[0],2);if(o.confirmations<=0)throw new Error(`No confirmations on block mining: ${o.confirmations}`)})))(n)})))),t}));function Bt(e,o){const n=Object.keys(o);const r=Object.keys(e);if(n.length!==r.length)throw new Error("Actual keys do not match expected keys");n.forEach((n=>{const r=e[n];const i=o[n];if(void 0===i)throw new Error(`${n} is not defined in expected object`);if("value"===i.check)t(e).to.have.property(n),t(e[n]).to.deep.eq(i.value);else{if("type"!==i.check)throw new Error("Error configuring expectToEqual: set 'check' to 'type' or 'value'");if("string"===i.type)t(e).to.have.property(n).that.is.a("string");else if("number"===i.type)t(e).to.have.property(n).that.is.a("number");else if("array"===i.type){if(t(e).to.have.property(n).that.is.a("array").that.have.lengthOf(i.length),void 0!==i.length&&i.length>0)for(let e=0;e<r.length;e+=1)t(r[e]).to.be.an(i.subtype)}else{if("object"!==i.type)throw new Error("Error configuring expectToEqual: set 'type' to 'number', 'string', array', or 'object'.");t(e).to.have.property(n).that.is.an("object")}}}))}const $t=e=>e.split("/")[0];const At=Ct();const Et=e=>{const[t,o]=e.split("/");const n=parseFloat(o);return[64,65].includes(t.length)&&!Number.isNaN(n)&&Number.isFinite(n)};let It=[];before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){It=yield function({n:e=1,random:t=!1}={}){return y(this,void 0,void 0,(function*(){const o=[];for(let n=0;n<e;n+=1)o.push(yield Rt({random:t}));return yield y(void 0,void 0,void 0,(function*(){let e=!1;do{try{const{result:t}=yield mt.generateToAddress(100,(new jt).toHDPrivateKey("",S).derive(J()).privateKey.toPublicKey().toAddress());e=100===t.length}catch(e){F(500)}}while(!e)})),o}))}({n:58,random:!0})}))));let Pt=0;function Kt(){if(Pt+=1,It.length)return It.pop();throw Error(`No more paths ${Pt}`)}describe("Computer",(()=>{describe("New",(()=>{describe("Should create a smart object without argument",(()=>{class e{constructor(){this.n=1}}let o;let n;let r;let i;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){n=new dt({mnemonic:At,path:Kt()}),r=new dt({mnemonic:At,path:Kt()}),({db:i}=n),o=yield n.new(e)})))),it("Should create a smart object when computer.new is called",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{n:{check:"value",type:"number",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(o._id).eq(o._rev),t(o._id).eq(o._root),t(Et(o._id)),t(Et(o._rev)),t(Et(o._root))})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:i});t(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const n=yield i.get([o._rev]);t(n).to.be.an("array").that.have.lengthOf(1),Bt(n[0],{__args:{check:"type",type:"array",length:0},__index:{check:"type",type:"object"},__cls:{check:"value",value:e.toString(),type:"string"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x,type:"number"}}),t(n[0].__index).to.deep.eq({obj:0})})))),it("should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield n.getLatestRev(o._id)).eq(o._rev)})))),it("should work with idsToRevs",(()=>y(void 0,void 0,void 0,(function*(){t(yield n.idsToRevs([o._id])).to.deep.eq([o._rev])})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield r.sync(o._rev)).to.deep.eq(o)})))),it("Should be able to call the RPC methods",(()=>y(void 0,void 0,void 0,(function*(){yield n.rpcCall("getBlockchainInfo","")}))))})),describe("Should create a smart object with a dumb argument",(()=>{class e{constructor(e){this.n=e}}let o;const n=Math.random();let r;let i;let s;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){r=new dt({mnemonic:At,path:Kt()}),i=new dt({mnemonic:At,path:Kt()}),({db:s}=r),o=yield r.new(e,[n])})))),it("Should create a smart object when computer.new is called",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{n:{check:"value",type:"number",value:n},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(o._id).eq(o._rev),t(o._id).eq(o._root),t(Et(o._id)),t(Et(o._rev)),t(Et(o._root))})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:s});t(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const r=yield s.get([o._rev]);t(r).to.be.an("array").that.have.lengthOf(1),Bt(r[0],{__args:{check:"type",type:"array",length:1,subtype:"number"},__index:{check:"type",type:"object"},__cls:{check:"value",value:e.toString(),type:"string"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x,type:"number"}}),t(r[0].__args).to.deep.eq([n]),t(r[0].__index).to.deep.eq({obj:0})})))),it("should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create a smart object with a smart argument",(()=>{class e{constructor(){this.n=1}}class o{constructor(e){this.a=e}}let n;let r;let i;let s;let c;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){i=new dt({mnemonic:At,path:Kt()}),s=new dt({mnemonic:At,path:Kt()}),({db:c}=i),n=yield i.new(e,[]),r=yield i.new(o,[n])})))),it("Should create a smart object when computer.new is called",(()=>y(void 0,void 0,void 0,(function*(){Bt(n,{n:{check:"value",type:"number",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(r.a,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),t(r.a).to.deep.eq(n)})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(Et(n._id)),t(Et(n._rev)),t(Et(n._root)),t(Et(r._id)),t(Et(r._rev)),t(Et(r._root));const e=$t(n._id);const o=$t(r._id);t(e).not.eq(o),t(n._id).eq(`${e}/0`),t(n._rev).eq(`${o}/0`),t(r._id).eq(`${o}/1`),t(r._rev).eq(`${o}/1`),t(r.a._id).eq(n._id),t(r.a._rev).eq(n._rev),t(n._root).eq(n._id),t(r._root).eq(r._id)})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:c});t(yield e.get(n._rev)).to.deep.eq(n),t(yield e.get(r._rev)).to.deep.eq(r)})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const i=yield c.get([n._id]);t(i).to.be.an("array").that.have.lengthOf(1),Bt(i[0],{__args:{check:"type",type:"array",length:0},__index:{check:"type",type:"object"},__cls:{check:"value",value:e.toString(),type:"string"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x,type:"number"}}),t(i[0].__index).to.deep.eq({obj:0});const s=$t(r._id);const a=yield c.get([`${s}/0`,`${s}/1`]);t(a).to.be.an("array").that.have.lengthOf(2),Bt(a[0],{__index:{check:"type",type:"object"},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x,type:"number"}}),t(a[0].__index).to.deep.eq({0:0,obj:1}),Bt(a[1],{a:{check:"value",value:0},__args:{check:"value",value:["__"]},__cls:{check:"value",value:o.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}})})))),it("Should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield i.getLatestRev(r._id)).eq(r._rev),t(yield i.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with idsToRevs",(()=>y(void 0,void 0,void 0,(function*(){t(yield i.idsToRevs([n._id])).to.deep.eq([n._rev]),t(yield i.idsToRevs([r._id])).to.deep.eq([r._rev])})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield s.sync(n._rev)).to.deep.eq(n),t(yield s.sync(r._rev)).to.deep.eq(r)}))))})),describe("Should create a smart object with a sub-object",(()=>{class e{constructor(){this.n={m:1}}}let o;let n;let r;let i;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){n=new dt({mnemonic:At,path:Kt()}),r=new dt({mnemonic:At,path:Kt()}),({db:i}=n),o=yield n.new(e,[])})))),it("Should create a smart object when computer.new is called",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{n:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(o.n,{m:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(o._id).eq(o._rev),t(o.n._id).eq(o.n._rev),t(o._root).eq(o._id),t(o.n._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:i});const n=yield e.get(o._rev);t(n).to.deep.eq(o),t(o.n._id.startsWith("__temp__")).eq(!1),t(o.n._rev.startsWith("__temp__")).eq(!1);const r=yield e.get(o.n._rev);t(r).to.be.undefined})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const n=yield i.get([o._rev]);t(n).to.be.an("array").that.have.lengthOf(1),Bt(n[0],{n:{check:"value",value:1},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}})})))),it("Should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield n.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create a smart object with a smart sub-object",(()=>{class e{constructor(t){this.b=t?new e(!1):void 0}}let o;let n;let r;let i;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){n=new dt({mnemonic:At,path:Kt()}),r=new dt({mnemonic:At,path:Kt()}),({db:i}=n),o=yield n.new(e,[!0])})))),it("Should create a smart object when computer.new is called",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{b:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(o.b,{b:{check:"value",value:void 0},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(o._id).eq(o._rev),t(o.b._id).eq(o.b._rev),t(o._root).eq(o._id),t(o.b._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:i});const n=yield e.get(o._rev);t(n).to.deep.eq(o),t(o.b._id.startsWith("__temp__")).eq(!1),t(o.b._rev.startsWith("__temp__")).eq(!1);const r=yield e.get(o.b._rev);t(r).to.be.undefined})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const n=yield i.get([o._rev]);t(n).to.be.an("array").that.have.lengthOf(1),Bt(n[0],{b:{check:"value",value:1},__args:{check:"value",value:[!0]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}})})))),it("Should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield n.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create a smart object with an owner defined",(()=>{class e{constructor(e,t){this.n=e,this._owners=[t]}}let o;const n=Math.random();let r;let i;let s;let c;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){r=new dt({mnemonic:At,path:Kt()}),i=new dt({mnemonic:At,path:Kt()}),({db:s}=r),c=r.db.wallet.publicKey.toString(),o=yield r.new(e,[n,c])})))),it("Should create a smart object when computer.new is called",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{n:{check:"value",value:n},_owners:{check:"value",value:[c]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(o._id).eq(o._rev),t(o._id).eq(o._root),t(Et(o._id)),t(Et(o._rev)),t(Et(o._root))})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:s});t(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const r=yield s.get([o._rev]);t(r).to.be.an("array").that.have.lengthOf(1),Bt(r[0],{__args:{check:"value",value:[n,c]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}})})))),it("should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should create an encrypted smart object",(()=>{class e{constructor(e,t){this.n=e,this._readers=[t]}}let o;const n=Math.random();let r;let i;let s;let c;let a;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){r=new dt({mnemonic:At,path:Kt()}),i=new dt({mnemonic:"average metal token tube twice idle yellow mail imitate nuclear clerk cover",path:Kt()}),({db:s}=r),({db:c}=i),a=r.db.wallet.publicKey.toString(),o=yield r.new(e,[n,a])})))),it("Should create a smart object when computer.new is called",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{n:{check:"value",value:n},_readers:{check:"value",value:[a]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(o._id).eq(o._rev),t(o._id).eq(o._root),t(Et(o._id)),t(Et(o._rev)),t(Et(o._root))})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:s});t(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with encoded data",(()=>y(void 0,void 0,void 0,(function*(){const r=yield s.get([o._id]);t(r).to.be.an("array").that.have.lengthOf(1),Bt(r[0],{__args:{check:"value",value:[n,a]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_readers:{check:"value",value:[]},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}})})))),it("Should be able to decode the output when db has access",(()=>y(void 0,void 0,void 0,(function*(){const r=yield s.get([o._rev]);t(r).to.be.an("array").that.have.lengthOf(1),Bt(r[0],{__args:{check:"value",value:[n,a]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_readers:{check:"value",value:[]},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}})})))),it("Should be not able to decode the output when db does not has access",(()=>y(void 0,void 0,void 0,(function*(){try{yield c.get([o._rev])}catch(e){t(e).to.be.instanceof(Error),t(e).to.have.property("message","Decryption failure")}})))),it("should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield r.sync(o._rev)).to.deep.eq(o);try{yield i.sync(o._rev),t(!0).eq(!1)}catch(e){t(e.message).to.not.be.undefined}}))))})),describe("Should create an off-chain object",(()=>{class e{constructor(e){this.n=e,this._url="http://127.0.0.1:3000"}}let o;const n=Math.random();let r;let i;let s;let c;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){r=new dt({mnemonic:At,path:Kt()}),i=new dt({mnemonic:At,path:Kt()}),({db:s}=r),({db:c}=i),o=yield r.new(e,[n])})))),it("Should create a smart object when computer.new is called",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{n:{check:"value",value:n},_url:{check:"value",value:"http://127.0.0.1:3000"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:s});t(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with encoded data data",(()=>y(void 0,void 0,void 0,(function*(){const i=o._rev.split("/")[0];const{restClient:s}=r.db.wallet;const c=yield be.fromTxId({txId:i,restClient:s});const{outData:a}=c;t(a).to.be.an("array").that.have.lengthOf(1),Bt(a[0],{__args:{check:"value",value:[n]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x},_url:{check:"type",type:"string"}})})))),it("Should be able to get the output from the server when db has access",(()=>y(void 0,void 0,void 0,(function*(){const r=yield s.get([o._rev]);t(r).to.be.an("array").that.have.lengthOf(1),Bt(r[0],{__args:{check:"value",value:[n]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("Should give all users access to the server",(()=>y(void 0,void 0,void 0,(function*(){const r=yield c.get([o._rev]);t(r).to.be.an("array").that.have.lengthOf(1),Bt(r[0],{__args:{check:"value",value:[n]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe.skip("Should work if the contract is a string",(()=>{let e=null;let o;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){o=new dt({mnemonic:At,path:Kt()}),e=yield o.new("class A {\n        constructor(n) {\n          this.n = n\n        }\n      }",[1])})))),it("should work",(()=>{t(e).to.not.be.undefined,t(typeof e).eq("object"),Bt(e,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),t(e._id).eq(e._rev)})),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){const o=Tt();t(yield o.sync(e._rev)).to.deep.eq(e)}))))})),describe("Should not create a smart object if no args as passed to the constructor",(()=>{class e{constructor(e,t){this.n=e,this._owners=[t]}}let o;it("Should throw an error",(()=>y(void 0,void 0,void 0,(function*(){try{const n=new dt;o=o||(yield n.new(e,[])),t(!0).eq(!1)}catch(e){t(o).to.be.undefined,t(e.message).to.not.be.undefined}}))))}))})),describe("Function calls",(()=>{describe("Should work for a function call with a dumb argument",(()=>{class e{constructor(e){this.n=e}inc(e){return this.n+=e,this.n}}let o;let n;let r;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){const t=new dt({mnemonic:At,path:Kt()});r=new dt({mnemonic:At,path:Kt()}),({db:n}=t),o=yield t.new(e,[1]),yield o.inc(1)})))),it("Should update the smart object",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{n:{check:"value",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(Et(o._id)).eq(!0),t(Et(o._rev)).eq(!0),t(Et(o._root)).eq(!0),t(o._id).not.eq(o._rev),t(o._id).eq(o._root)})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:n});t(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const r=yield n.get([o._id]);t(r).to.be.an("array").that.have.lengthOf(1),Bt(r[0],{__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}});const i=yield n.get([o._rev]);t(i).to.be.an("array").that.have.lengthOf(1),Bt(i[0],{__func:{check:"value",value:"inc"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}})})))),it("Should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){const e=new dt;t(yield e.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work for a function call on an encrypted object",(()=>{class e{constructor(e,t){this.n=e,this._readers=[t]}inc(e){return this.n+=e,this.n}}let o;const n=Math.random();let r;let i;let s;let c;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){r=new dt({mnemonic:At,path:Kt()}),i=new dt({mnemonic:"average metal token tube twice idle yellow mail imitate nuclear clerk cover",path:Kt()}),({db:s}=r),c=r.db.wallet.publicKey.toString(),o=yield r.new(e,[n,c]),yield o.inc(1)})))),it("Should update the smart object",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{n:{check:"type",type:"number"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"},_readers:{check:"value",value:[c]}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(Et(o._id)).eq(!0),t(Et(o._rev)).eq(!0),t(Et(o._root)).eq(!0),t(o._id).not.eq(o._rev),t(o._id).eq(o._root)})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:s});t(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const r=yield s.get([o._id]);t(r).to.be.an("array").that.have.lengthOf(1),Bt(r[0],{__args:{check:"value",value:[n,c]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x},_readers:{check:"value",value:[]}});const i=yield s.get([o._rev]);t(i).to.be.an("array").that.have.lengthOf(1),Bt(i[0],{__func:{check:"value",value:"inc"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x},_readers:{check:"value",value:[]}})})))),it("Should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield r.sync(o._rev)).to.deep.eq(o);try{yield i.sync(o._rev),t(!0).eq(!1)}catch(e){t(e.message).to.not.be.undefined}}))))})),describe("Should work for a function call on an off chain object",(()=>{class e{constructor(e){this.n=e,this._url="http://127.0.0.1:3000"}inc(e){return this.n+=e,this.n}}let o;const n=Math.random();let r;let i;let s;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){r=new dt({mnemonic:At,path:Kt()}),i=new dt({mnemonic:At,path:Kt()}),({db:s}=r),o=yield r.new(e,[n]),yield o.inc(1)})))),it("Should update the smart object",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{n:{check:"type",type:"number"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(Et(o._id)).eq(!0),t(Et(o._rev)).eq(!0),t(Et(o._root)).eq(!0),t(o._id).not.eq(o._rev),t(o._id).eq(o._root)})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:s});t(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const r=yield s.get([o._id]);t(r).to.be.an("array").that.have.lengthOf(1),Bt(r[0],{__args:{check:"value",value:[n]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x},_url:{check:"value",value:"http://127.0.0.1:3000"}});const i=yield s.get([o._rev]);t(i).to.be.an("array").that.have.lengthOf(1),Bt(i[0],{__func:{check:"value",value:"inc"},__args:{check:"value",value:[1]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x},_url:{check:"value",value:"http://127.0.0.1:3000"}})})))),it("Should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield r.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield i.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work for a function with a smart argument",(()=>{class e{constructor(){this.n=1}}class o{constructor(){this.m=2}objInc(e){return e.n+=1,this.m+=e.n,this.m}}let n;let r;let i;let s;let c;let a;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){s=new dt({mnemonic:At,path:Kt()}),c=new dt({mnemonic:At,path:Kt()}),a=s.db,n=yield s.new(e,[]),r=yield s.new(o,[]),i=yield r.objInc(n)})))),it("Should update the smart object",(()=>y(void 0,void 0,void 0,(function*(){Bt(n,{n:{check:"value",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(r,{m:{check:"value",value:4},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should return the correct value",(()=>{t(i).eq(4)})),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(Et(n._id)).eq(!0),t(Et(n._rev)).eq(!0),t(Et(n._root)).eq(!0),t(Et(r._id)).eq(!0),t(Et(r._rev)).eq(!0),t(Et(r._root)).eq(!0);const e=$t(n._id);const o=$t(r._id);const i=$t(r._rev);t(e).not.eq(o),t(o).not.eq(i),t(i).not.eq(e),t(n._id).eq(`${e}/0`),t(r._id).eq(`${o}/0`),t(n._rev).eq(`${i}/0`),t(r._rev).eq(`${i}/1`),t(n._root).eq(n._id),t(r._root).eq(r._id)})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:a});t(yield e.get(n._rev)).to.deep.eq(n),t(yield e.get(r._rev)).to.deep.eq(r)})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const i=yield a.get([n._id]);t(i).to.be.an("array").that.have.lengthOf(1),Bt(i[0],{__args:{check:"value",value:[]},__cls:{check:"value",value:e.toString()},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}});const s=$t(r._id);const c=yield a.get([`${s}/0`]);t(c).to.be.an("array").that.have.lengthOf(1),Bt(c[0],{__args:{check:"value",value:[]},__cls:{check:"value",value:o.toString()},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}});const d=$t(r._rev);const u=yield a.get([`${d}/0`,`${d}/1`]);t(u).to.be.an("array").that.have.lengthOf(2),Bt(u[0],{__index:{check:"value",value:{obj:1,0:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}}),Bt(u[1],{__func:{check:"value",value:"objInc"},__args:{check:"value",value:["__"]},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}})})))),it("Should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield s.getLatestRev(n._id)).eq(n._rev),t(yield s.getLatestRev(r._id)).eq(r._rev)})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield c.sync(n._rev)).to.deep.eq(n),t(yield c.sync(r._rev)).to.deep.eq(r)}))))})),describe("Should work for a function that returns a dumb object",(()=>{class e{getJson(){return{n:1}}}let o;let n;let r;let i;let s;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){r=new dt({mnemonic:At,path:Kt()}),i=new dt({mnemonic:At,path:Kt()}),({db:s}=r),o=yield r.new(e,[]),n=n||(yield o.getJson(3))})))),it("Should update the smart object",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(n,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(Et(o._id)).eq(!0),t(Et(o._rev)).eq(!0),t(Et(o._root)).eq(!0),t(Et(n._id)).eq(!0),t(Et(n._rev)).eq(!0),t(Et(n._root)).eq(!0);const e=$t(o._id);const r=$t(n._id);t(e).not.eq(r),t(o._id).eq(`${e}/0`),t(n._id).eq(`${r}/1`),t(o._rev).eq(`${r}/0`),t(n._rev).eq(`${r}/1`),t(o._root).eq(o._id),t(n._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:s});t(yield e.get(o._rev)).to.deep.eq(o),t(yield e.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const r=yield s.get([o._id]);t(r).to.be.an("array").that.have.lengthOf(1),Bt(r[0],{__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}});const i=$t(n._id);const c=yield s.get([`${i}/0`,`${i}/1`]);t(c).to.be.an("array").that.have.lengthOf(2),Bt(c[0],{__func:{check:"value",value:"getJson"},__args:{check:"value",value:[3]},__index:{check:"value",value:{obj:0,res:1}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}}),Bt(c[1],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}})})))),it("Should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield r.getLatestRev(o._id)).eq(o._rev),t(yield r.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield i.sync(o._rev)).to.deep.eq(o),t(yield i.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should work for a function that returns a smart object",(()=>{class e{constructor(e){this.n=e}send(t){if(t>this.n)throw new Error;return this.n-=t,new e(t)}}let o;let n;let r;let i;let s;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){r=new dt({mnemonic:At,path:Kt()}),i=new dt({mnemonic:At,path:Kt()}),({db:s}=r),o=yield r.new(e,[10]),n=yield o.send(3)})))),it("Should update the smart object",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{n:{check:"value",value:7},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(n,{n:{check:"value",value:3},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(Et(o._id)).eq(!0),t(Et(o._rev)).eq(!0),t(Et(o._root)).eq(!0),t(Et(n._id)).eq(!0),t(Et(n._rev)).eq(!0),t(Et(n._root)).eq(!0);const e=$t(o._id);const r=$t(n._id);t(e).not.eq(r),t(o._id).eq(`${e}/0`),t(n._id).eq(`${r}/1`),t(o._rev).eq(`${r}/0`),t(n._rev).eq(`${r}/1`),t(o._root).eq(o._id),t(n._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:s});t(yield e.get(o._rev)).to.deep.eq(o),t(yield e.get(n._rev)).to.deep.eq(n)})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const r=yield s.get([o._id]);t(r).to.be.an("array").that.have.lengthOf(1),Bt(r[0],{__args:{check:"value",value:[10]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}});const i=$t(n._id);const c=yield s.get([`${i}/0`,`${i}/1`]);t(c).to.be.an("array").that.have.lengthOf(2),Bt(c[0],{__func:{check:"value",value:"send"},__args:{check:"value",value:[3]},__index:{check:"value",value:{obj:0,res:1}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}}),Bt(c[1],{__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}})})))),it("Should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield r.getLatestRev(o._id)).eq(o._rev),t(yield r.getLatestRev(n._id)).eq(n._rev)})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield i.sync(o._rev)).to.deep.eq(o),t(yield i.sync(n._rev)).to.deep.eq(n)}))))})),describe("Should work for a function that updates a nested object",(()=>{class e{constructor(){this.a={aa:1},this.b={bb:2}}update(){this.b.bb=3}}let o;let n;let r;let i;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){n=new dt({mnemonic:At,path:Kt()}),r=new dt({mnemonic:At,path:Kt()}),({db:i}=n),o=yield n.new(e,[]),yield o.update()})))),it("Should update the smart object",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{a:{check:"type",type:"object"},b:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(o.a,{aa:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(o.b,{bb:{check:"value",value:3},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(Et(o._id)).eq(!0),t(Et(o._rev)).eq(!0),t(Et(o._root)).eq(!0),t(Et(o.a._id)).eq(!0),t(Et(o.a._rev)).eq(!0),t(Et(o.a._root)).eq(!0),t(Et(o.b._id)).eq(!0),t(Et(o.b._rev)).eq(!0),t(Et(o.b._root)).eq(!0);const e=$t(o._id);t(o._id).eq(`${e}/0`),t(o.a._id).eq(`${e}/1`),t(o.b._id).eq(`${e}/2`),t(o._root).eq(o._id),t(o.a._root).eq(o._id),t(o.b._root).eq(o._id)})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:i});t(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const n=yield i.get([o._id,o.a._id,o.b._id]);t(n).to.be.an("array").that.have.lengthOf(3),Bt(n[0],{a:{check:"value",value:1},b:{check:"value",value:2},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},__cls:{check:"value",value:e.toString()},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}}),Bt(n[1],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}}),Bt(n[2],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}});const r=yield i.get([o._rev,o.a._rev,o.b._rev]);t(r).to.be.an("array").that.have.lengthOf(3),Bt(r[0],{b:{check:"value",value:1},__func:{check:"value",value:"update"},__args:{check:"value",value:[]},__index:{check:"value",value:{obj:0}},_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}}),Bt(r[1],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}}),Bt(r[2],{_owners:{check:"type",type:"array",length:1,subtype:"string"},_amount:{check:"value",value:x}})})))),it("Should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield n.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield r.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work for a function that returns an array",(()=>{class e{constructor(){this.aa=1}createArray(){return this.a=new e,[new e,new e]}}let t;let o;let n;let r;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){r=new dt({mnemonic:At,path:Kt()}),t=yield r.new(e,[]),[o,n]=yield t.createArray()})))),it("Should return an array",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{aa:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(n,{aa:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns an object created by a property wrapped as object",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}o(){return{o:this.a.f()}}}let o;let n;let r;let i;let s;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){s=new dt({mnemonic:At,path:Kt()}),o=yield s.new(e,[]),r=yield s.new(t,[o]),n=yield r.g(),({o:i}=yield r.o())})))),it("Should return the object",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(i,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns an object created by a property wrapped in an array",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}o(){return[this.a.f()]}}let o;let n;let r;let i;let s;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){s=new dt({mnemonic:At,path:Kt()}),o=yield s.new(e,[]),r=yield s.new(t,[o]),n=yield r.g(),[i]=yield r.o()})))),it("Should return the object",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(i,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns multiple objects created by a property wrapped in an array",(()=>{class e{f(){return new e}}class o{constructor(e){this.a=e}g(){return this.a.f()}o(){return[this.a.f(),this.a.f()]}}let n;let r;let i;let s;let c;let a;let d;let u;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){a=new dt({mnemonic:At,path:Kt()}),d=new dt({mnemonic:At,path:Kt()}),({db:u}=a),n=yield a.new(e,[]),i=yield a.new(o,[n]),r=yield i.g(),[s,c]=yield i.o()})))),it("Should update the smart object",(()=>y(void 0,void 0,void 0,(function*(){Bt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(r,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(s,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(c,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(i,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(i.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){const e=[n,r,s,c,i];for(let o=0;o<e.length;o+=1){const n=e[o];t(Et(n._id)).eq(!0),t(Et(n._rev)).eq(!0),t(Et(n._root)).eq(!0)}t(n._id).not.eq(n._rev),t(i._id).not.eq(i._rev),t(r._id).eq(r._rev)})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:u});t(yield e.get(n._rev)).to.deep.eq(n),t(yield e.get(r._rev)).to.deep.eq(r),t(yield e.get(i._rev)).to.deep.eq(i)})))),it("Should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield a.getLatestRev(n._id)).eq(n._rev),t(yield a.getLatestRev(r._id)).eq(r._rev),t(yield a.getLatestRev(i._id)).eq(i._rev)})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield d.sync(n._rev)).to.deep.eq(n),t(yield d.sync(r._rev)).to.deep.eq(r),t(yield d.sync(i._rev)).to.deep.eq(i)}))))})),describe("Should work for a function that returns multiple objects created by a property",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}o(){return this.a.f()}}let o;let n;let r;let i;let s;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){s=new dt({mnemonic:At,path:Kt()}),o=yield s.new(e,[]),r=yield s.new(t,[o]),n=yield r.g(),i=yield r.o()})))),it("Should return the object",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(i,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work for a function that returns an object created by a property",(()=>{class e{f(){return new e}}class t{constructor(e){this.a=e}g(){return this.a.f()}}let o;let n;let r;let i;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){i=new dt({mnemonic:At,path:Kt()}),o=yield i.new(e,[]),r=yield i.new(t,[o]),n=yield r.g()})))),it("Should return the object",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(n,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(r,{a:{check:"type",type:"object"},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(r.a,{_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))))})),describe("Should work when setting an owner",(()=>{class e{constructor(e){this._owners=[e]}updateOwner(e){this._owners=[e]}}let o;const n=new dt({chain:k,network:S});const r=n.db.wallet.publicKey.toString();let i;let s;let c;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){i=new dt({mnemonic:At,path:Kt()}),c=i.db.wallet.publicKey.toString(),({db:s}=i),o=yield i.new(e,[c]),yield o.updateOwner(r)})))),it("Should update the smart object",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{_owners:{check:"value",value:[r]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){const e=$t(o._id);t(o._id).eq(`${e}/0`)})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const e=new st({db:s});t(yield e.get(o._rev)).to.deep.eq(o)})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const[n]=yield s.get([o._id]);t(n).to.deep.eq({__args:[c],__index:{obj:0},__cls:e.toString(),_amount:x,_owners:[c]});const[i]=yield s.get([o._rev]);t(i).to.deep.eq({__func:"updateOwner",__args:[r],__index:{obj:0},_owners:[r],_amount:x})})))),it("Should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield i.getLatestRev(o._id)).eq(o._rev)})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield n.sync(o._rev)).to.deep.eq(o)}))))})),describe("Should work with multiple computers",(()=>{class e{constructor(){this.n=1}inc(){this.n+=1}}let t=null;let o=null;let n;let r;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){n=new dt({mnemonic:At,path:Kt()}),r=new dt({mnemonic:At,path:Kt()}),t=yield n.new(e,[]),o=yield r.new(e,[]),yield t.inc()})))),it("should work",(()=>{Bt(t,{n:{check:"value",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}}),Bt(o,{n:{check:"value",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})}))}))})),describe("sync",(()=>{class e{constructor(e,t){this.n=e,this._owners=[t]}}let o;const n=Math.random();let r;let i;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){r=new dt({path:Kt(),mnemonic:At}),i=r.db.wallet.publicKey.toString(),o=yield r.new(e,[n,i])})))),it("Should create another instance of the same smart object",(()=>y(void 0,void 0,void 0,(function*(){Bt(o,{n:{check:"value",value:n},_owners:{check:"value",value:[i]},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}});const e=Tt();const r=yield e.sync(o._rev);t(r).to.deep.eq(o)})))),it("throw an error if no params are passed to sync function",(()=>y(void 0,void 0,void 0,(function*(){const e=Tt();try{yield e.sync(),t(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t(e.message).eq("Invalid outId: undefined")}})))),it("throw an error if rev is not in the right format: tdId:num",(()=>y(void 0,void 0,void 0,(function*(){const e=Tt();try{yield e.sync("123"),t(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t(e.message).eq("Invalid outId: 123")}})))),it("throw an error if trId in rev is not 64 hex characters",(()=>y(void 0,void 0,void 0,(function*(){const e=Tt();try{yield e.sync("123:0"),t(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t(e.message).eq("Invalid outId: 123:0")}})))),it("throw an error if trId in rev is contains non hex characters",(()=>y(void 0,void 0,void 0,(function*(){const e=Tt();try{yield e.sync("31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844g:0"),t(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t(e.message).eq("Invalid outId: 31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844g:0")}})))),it("throw an error if num in rev is not a number",(()=>y(void 0,void 0,void 0,(function*(){const e=Tt();try{yield e.sync("31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844f:abc"),t(!0).eq(!1)}catch(e){if(!(e instanceof Error))throw new Error("Unknown error");t(e.message).eq("Invalid outId: 31770236f6e55558a8250100cff2b53d0389d26899155f03eca16c4bde9f844f:abc")}}))))})),describe("getBalance",(()=>{it("Should return the network",(()=>y(void 0,void 0,void 0,(function*(){const e=new dt;t(typeof(yield e.getBalance())).to.eq("number")}))))})),describe.skip("Query",(()=>{class o{constructor(){this.n=1}}let n;let r;it("Should work with a string encoded public key",(()=>y(void 0,void 0,void 0,(function*(){r=new dt({mnemonic:At,path:Kt()}),n=yield r.new(o);const e=r.getPublicKey();const i=yield r.query({publicKey:e});t(i.length).to.eq(1);const[s]=i;t(typeof s).to.eq("string"),t(s).to.eq(n._rev)})))),it("Should work with a public key",(()=>y(void 0,void 0,void 0,(function*(){r=new dt({mnemonic:At,path:Kt()}),n=yield r.new(o);const i=r.getPublicKey();const s=yield r.query({publicKey:new e.PublicKey(i)});t(s.length).to.eq(1);const[c]=s;t(typeof c).to.eq("string"),t(c).to.eq(n._rev)})))),it("Should work with a class",(()=>y(void 0,void 0,void 0,(function*(){r=new dt({mnemonic:At,path:Kt()}),n=yield r.new(o);const e=yield r.query({contract:o});t(e.length).to.be.above(1);const[i]=e;t(typeof i).to.eq("string"),t(e.includes(n._rev)).to.be.true})))),it("Should work with a class string",(()=>y(void 0,void 0,void 0,(function*(){r=new dt({mnemonic:At,path:Kt()}),n=yield r.new(o);const e=yield r.query({contract:o.toString()});t(e.length).to.be.above(1);const[i]=e;t(typeof i).to.eq("string"),t(e.includes(n._rev)).to.be.true})))),it("Should work with a class and a public key",(()=>y(void 0,void 0,void 0,(function*(){r=new dt({mnemonic:At,path:Kt()}),n=yield r.new(o);const e=r.getPublicKey();const i=yield r.query({contract:o,publicKey:e});t(i.length).to.eq(1);const[s]=i;t(typeof s).to.eq("string"),t(s).to.eq(n._rev)}))))})),describe("Deploy",(()=>{describe("Should create a smart object from a deployed module",(()=>y(void 0,void 0,void 0,(function*(){let e;let o;let n;let r;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){o=new dt({mnemonic:At,path:Kt()}),n=new dt({mnemonic:At,path:Kt()}),({db:r}=o);const t=yield o.deploy("export class A {\n        constructor() {\n          this.n = 1\n        }\n      }");e=yield o.new("A",[],t)})))),it("Should create a smart object when computer.new is called",(()=>y(void 0,void 0,void 0,(function*(){Bt(e,{n:{check:"value",type:"number",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(e._id).eq(e._rev),t(e._id).eq(e._root),t(Et(e._id)),t(Et(e._rev)),t(Et(e._root))})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const o=new st({db:r});t(yield o.get(e._rev)).to.deep.eq(e)})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const o=yield r.get([e._rev]);t(o).to.be.an("array").that.have.lengthOf(1),t(o[0].__index).to.deep.eq({obj:0}),t(o[0].__expt).to.eq("A"),te(o[0].__mdl)})))),it("should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield o.getLatestRev(e._id)).eq(e._rev)})))),it("should work with idsToRevs",(()=>y(void 0,void 0,void 0,(function*(){t(yield o.idsToRevs([e._id])).to.deep.eq([e._rev])})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield n.sync(e._rev)).to.deep.eq(e)}))))})))),describe("Should increment a smart counter from a deployed module",(()=>y(void 0,void 0,void 0,(function*(){let e;let o;let n;let r;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){o=new dt({mnemonic:At,path:Kt()}),n=new dt({mnemonic:At,path:Kt()}),({db:r}=o);const t=yield o.deploy("export class A {\n        constructor() {\n          this.n = 1\n        }\n\n        inc() {\n          this.n += 1\n        }\n      }");e=yield o.new("A",[],t),yield e.inc()})))),it("Should update the smart object when inc is called",(()=>y(void 0,void 0,void 0,(function*(){Bt(e,{n:{check:"value",type:"number",value:2},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(e._id).to.not.eq(e._rev),t(e._id).eq(e._root),t(Et(e._id)),t(Et(e._rev)),t(Et(e._root))})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const o=new st({db:r});t(yield o.get(e._rev)).to.deep.eq(e)})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const o=yield r.get([e._id]);t(o).to.be.an("array").that.have.lengthOf(1),t(o[0].__index).to.deep.eq({obj:0}),t(o[0].__expt).to.eq("A"),te(o[0].__mdl);const n=yield r.get([e._rev]);t(n).to.be.an("array").that.have.lengthOf(1),t(n[0].__index).to.deep.eq({obj:0}),t(n[0].__args).to.deep.eq([]),t(n[0].__func).to.eq("inc")})))),it("should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield o.getLatestRev(e._id)).eq(e._rev)})))),it("should work with idsToRevs",(()=>y(void 0,void 0,void 0,(function*(){t(yield o.idsToRevs([e._id])).to.deep.eq([e._rev])})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield n.sync(e._rev)).to.deep.eq(e)}))))})))),describe("Should return an object from a different class from a constructor or function call",(()=>y(void 0,void 0,void 0,(function*(){let e;let o;let n;let r;let i;before("Before Computer",(()=>y(void 0,void 0,void 0,(function*(){n=new dt({mnemonic:At,path:Kt()}),r=new dt({mnemonic:At,path:Kt()}),({db:i}=n);const t=yield n.deploy("\n        export class A {\n          constructor() {\n            this.n = 1\n          }\n        }\n\n        export class B {\n          constructor() {\n            this.m = new A()\n          }\n\n          getA() {\n            return new A()\n          }\n        }");o=yield n.new("B",[],t),e=yield o.getA()})))),it("Should update the smart object when inc is called",(()=>y(void 0,void 0,void 0,(function*(){t(e.n).to.eq(1),t(e._id).to.be.a("string"),t(e._rev).to.be.a("string"),t(e._root).to.be.a("string"),t(o._id).to.be.a("string"),t(o._rev).to.be.a("string"),t(o._root).to.be.a("string"),Bt(o.m,{n:{check:"value",type:"number",value:1},_id:{check:"type",type:"string"},_rev:{check:"type",type:"string"},_root:{check:"type",type:"string"}})})))),it("Should set the location correctly",(()=>y(void 0,void 0,void 0,(function*(){t(e._id).to.eq(e._rev),t(e._root).to.eq(o._root),t(Et(e._id)),t(Et(e._rev)),t(Et(e._root)),t(o._id).not.to.eq(o._rev),t(o._root).to.eq(e._root),t(Et(o._id)),t(Et(o._rev)),t(Et(o._root))})))),it("Should return the object if reader.get is called",(()=>y(void 0,void 0,void 0,(function*(){const o=new st({db:i});t(yield o.get(e._rev)).to.deep.eq(e)})))),it("Should broadcast a transaction with an output containing data",(()=>y(void 0,void 0,void 0,(function*(){const o=yield i.get([e._id]);t(o).to.be.an("array").that.have.lengthOf(1),t(o[0].__cls.substring(0,5)).to.eq("class")})))),it("should work with getLatestRev",(()=>y(void 0,void 0,void 0,(function*(){t(yield n.getLatestRev(e._id)).eq(e._rev)})))),it("should work with idsToRevs",(()=>y(void 0,void 0,void 0,(function*(){t(yield n.idsToRevs([e._id])).to.deep.eq([e._rev])})))),it("Should work with sync",(()=>y(void 0,void 0,void 0,(function*(){t(yield r.sync(e._rev)).to.deep.eq(e)}))))}))))}))}));
